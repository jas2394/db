<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
	<title>Fundamentals of Database Systems</title>
	<meta content="http://www.w3.org/1999/xhtml; charset=utf-8" http-equiv="Content-Type"/><link href="../stylesheet.css" type="text/css" rel="stylesheet"/><style type="text/css">
		@page { margin-bottom: 5.000000pt; margin-top: 5.000000pt; }</style></head>
  <body class="calibre">
<h3 id="filepos533169" class="calibre55"><span class="calibre47"><span class="bold"><a class="calibre35"></a><a id="filepos533250" class="calibre35"></a>chapter 6<br class="calibre54"/><br class="calibre54"/>The Relational Algebra and Relational Calculus</span></span></h3><div class="calibre56"> </div>
<p class="calibre37">In this chapter we discuss the two <em class="calibre13">formal languages</em> for the relational model: the relational algebra and the relational calculus. In contrast, <a href="dummy_split_019.html#filepos362078" class="calibre41">Chapters 4</a> and <a href="dummy_split_020.html#filepos448575" class="calibre41">5</a> described the <em class="calibre13">practical language</em> for the relational model, namely the SQL standard. Historically, the relational algebra and calculus were developed before the SQL language. In fact, in some ways, SQL is based on concepts from both the algebra and the calculus, as we shall see. Because most relational DBMSs use SQL as their language, we presented the SQL language first.</p>
<p class="calibre18">Recall from <a href="dummy_split_016.html#filepos180230" class="calibre41">Chapter 2</a> that a data model must include a set of operations to manipulate the database, in addition to the data model’s concepts for defining the database’s structure and constraints. We presented the structures and constraints of the formal relational model in <a href="dummy_split_018.html#filepos266551" class="calibre41">Chapter 3</a>. The basic set of operations for the relational model is the <strong class="calibre6">relational algebra</strong>. These operations enable a user to specify basic retrieval requests as <em class="calibre13">relational algebra expressions</em>. The result of a retrieval is a new relation, which may have been formed from one or more relations. The algebra operations thus produce new relations, which can be further manipulated using operations of the same algebra. A sequence of relational algebra operations forms a <strong class="calibre6">relational algebra expression</strong>, whose result will also be a relation that represents the result of a database query (or retrieval request).</p><div class="calibre31"> </div>
<p class="calibre18">The relational algebra is very important for several reasons. First, it provides a formal foundation for relational model operations. Second, and perhaps more important, it is used as a basis for implementing and optimizing queries in the query processing and optimization modules that are integral parts of relational database management systems (RDBMSs), as we shall discuss in <a href="dummy_split_040.html#filepos2126215" class="calibre41">Chapter 19</a>. Third, some of its concepts are incorporated into the SQL standard query language for RDBMSs.</p><div class="calibre31"> </div>
<p class="calibre18"><a id="filepos535667" class="calibre3"></a>Although most commercial RDBMSs in use today do not provide user interfaces for relational algebra queries, the core operations and functions in the internal modules of most relational systems are based on relational algebra operations. We will define these operations in detail in Sections 6.1 through 6.4 of this chapter.</p><div class="calibre31"> </div>
<p class="calibre18">Whereas the algebra defines a set of operations for the relational model, the <strong class="calibre6">relational calculus</strong> provides a higher-level <em class="calibre13">declarative</em> language for specifying relational queries. A relational calculus expression creates a new relation. In a relational calculus expression, there is <em class="calibre13">no order of operations</em> to specify how to retrieve the query result—only what information the result should contain. This is the main distinguishing feature between relational algebra and relational calculus. The relational calculus is important because it has a firm basis in mathematical logic and because the standard query language (SQL) for RDBMSs has some of its foundations in a variation of relational calculus known as the tuple relational calculus.<a id="filepos536833" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_110.html#filepos4350271" class="calibre41">1</a></sup></p><div class="calibre31"> </div>
<p class="calibre18">The relational algebra is often considered to be an integral part of the relational data model. Its operations can be divided into two groups. One group includes set operations from mathematical set theory; these are applicable because each relation is defined to be a set of tuples in the <em class="calibre13">formal</em> relational model (see Section 3.1). Set operations include UNION, INTERSECTION, SET DIFFERENCE, and CARTESIAN PRODUCT (also known as CROSS PRODUCT). The other group consists of operations developed specifically for relational databases—these include SELECT, PROJECT, and JOIN, among others. First, we describe the SELECT and PROJECT operations in Section 6.1 because they are <strong class="calibre6">unary operations</strong> that operate on single relations. Then we discuss set operations in Section 6.2. In Section 6.3, we discuss JOIN and other complex <strong class="calibre6">binary operations</strong>, which operate on two tables by combining related tuples (records) based on <em class="calibre13">join conditions</em>. The COMPANY relational database shown in <a href="dummy_split_018.html#filepos314167" class="calibre41">Figure 3.6</a> is used for our examples.</p><div class="calibre31"> </div>
<p class="calibre18">Some common database requests cannot be performed with the original relational algebra operations, so additional operations were created to express these requests. These include <strong class="calibre6">aggregate functions</strong>, which are operations that can <em class="calibre13">summarize</em> data from the tables, as well as additional types of JOIN and UNION operations, known as OUTER JOINs and OUTER UNIONs. These operations, which were added to the original relational algebra because of their importance to many database applications, are described in Section 6.4. We give examples of specifying queries that use relational operations in Section 6.5. Some of these same queries were used in <a href="dummy_split_019.html#filepos362078" class="calibre41">Chapters 4</a> and <a href="dummy_split_020.html#filepos448575" class="calibre41">5</a>. By using the same query numbers in this chapter, the reader can contrast how the same queries are written in the various query languages.</p><div class="calibre31"> </div>
<p class="calibre18">In Sections 6.6 and 6.7 we describe the other main formal language for relational databases, the <strong class="calibre6">relational calculus</strong>. There are two variations of relational calculus. The <em class="calibre13">tuple</em> relational calculus is described in Section 6.6 and the <em class="calibre13">domain</em> relational calculus is described in Section 6.7. Some of the SQL constructs discussed in <a href="dummy_split_019.html#filepos362078" class="calibre41">Chapters 4</a> and <a href="dummy_split_020.html#filepos448575" class="calibre41">5</a> are based on the tuple relational calculus. The relational calculus is a formal language, based on the branch of mathematical logic called predicate calculus.<a id="filepos539615" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_111.html#filepos4350577" class="calibre41">2</a></sup><a id="filepos539662" class="calibre3"></a>In tuple relational calculus, variables range over <em class="calibre13">tuples</em>, whereas in domain relational calculus, variables range over the <em class="calibre13">domains</em> (values) of attributes. In Appendix C we give an overview of the Query-By-Example (QBE) language, which is a graphical user-friendly relational language based on domain relational calculus. Section 6.8 summarizes the chapter.</p><div class="calibre31"> </div>
<p class="calibre18">For the reader who is interested in a less detailed introduction to formal relational languages, Sections 6.4, 6.6, and 6.7 may be skipped.</p><div class="calibre31"> </div>
<h4 id="filepos540268" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">6.1 Unary Relational Operations: SELECT and PROJECT</span></span></blockquote></h4><div class="calibre31"> </div>
<h5 class="calibre64"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">6.1.1 The SELECT Operation</span></span></blockquote></h5>
<p class="calibre18">The SELECT operation is used to choose a <em class="calibre13">subset</em> of the tuples from a relation that satisfies a <strong class="calibre6">selection condition</strong>.<a id="filepos540790" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_112.html#filepos4350847" class="calibre41">3</a></sup> One can consider the SELECT operation to be a <em class="calibre13">filter</em> that keeps only those tuples that satisfy a qualifying condition. Alternatively, we can consider the SELECT operation to <em class="calibre13">restrict</em> the tuples in a relation to only those tuples that satisfy the condition. The SELECT operation can also be visualized as a <em class="calibre13">horizontal partition</em> of the relation into two sets of tuples—those tuples that satisfy the condition and are selected, and those tuples that do not satisfy the condition and are discarded. For example, to select the EMPLOYEE tuples whose department is 4, or those whose salary is greater than $30,000, we can individually specify each of these two conditions with a SELECT operation as follows:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">σ<sub class="calibre65">Dno=4</sub>(EMPLOYEE)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">σ<sub class="calibre65">Salary&gt;30000</sub>(EMPLOYEE)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">In general, the SELECT operation is denoted by</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">σ<sub class="calibre65">&lt;selection condition&gt;</sub>(<em class="calibre13">R</em>)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">where the symbol σ (sigma) is used to denote the SELECT operator and the selection condition is a Boolean expression (condition) specified on the attributes of relation <em class="calibre13">R</em>. Notice that <em class="calibre13">R</em> is generally a <em class="calibre13">relational algebra expression</em> whose result is a relation—the simplest such expression is just the name of a database relation. The relation resulting from the SELECT operation has the <em class="calibre13">same attributes</em> as <em class="calibre13">R</em>.</p><div class="calibre31"> </div>
<p class="calibre18">The Boolean expression specified in &lt;selection condition&gt; is made up of a number of <strong class="calibre6">clauses</strong> of the form</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">&lt;attribute name&gt; &lt;comparison op&gt; &lt;constant value&gt;</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">or</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">&lt;attribute name&gt; &lt;comparison op&gt; &lt;attribute name&gt;</p></blockquote><div class="calibre31"> </div>
<p class="calibre18"><a id="filepos543242" class="calibre3"></a>where &lt;attribute name&gt; is the name of an attribute of <em class="calibre13">R</em>, &lt;comparison op&gt; is normally one of the operators {=,&lt;,≤,&gt;,≥,≠}, and &lt;constant value&gt; is a constant value from the attribute domain. Clauses can be connected by the standard Boolean operators <em class="calibre13">and</em>, <em class="calibre13">or</em>, and <em class="calibre13">not</em> to form a general selection condition. For example, to select the tuples for all employees who either work in department 4 and make over $25,000 per year, or work in department 5 and make over $30,000, we can specify the following SELECT operation:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">σ<sub class="calibre65">(Dno=4 <strong class="calibre6">AND</strong> Salary&gt;25000) <strong class="calibre6">OR</strong> (Dno=5 <strong class="calibre6">AND</strong> Salary&gt;30000)</sub>(EMPLOYEE)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">The result is shown in <a href="#filepos545808" class="calibre41">Figure 6.1(a)</a>.</p><div class="calibre31"> </div>
<p class="calibre18">Notice that all the comparison operators in the set {=,&lt;,≤,&gt;,≥,≠} can apply to attributes whose domains are <em class="calibre13">ordered values</em>, such as numeric or date domains. Domains of strings of characters are also considered to be ordered based on the collating sequence of the characters. If the domain of an attribute is a set of <em class="calibre13">unordered values</em>, then only the comparison operators in the set {=, ≠} can be used. An example of an unordered domain is the domain Color = { ‘red’, ‘blue’, ‘green’, ‘white’, ‘yellow’, ...}, where no order is specified among the various colors. Some domains allow additional types of comparison operators; for example, a domain of character strings may allow the comparison operator SUBSTRING_OF.</p><div class="calibre31"> </div>
<p class="calibre18">In general, the result of a SELECT operation can be determined as follows. The &lt;selection condition&gt; is applied independently to each <em class="calibre13">individual tuple t</em> in <em class="calibre13">R</em>. This is done by substituting each occurrence of an attribute <em class="calibre13">A<sub class="calibre65">i</sub></em> in the selection condition with its value in the tuple <em class="calibre13">t</em>[<em class="calibre13">A<sub class="calibre65">i</sub></em>]. If the condition evaluates to TRUE, then tuple <em class="calibre13">t</em> is <a id="filepos545559" class="calibre3"></a><strong class="calibre6">selected</strong>. All the selected tuples appear in the result of the SELECT operation. The Boolean conditions AND, OR, and NOT have their normal interpretation, as follows:</p><div class="calibre31"> </div>
<p class="calibre7"><a id="filepos545808" class="calibre3"></a><img alt="image" src="../images/00114.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 6.1</strong><br class="calibre1"/>Results of SELECT and PROJECT operations. (a) σ<sub class="calibre65">(Dno=4 <strong class="calibre6">AND</strong> Salary&gt;25000) OR (Dno=5 <strong class="calibre6">AND</strong> Salary&gt;30000)</sub> (EMPLOYEE). (b) π<sub class="calibre65">Lname, Fname, Salary</sub>(EMPLOYEE). (c) π<sub class="calibre65">Sex, Salary</sub>(EMPLOYEE).</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> (cond1 <strong class="calibre6">AND</strong> cond2) is TRUE if both (cond1) and (cond2) are TRUE; otherwise, it is FALSE.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> (cond1 <strong class="calibre6">OR</strong> cond2) is TRUE if either (cond1) or (cond2) or both are TRUE; otherwise, it is FALSE.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> (<strong class="calibre6">NOT</strong> cond) is TRUE if cond is FALSE; otherwise, it is FALSE.</p></blockquote>
<p class="calibre58">The SELECT operator is <strong class="calibre6">unary</strong>; that is, it is applied to a single relation. Moreover, the selection operation is applied to <em class="calibre13">each tuple individually</em>; hence, selection conditions cannot involve more than one tuple. The <strong class="calibre6">degree</strong> of the relation resulting from a SELECT operation—its number of attributes—is the same as the degree of <em class="calibre13">R</em>. The number of tuples in the resulting relation is always <em class="calibre13">less than or equal to</em> the number of tuples in <em class="calibre13">R</em>. That is, |σ<em class="calibre13"><sub class="calibre65">c</sub></em> (<em class="calibre13">R</em>)| ≤ |<em class="calibre13">R</em>| for any condition <em class="calibre13">C</em>. The fraction of tuples selected by a selection condition is referred to as the <strong class="calibre6">selectivity</strong> of the condition.</p>
<p class="calibre58">Notice that the SELECT operation is <strong class="calibre6">commutative</strong>; that is,</p>
<blockquote class="calibre45"><p class="calibre18">σ<sub class="calibre65">&lt;cond1&gt;</sub>(σ<sub class="calibre65">&lt;cond2&gt;</sub>(<em class="calibre13">R</em>)) = σ<sub class="calibre65">&lt;cond2&gt;</sub>(σ<sub class="calibre65">&lt;cond1&gt;</sub>(<em class="calibre13">R</em>))</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">Hence, a sequence of SELECTs can be applied in any order. In addition, we can always combine a <strong class="calibre6">cascade</strong> (or <strong class="calibre6">sequence</strong>) of SELECT operations into a single SELECT operation with a conjunctive (AND) condition; that is,</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">σ<sub class="calibre65">&lt;cond1&gt;</sub>(σ<sub class="calibre65">&lt;cond2&gt;</sub>(...(σ<sub class="calibre65">&lt;cond<em class="calibre13">n</em>&gt;</sub>(<em class="calibre13">R</em>))...)) = σ<sub class="calibre65">&lt;cond1&gt; <strong class="calibre6">AND</strong>&lt;cond2&gt; <strong class="calibre6">AND</strong>...<strong class="calibre6">AND</strong> &lt;cond<em class="calibre13">n</em>&gt;</sub> (<em class="calibre13">R</em>)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">In SQL, the SELECT condition is typically specified in the WHERE clause of a query. For example, the following operation:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">σ<sub class="calibre65">Dno=4 <strong class="calibre6">AND</strong> Salary&gt;25000</sub> (EMPLOYEE)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">would correspond to the following SQL query:</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre17"><img alt="image" src="../images/00115.jpg" class="calibre16"/></p></blockquote>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">6.1.2 The PROJECT Operation</span></span></blockquote></h5>
<p class="calibre18">If we think of a relation as a table, the SELECT operation chooses some of the <em class="calibre13">rows</em> from the table while discarding other rows. The <strong class="calibre6">PROJECT</strong> operation, on the other hand, selects certain <em class="calibre13">columns</em> from the table and discards the other columns. If we are interested in only certain attributes of a relation, we use the PROJECT operation to <em class="calibre13">project</em> the relation over these attributes only. Therefore, the result of the PROJECT operation can be visualized as a <em class="calibre13">vertical partition</em> of the relation into two relations: one has the needed columns (attributes) and contains the result of the operation, and the other contains the discarded columns. For example, to list each employee’s first and last name and salary, we can use the PROJECT operation as follows:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">π<sub class="calibre65">Lname, Fname, Salary</sub>(EMPLOYEE)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18"><a id="filepos550490" class="calibre3"></a>The resulting relation is shown in <a href="#filepos545808" class="calibre41">Figure 6.1(b)</a>. The general form of the PROJECT operation is</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">π<sub class="calibre65">&lt;attribute list&gt;</sub>(<em class="calibre13">R</em>)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">where π (pi) is the symbol used to represent the PROJECT operation, and &lt;attribute list&gt; is the desired sublist of attributes from the attributes of relation <em class="calibre13">R</em>. Again, notice that <em class="calibre13">R</em> is, in general, a <em class="calibre13">relational algebra expression</em> whose result is a relation, which in the simplest case is just the name of a database relation. The result of the PROJECT operation has only the attributes specified in &lt;attribute list&gt; <em class="calibre13">in the same order as they appear in the list</em>. Hence, its <strong class="calibre6">degree</strong> is equal to the number of attributes in &lt;attribute list&gt;.</p><div class="calibre31"> </div>
<p class="calibre18">If the attribute list includes only nonkey attributes of <em class="calibre13">R</em>, duplicate tuples are likely to occur. The PROJECT operation <em class="calibre13">removes any duplicate tuples</em>, so the result of the PROJECT operation is a set of distinct tuples, and hence a valid relation. This is known as <strong class="calibre6">duplicate elimination</strong>. For example, consider the following PROJECT operation:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">π<sub class="calibre65">Sex, Salary</sub>(EMPLOYEE)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">The result is shown in <a href="#filepos545808" class="calibre41">Figure 6.1(c)</a>. Notice that the tuple &lt;‘F’, 25000&gt; appears only once in <a href="#filepos545808" class="calibre41">Figure 6.1(c)</a>, even though this combination of values appears twice in the EMPLOYEE relation. Duplicate elimination involves sorting or some other technique to detect duplicates and thus adds more processing. If duplicates are not eliminated, the result would be a <strong class="calibre6">multiset</strong> or <strong class="calibre6">bag</strong> of tuples rather than a set. This was not permitted in the formal relational model, but is allowed in SQL (see Section 4.3).</p><div class="calibre31"> </div>
<p class="calibre18">The number of tuples in a relation resulting from a PROJECT operation is always less than or equal to the number of tuples in <em class="calibre13">R</em>. If the projection list is a superkey of <em class="calibre13">R</em>—that is, it includes some key of <em class="calibre13">R</em>—the resulting relation has the <em class="calibre13">same number</em> of tuples as <em class="calibre13">R</em>. Moreover,</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">π<sub class="calibre65">&lt;list1&gt;</sub> (π<sub class="calibre65">&lt;list2&gt;</sub>(<em class="calibre13">R</em>)) = π<sub class="calibre65">&lt;list1&gt;</sub>(<em class="calibre13">R</em>)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">as long as &lt;list2&gt; contains the attributes in &lt;list1&gt;; otherwise, the left-hand side is an incorrect expression. It is also noteworthy that commutativity <em class="calibre13">does not</em> hold on PROJECT.</p><div class="calibre31"> </div>
<p class="calibre18">In SQL, the PROJECT attribute list is specified in the SELECT clause of a query. For example, the following operation:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">π<sub class="calibre65">Sex, Salary</sub>(EMPLOYEE)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">would correspond to the following SQL query:</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre17"><img alt="image" src="../images/00116.jpg" class="calibre16"/></p></blockquote>
<p class="calibre18">Notice that if we remove the keyword <strong class="calibre6">DISTINCT</strong> from this SQL query, then duplicates will not be eliminated. This option is not available in the formal relational algebra.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1"><a id="filepos554412" class="calibre3"></a>6.1.3 Sequences of Operations and the RENAME Operation</span></span></blockquote></h5>
<p class="calibre18">The relations shown in <a href="#filepos545808" class="calibre41">Figure 6.1</a> that depict operation results do not have any names. In general, for most queries, we need to apply several relational algebra operations one after the other. Either we can write the operations as a single <strong class="calibre6">relational algebra expression</strong> by nesting the operations, or we can apply one operation at a time and create intermediate result relations. In the latter case, we must give names to the relations that hold the intermediate results. For example, to retrieve the first name, last name, and salary of all employees who work in department number 5, we must apply a SELECT and a PROJECT operation. We can write a single relational algebra expression, also known as an <strong class="calibre6">in-line expression</strong>, as follows:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">π<sub class="calibre65">Fname, Lname, Salary</sub>(σ<sub class="calibre65">Dno=5</sub>(EMPLOYEE))</p></blockquote><div class="calibre31"> </div>
<p class="calibre18"><a href="#filepos556702" class="calibre41">Figure 6.2(a)</a> shows the result of this in-line relational algebra expression. Alternatively, we can explicitly show the sequence of operations, giving a name to each intermediate relation, as follows:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">DEP5_EMPS ← σ<sub class="calibre65">Dno=5</sub>(EMPLOYEE)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">RESULT ← π<sub class="calibre65">Fname, Lname, Salary</sub>(DEP5_EMPS)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">It is sometimes simpler to break down a complex sequence of operations by specifying intermediate result relations than to write a single relational algebra expression. We can also use this technique to <strong class="calibre6">rename</strong> the attributes in the intermediate and <a id="filepos556422" class="calibre3"></a>result relations. This can be useful in connection with more complex operations such as UNION and JOIN, as we shall see. To rename the attributes in a relation, we simply list the new attribute names in parentheses, as in the following example:</p><div class="calibre31"> </div>
<p id="filepos556702" class="calibre7"><img alt="image" src="../images/00117.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 6.2</strong><br class="calibre1"/>Results of a sequence of operations. (a) π<sub class="calibre65">Fname, Lname, Salary</sub> (σ<sub class="calibre65">Dno=5</sub>(EMPLOYEE)). (b) Using intermediate relations and renaming of attributes.</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">TEMP ← σ<sub class="calibre65">Dno=5</sub>(EMPLOYEE)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><em class="calibre13">R</em>(First_name, Last_name, Salary) ← π<sub class="calibre65">Fname, Lname, Salary</sub>(TEMP)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">These two operations are illustrated in <a href="#filepos556702" class="calibre41">Figure 6.2(b)</a>.</p><div class="calibre31"> </div>
<p class="calibre18">If no renaming is applied, the names of the attributes in the resulting relation of a SELECT operation are the same as those in the original relation and in the same order. For a PROJECT operation with no renaming, the resulting relation has the same attribute names as those in the projection list and in the same order in which they appear in the list.</p><div class="calibre31"> </div>
<p class="calibre18">We can also define a formal <strong class="calibre6">RENAME</strong> operation—which can rename either the relation name or the attribute names, or both—as a unary operator. The general RENAME operation when applied to a relation <em class="calibre13">R</em> of degree <em class="calibre13">n</em> is denoted by any of the following three forms:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">ρ<sub class="calibre65"><em class="calibre13">S</em>(<em class="calibre13">B</em>1, <em class="calibre13">B</em>2, ..., <em class="calibre13">Bn</em>)</sub>(<em class="calibre13">R</em>) or ρ<sub class="calibre65"><em class="calibre13">S</em></sub>(<em class="calibre13">R</em>) or ρ<sub class="calibre65">(<em class="calibre13">B</em>1, <em class="calibre13">B</em>2, ..., <em class="calibre13">Bn</em>)</sub>(<em class="calibre13">R</em>)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">where the symbol ρ (rho) is used to denote the RENAME operator, <em class="calibre13">S</em> is the new relation name, and <em class="calibre13">B</em><sub class="calibre65">1</sub>, <em class="calibre13">B</em><sub class="calibre65">2</sub>, ..., <em class="calibre13">B<sub class="calibre65">n</sub></em> are the new attribute names. The first expression renames both the relation and its attributes, the second renames the relation only, and the third renames the attributes only. If the attributes of <em class="calibre13">R</em> are (<em class="calibre13">A</em><sub class="calibre65">1</sub>, <em class="calibre13">A</em><sub class="calibre65">2</sub>, ...,<em class="calibre13">A<sub class="calibre65">n</sub></em>) in that order, then each <em class="calibre13">A<sub class="calibre65">i</sub></em> is renamed as <em class="calibre13">B<sub class="calibre65">i</sub></em>.</p><div class="calibre31"> </div>
<p class="calibre18">In SQL, a single query typically represents a complex relational algebra expression. Renaming in SQL is accomplished by aliasing using <strong class="calibre6">AS</strong>, as in the following example:</p><div class="calibre31"> </div>
<p class="calibre7"><img alt="image" src="../images/00118.jpg" class="calibre16"/></p>
<h4 id="filepos559546" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">6.2 Relational Algebra Operations from Set Theory</span></span></blockquote></h4><div class="calibre31"> </div>
<h5 class="calibre64"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">6.2.1 The UNION, INTERSECTION, and MINUS Operations</span></span></blockquote></h5>
<p class="calibre18">The next group of relational algebra operations are the standard mathematical operations on sets. For example, to retrieve the Social Security numbers of all employees who either work in department 5 or directly supervise an employee who works in department 5, we can use the UNION operation as follows:<a id="filepos560253" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_113.html#filepos4351148" class="calibre41">4</a></sup></p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><a class="calibre3"></a>DEP5_EMPS ← σ<sub class="calibre65">Dno=5</sub>(EMPLOYEE)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">RESULT1 ← π<sub class="calibre65">Ssn</sub>(DEP5_EMPS)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">RESULT2(Ssn) ← π<sub class="calibre65">Super_ssn</sub>(DEP5_EMPS)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">RESULT ← RESULT1 <img alt="image" src="../images/00024.jpg" class="calibre16"/> RESULT2</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">The relation RESULT1 has the Ssn of all employees who work in department 5, whereas RESULT2 has the Ssn of all employees who directly supervise an employee who works in department 5. The UNION operation produces the tuples that are in either RESULT1 or RESULT2 or both (see <a href="#filepos564163" class="calibre41">Figure 6.3</a>), while eliminating any duplicates. Thus, the Ssn value ‘333445555’ appears only once in the result.</p><div class="calibre31"> </div>
<p class="calibre18">Several set theoretic operations are used to merge the elements of two sets in various ways, including <strong class="calibre6">UNION</strong>, <strong class="calibre6">INTERSECTION</strong>, and <strong class="calibre6">SET DIFFERENCE</strong> (also called <strong class="calibre6">MINUS</strong> or <strong class="calibre6">EXCEPT</strong>). These are <strong class="calibre6">binary</strong> operations; that is, each is applied to two sets (of tuples). When these operations are adapted to relational databases, the two relations on which any of these three operations are applied must have the same <strong class="calibre6">type of tuples</strong>; this condition has been called <em class="calibre13">union compatibility</em> or <em class="calibre13">type compatibility</em>. Two relations <em class="calibre13">R</em>(<em class="calibre13">A</em><sub class="calibre65">1</sub>, <em class="calibre13">A</em><sub class="calibre65">2</sub>, ...,<em class="calibre13">A<sub class="calibre65">n</sub></em>) and <em class="calibre13">S</em>(<em class="calibre13">B</em><sub class="calibre65">1</sub>, <em class="calibre13">B</em><sub class="calibre65">2</sub>, ..., <em class="calibre13">B<sub class="calibre65">n</sub></em>) are said to be <strong class="calibre6">union compatible</strong> (or <strong class="calibre6">type compatible</strong>) if they have the same degree <em class="calibre13">n</em> and if dom(<em class="calibre13">A<sub class="calibre65">i</sub></em>) = dom(<em class="calibre13">B<sub class="calibre65">i</sub></em>) for 1 ≤ <em class="calibre13">i</em> ≤ <em class="calibre13">n</em>. This means that the two relations have the same number of attributes and each corresponding pair of attributes has the same domain.</p><div class="calibre31"> </div>
<p class="calibre18">We can define the three operations UNION, INTERSECTION, and SET DIFFERENCE on two union-compatible relations <em class="calibre13">R</em> and <em class="calibre13">S</em> as follows:</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> UNION: The result of this operation, denoted by <em class="calibre13">R</em>
<img alt="image" src="../images/00024.jpg" class="calibre16"/><em class="calibre13">S</em>, is a relation that includes all tuples that are either in <em class="calibre13">R</em> or in <em class="calibre13">S</em> or in both <em class="calibre13">R</em> and <em class="calibre13">S</em>. Duplicate tuples are eliminated.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> INTERSECTION: The result of this operation, denoted by <em class="calibre13">R</em>
<img alt="image" src="../images/00119.jpg" class="calibre16"/><em class="calibre13">S</em>, is a relation that includes all tuples that are in both <em class="calibre13">R</em> and <em class="calibre13">S</em>.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> SET DIFFERENCE (or MINUS): The result of this operation, denoted by <em class="calibre13">R</em> – <em class="calibre13">S</em>, is a relation that includes all tuples that are in <em class="calibre13">R</em> but not in <em class="calibre13">S</em>.</p></blockquote>
<p class="calibre18">We will adopt the convention that the resulting relation has the same attribute names as the <em class="calibre13">first</em> relation <em class="calibre13">R</em>. It is always possible to rename the attributes in the result using the rename operator.</p><div class="calibre31"> </div>
<p id="filepos564163" class="calibre7"><img alt="image" src="../images/00120.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 6.3</strong><br class="calibre1"/>Result of the UNION operation RESULT ← RESULT1 <img alt="image" src="../images/00024.jpg" class="calibre16"/> RESULT2.</p><div class="calibre31"> </div>
<p class="calibre18"><a class="calibre3"></a><a href="#filepos566726" class="calibre41">Figure 6.4</a> illustrates the three operations. The relations STUDENT and INSTRUCTOR in <a href="#filepos566726" class="calibre41">Figure 6.4(a)</a> are union compatible and their tuples represent the names of students and the names of instructors, respectively. The result of the UNION operation in <a href="#filepos566726" class="calibre41">Figure 6.4(b)</a> shows the names of all students and instructors. Note that duplicate tuples appear only once in the result. The result of the INTERSECTION operation (<a href="#filepos566726" class="calibre41">Figure 6.4(c)</a>) includes only those who are both students and instructors.</p><div class="calibre31"> </div>
<p class="calibre18">Notice that both UNION and INTERSECTION are <em class="calibre13">commutative operations</em>; that is,</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><em class="calibre13">R</em>
<img alt="image" src="../images/00024.jpg" class="calibre16"/><em class="calibre13">S</em> = <em class="calibre13">S</em>
<img alt="image" src="../images/00024.jpg" class="calibre16"/><em class="calibre13">R</em>  and  <em class="calibre13">R</em>
<img alt="image" src="../images/00119.jpg" class="calibre16"/><em class="calibre13">S</em> = <em class="calibre13">S</em>
<img alt="image" src="../images/00119.jpg" class="calibre16"/><em class="calibre13">R</em></p></blockquote><div class="calibre31"> </div>
<p class="calibre18">Both UNION and INTERSECTION can be treated as <em class="calibre13">n</em>-ary operations applicable to any number of relations because both are also <em class="calibre13">associative operations;</em> that is,</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><em class="calibre13">R</em>
<img alt="image" src="../images/00024.jpg" class="calibre16"/> (<em class="calibre13">S</em>
<img alt="image" src="../images/00024.jpg" class="calibre16"/><em class="calibre13">T</em>) = (<em class="calibre13">R</em>
<img alt="image" src="../images/00024.jpg" class="calibre16"/><em class="calibre13">S</em>) <img alt="image" src="../images/00024.jpg" class="calibre16"/><em class="calibre13">T</em>  and  (<em class="calibre13">R</em>
<img alt="image" src="../images/00119.jpg" class="calibre16"/><em class="calibre13">S</em>) <img alt="image" src="../images/00119.jpg" class="calibre16"/><em class="calibre13">T</em> = <em class="calibre13">R</em>
<img alt="image" src="../images/00119.jpg" class="calibre16"/> (<em class="calibre13">S</em>
<img alt="image" src="../images/00119.jpg" class="calibre16"/><em class="calibre13">T</em>)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">The MINUS operation is <em class="calibre13">not commutative;</em> that is, in general,</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><em class="calibre13">R</em> − <em class="calibre13">S</em> ≠ <em class="calibre13">S</em> – <em class="calibre13">R</em></p></blockquote><div class="calibre31"> </div>
<p id="filepos566726" class="calibre7"><img alt="image" src="../images/00121.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 6.4</strong><br class="calibre1"/>The set operations UNION, INTERSECTION, and MINUS. (a) Two union-compatible relations. (b) STUDENT <img alt="image" src="../images/00024.jpg" class="calibre16"/> INSTRUCTOR. (c) STUDENT <img alt="image" src="../images/00119.jpg" class="calibre16"/> INSTRUCTOR. (d) STUDENT – INSTRUCTOR. (e) INSTRUCTOR – STUDENT.</p><div class="calibre31"> </div>
<p class="calibre18"><a id="filepos567211" class="calibre3"></a><a href="#filepos566726" class="calibre41">Figure 6.4(d)</a> shows the names of students who are not instructors, and <a href="#filepos566726" class="calibre41">Figure 6.4(e)</a> shows the names of instructors who are not students.</p><div class="calibre31"> </div>
<p class="calibre18">Note that INTERSECTION can be expressed in terms of union and set difference as follows:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><em class="calibre13">R</em>
<img alt="image" src="../images/00119.jpg" class="calibre16"/><em class="calibre13">S</em> = ((<em class="calibre13">R</em>
<img alt="image" src="../images/00024.jpg" class="calibre16"/><em class="calibre13">S</em>) − (<em class="calibre13">R</em>−<em class="calibre13">S</em>)) − (<em class="calibre13">S</em> − <em class="calibre13">R</em>)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">In SQL, there are three operations—UNION, INTERSECT, and EXCEPT—that correspond to the set operations described here. In addition, there are multiset operations (UNION ALL, INTERSECT ALL, and EXCEPT ALL) that do not eliminate duplicates (see Section 4.3.4).</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">6.2.2 The CARTESIAN PRODUCT (CROSS PRODUCT) Operation</span></span></blockquote></h5>
<p class="calibre18">Next, we discuss the <strong class="calibre6">CARTESIAN PRODUCT</strong> operation—also known as <strong class="calibre6">CROSS PRODUCT</strong> or <strong class="calibre6">CROSS JOIN</strong>–which is denoted by ×. This is also a binary set operation, but the relations on which it is applied do <em class="calibre13">not</em> have to be union compatible. In its binary form, this set operation produces a new element by combining every member (tuple) from one relation (set) with every member (tuple) from the other relation (set). In general, the result of <em class="calibre13">R</em> (<em class="calibre13">A</em><sub class="calibre65">1</sub>, <em class="calibre13">A</em><sub class="calibre65">2</sub>, ...,<em class="calibre13">A<sub class="calibre65">n</sub></em>) × <em class="calibre13">S</em>(<em class="calibre13">B</em><sub class="calibre65">1</sub>, <em class="calibre13">B</em><sub class="calibre65">2</sub>, ..., <em class="calibre13">B<sub class="calibre65">m</sub></em>) is a relation <em class="calibre13">Q</em> with degree <em class="calibre13">n</em> +<em class="calibre13">m</em> attributes <em class="calibre13">Q</em>(<em class="calibre13">A</em><sub class="calibre65">1</sub>, <em class="calibre13">A</em><sub class="calibre65">2</sub>, ...,<em class="calibre13">A<sub class="calibre65">n</sub></em>, <em class="calibre13">B</em><sub class="calibre65">1</sub>, <em class="calibre13">B</em><sub class="calibre65">2</sub>, ..., <em class="calibre13">B<sub class="calibre65">m</sub></em>), in that order. The resulting relation <em class="calibre13">Q</em> has one tuple for each combination of tuples—one from <em class="calibre13">R</em> and one from <em class="calibre13">S</em>. Hence, if <em class="calibre13">R</em> has <em class="calibre13">n</em><sub class="calibre65">R</sub> tuples (denoted as |<em class="calibre13">R</em>| = <em class="calibre13">n</em><sub class="calibre65">R</sub>), and <em class="calibre13">S</em> has <em class="calibre13">n</em><sub class="calibre65">S</sub> tuples, then <em class="calibre13">R</em> × <em class="calibre13">S</em> will have <em class="calibre13">n</em><sub class="calibre65">R</sub> * <em class="calibre13">n</em><sub class="calibre65">S</sub> tuples.</p><div class="calibre31"> </div>
<p class="calibre18">The <em class="calibre13">n</em>-ary CARTESIAN PRODUCT operation is an extension of the above concept, which produces new tuples by concatenating all possible combinations of tuples from <em class="calibre13">n</em> underlying relations.</p><div class="calibre31"> </div>
<p class="calibre18">In general, the CARTESIAN PRODUCT operation applied by itself is generally meaningless. It is mostly useful when followed by a selection that matches values of attributes coming from the component relations. For example, suppose that we want to retrieve a list of names of each female employee’s dependents. We can do this as follows:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">FEMALE_EMPS ← σ<sub class="calibre65">Sex=‘F’</sub>(EMPLOYEE)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">EMPNAMES ← π<sub class="calibre65">Fname, Lname, Ssn</sub>(FEMALE_EMPS)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">EMP_DEPENDENTS ← EMPNAMES × DEPENDENT</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">ACTUAL_DEPENDENTS ← σ<sub class="calibre65">Ssn=Essn</sub>(EMP_DEPENDENTS)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">RESULT ← π<sub class="calibre65">Fname, Lname, Dependent_name</sub>(ACTUAL_DEPENDENTS)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">The resulting relations from this sequence of operations are shown in <a href="#filepos572317" class="calibre41">Figure 6.5</a>. The EMP_DEPENDENTS relation is the result of applying the CARTESIAN PRODUCT operation to EMPNAMES from <a href="#filepos572317" class="calibre41">Figure 6.5</a> with DEPENDENT from <a href="dummy_split_018.html#filepos314167" class="calibre41">Figure 3.6</a>. In EMP_DEPENDENTS, every tuple from EMPNAMES is combined with every tuple from DEPENDENT, giving a result that is not very meaningful (every dependent is combined with <em class="calibre13">every</em> female employee). We want to combine a female employee tuple only with her particular dependents—namely, the DEPENDENT tuples whose Essn value match the Ssn value of the EMPLOYEE tuple. The ACTUAL_DEPENDENTS relation accomplishes this. The EMP_DEPENDENTS relation is a good example of the case where relational algebra can be correctly applied to yield results that make no sense at all. It is the responsibility of the user to make sure to apply only meaningful operations to relations.</p><div class="calibre31"> </div>
<p class="calibre7"><a class="calibre3"></a><a id="filepos572317" class="calibre3"></a><img alt="image" src="../images/00122.jpg" class="calibre16"/></p>
<p class="calibre7"><img alt="image" src="../images/00123.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 6.5</strong><br class="calibre1"/>The Cartesian Product (Cross Product) operation.</p><div class="calibre31"> </div>
<p class="calibre58"><a id="filepos572634" class="calibre3"></a>The CARTESIAN PRODUCT creates tuples with the combined attributes of two relations. We can SELECT <em class="calibre13">related tuples only</em> from the two relations by specifying an appropriate selection condition after the Cartesian product, as we did in the preceding example. Because this sequence of CARTESIAN PRODUCT followed by SELECT is quite commonly used to combine <em class="calibre13">related tuples</em> from two relations, a special operation, called JOIN, was created to specify this sequence as a single operation. We discuss the JOIN operation next.</p>
<p class="calibre18">In SQL, CARTESIAN PRODUCT can be realized by using the CROSS JOIN option in joined tables (see Section 5.1.6). Alternatively, if there are two tables in the WHERE clause and there is no corresponding join condition in the query, the result will also be the CARTESIAN PRODUCT of the two tables (see Q10 in Section 4.3.3).</p><div class="calibre31"> </div>
<h4 id="filepos573580" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">6.3 Binary Relational Operations: JOIN and DIVISION</span></span></blockquote></h4><div class="calibre31"> </div>
<h5 class="calibre64"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">6.3.1 The JOIN Operation</span></span></blockquote></h5>
<p class="calibre18">The <strong class="calibre6">JOIN</strong> operation, denoted by <img alt="image" src="../images/00124.jpg" class="calibre16"/>, is used to combine <em class="calibre13">related tuples</em> from two relations into single “longer” tuples. This operation is very important for any relational database with more than a single relation because it allows us to process relationships among relations. To illustrate JOIN, suppose that we want to retrieve the name of the manager of each department. To get the manager’s name, we need to combine each department tuple with the employee tuple whose Ssn value matches the Mgr_ssn value in the department tuple. We do this by using the JOIN operation and then projecting the result over the necessary attributes, as follows:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">DEPT_MGR ← DEPARTMENT <img alt="image" src="../images/00124.jpg" class="calibre16"/><sub class="calibre65">Mgr_ssn=Ssn</sub>EMPLOYEE</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">RESULT ← <em class="calibre13">π</em><sub class="calibre65">Dname, Lname, Fname</sub>(DEPT_MGR)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">The first operation is illustrated in <a href="#filepos576116" class="calibre41">Figure 6.6</a>. Note that Mgr_ssn is a foreign key of the DEPARTMENT relation that references Ssn, the primary key of the EMPLOYEE relation. This referential integrity constraint plays a role in having matching tuples in the referenced relation EMPLOYEE.</p><div class="calibre31"> </div>
<p class="calibre18">The JOIN operation can be specified as a CARTESIAN PRODUCT operation followed by a SELECT operation. However, JOIN is very important because it is used very frequently when specifying database queries. Consider the earlier example illustrating CARTESIAN PRODUCT, which included the following sequence of operations:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">EMP_DEPENDENTS ← EMPNAMES × DEPENDENT</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">ACTUAL_DEPENDENTS ← σ<sub class="calibre65">Ssn=Essn</sub>(EMP_DEPENDENTS)</p></blockquote><div class="calibre31"> </div>
<p id="filepos576116" class="calibre7"><a class="calibre3"></a><img alt="image" src="../images/00125.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 6.6</strong><br class="calibre1"/>Result of the JOIN operation DEPT_MGR ← DEPARTMENT <img alt="image" src="../images/00124.jpg" class="calibre16"/><sub class="calibre65">Mgr_ssn=Ssn</sub>EMPLOYEE.</p><div class="calibre31"> </div>
<p class="calibre18">These two operations can be replaced with a single JOIN operation as follows:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">ACTUAL_DEPENDENTS ← EMPNAMES <img alt="image" src="../images/00124.jpg" class="calibre16"/><sub class="calibre65">Ssn=Essn</sub>DEPENDENT</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">The general form of a JOIN operation on two relations<a id="filepos576841" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_114.html#filepos4351519" class="calibre41">5</a></sup><em class="calibre13">R</em> (<em class="calibre13">A</em><sub class="calibre65">1</sub>, <em class="calibre13">A</em><sub class="calibre65">2</sub>, ...,<em class="calibre13">A<sub class="calibre65">n</sub></em>) and <em class="calibre13">S</em>(<em class="calibre13">B</em><sub class="calibre65">1</sub>, <em class="calibre13">B</em><sub class="calibre65">2</sub>, ..., <em class="calibre13">B</em><sub class="calibre65">m</sub>) is</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><em class="calibre13">R</em>
<img alt="image" src="../images/00124.jpg" class="calibre16"/><sub class="calibre65">&lt;join condition&gt;</sub><em class="calibre13">S</em></p></blockquote><div class="calibre31"> </div>
<p class="calibre18">The result of the JOIN is a relation <em class="calibre13">Q</em> with <em class="calibre13">n</em> + <em class="calibre13">m</em> attributes <em class="calibre13">Q</em>(<em class="calibre13">A</em><sub class="calibre65">1</sub>, <em class="calibre13">A</em><sub class="calibre65">2</sub>, ...,<em class="calibre13">A<sub class="calibre65">n</sub></em>, <em class="calibre13">B</em><sub class="calibre65">1</sub>, <em class="calibre13">B</em><sub class="calibre65">2</sub>, ..., <em class="calibre13">B<sub class="calibre65">m</sub></em>) in that order; <em class="calibre13">Q</em> has one tuple for each combination of tuples—one from <em class="calibre13">R</em> and one from <em class="calibre13">S—whenever the combination satisfies the join condition</em>. This is the main difference between CARTESIAN PRODUCT and JOIN. In JOIN, only combinations of tuples <em class="calibre13">satisfying the join condition</em> appear in the result, whereas in the CARTESIAN PRODUCT <em class="calibre13">all</em> combinations of tuples are included in the result. The join condition is specified on attributes from the two relations <em class="calibre13">R</em> and <em class="calibre13">S</em> and is evaluated for each combination of tuples. Each tuple combination for which the join condition evaluates to TRUE is included in the resulting relation <em class="calibre13">Q as a single combined tuple</em>.</p><div class="calibre31"> </div>
<p class="calibre18">A general join condition is of the form</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">&lt;condition&gt; <strong class="calibre6">AND</strong> &lt;condition&gt; <strong class="calibre6">AND</strong>...<strong class="calibre6">AND</strong> &lt;condition&gt;</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">where each &lt;condition&gt; is of the form <em class="calibre13">A<sub class="calibre65">i</sub> θ B<sub class="calibre65">j</sub></em>, <em class="calibre13">A<sub class="calibre65">i</sub></em> is an attribute of <em class="calibre13">R</em>, <em class="calibre13">B<sub class="calibre65">j</sub></em> is an attribute of <em class="calibre13">S</em>, <em class="calibre13">A<sub class="calibre65">i</sub></em> and <em class="calibre13">B<sub class="calibre65">j</sub></em> have the same domain, and θ (theta) is one of the comparison operators {=, &lt;, ≤, &gt;, ≥, ≠}. A JOIN operation with such a general join condition is called a <strong class="calibre6">THETA JOIN</strong>. Tuples whose join attributes are NULL or for which the join condition is FALSE <em class="calibre13">do not</em> appear in the result. In that sense, the JOIN operation does <em class="calibre13">not</em> necessarily preserve all of the information in the participating relations, because tuples that do not get combined with matching ones in the other relation do not appear in the result.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1"><a id="filepos579603" class="calibre3"></a>6.3.2 Variations of JOIN: The EQUIJOIN and NATURAL JOIN</span></span></blockquote></h5>
<p class="calibre18">The most common use of JOIN involves join conditions with equality comparisons only. Such a JOIN, where the only comparison operator used is =, is called an <strong class="calibre6">EQUIJOIN</strong>. Both previous examples were EQUIJOINs. Notice that in the result of an EQUIJOIN we always have one or more pairs of attributes that have <em class="calibre13">identical values</em> in every tuple. For example, in <a href="#filepos576116" class="calibre41">Figure 6.6</a>, the values of the attributes Mgr_ssn and Ssn are identical in every tuple of DEPT_MGR (the EQUIJOIN result) because the equality join condition specified on these two attributes <em class="calibre13">requires the values to be identical</em> in every tuple in the result. Because one of each pair of attributes with identical values is superfluous, a new operation called <strong class="calibre6">NATURAL JOIN</strong>—denoted by *—was created to get rid of the second (superfluous) attribute in an EQUIJOIN condition.<a id="filepos580659" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_115.html#filepos4351781" class="calibre41">6</a></sup> The standard definition of NATURAL JOIN requires that the two join attributes (or each pair of join attributes) have the same name in both relations. If this is not the case, a renaming operation is applied first.</p><div class="calibre31"> </div>
<p class="calibre18">Suppose we want to combine each PROJECT tuple with the DEPARTMENT tuple that controls the project. In the following example, first we rename the Dnumber attribute of DEPARTMENT to Dnum—so that it has the same name as the Dnum attribute in PROJECT—and then we apply NATURAL JOIN:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">PROJ_DEPT ← PROJECT *ρ<sub class="calibre65">(Dname, Dnum, Mgr_ssn, Mgr_start_date)</sub>(DEPARTMENT)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">The same query can be done in two steps by creating an intermediate table DEPT as follows:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">DEPT ← ρ<sub class="calibre65">(Dname, Dnum, Mgr_ssn, Mgr_start_date)</sub>(DEPARTMENT)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">PROJ_DEPT ← PROJECT * DEPT</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">The attribute Dnum is called the <strong class="calibre6">join attribute</strong> for the NATURAL JOIN operation, because it is the only attribute with the same name in both relations. The resulting relation is illustrated in <a href="#filepos583428" class="calibre41">Figure 6.7(a)</a>. In the PROJ_DEPT relation, each tuple combines a PROJECT tuple with the DEPARTMENT tuple for the department that controls the project, but <em class="calibre13">only one join attribute value</em> is kept.</p><div class="calibre31"> </div>
<p class="calibre18">If the attributes on which the natural join is specified already <em class="calibre13">have the same names in both relations</em>, renaming is unnecessary. For example, to apply a natural join on the Dnumber attributes of DEPARTMENT and DEPT_LOCATIONS, it is sufficient to write</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">DEPT_LOCS ← DEPARTMENT * DEPT_LOCATIONS</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">The resulting relation is shown in <a href="#filepos583428" class="calibre41">Figure 6.7(b)</a>, which combines each department with its locations and has one tuple for each location. In general, the join condition for NATURAL JOIN is constructed by equating <em class="calibre13">each pair of join attributes</em> that have the same name in the two relations and combining these conditions with <strong class="calibre6">AND</strong>. There can be a list of join attributes from each relation, and each corresponding pair must have the same name.</p><div class="calibre31"> </div>
<p id="filepos583428" class="calibre7"><a id="filepos583459" class="calibre3"></a><img alt="image" src="../images/00126.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 6.7</strong><br class="calibre1"/>Results of two NATURAL JOIN operations. (a) PROJ_DEPT ← PROJECT * DEPT. (b) DEPT_LOCS ← DEPARTMENT * DEPT_LOCATIONS.</p><div class="calibre31"> </div>
<p class="calibre18">A more general, <em class="calibre13">but nonstandard</em> definition for NATURAL JOIN is</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><em class="calibre13">Q</em> ← <em class="calibre13">R</em>*<sub class="calibre65">(&lt;list1&gt;),(&lt;list2&gt;)</sub><em class="calibre13">S</em></p></blockquote><div class="calibre31"> </div>
<p class="calibre18">In this case, &lt;list1&gt; specifies a list of <em class="calibre13">i</em> attributes from <em class="calibre13">R</em>, and &lt;list2&gt; specifies a list of <em class="calibre13">i</em> attributes from <em class="calibre13">S</em>. The lists are used to form equality comparison conditions between pairs of corresponding attributes, and the conditions are then ANDed together. Only the list corresponding to attributes of the first relation <em class="calibre13">R</em>—&lt;list1&gt;—is kept in the result <em class="calibre13">Q</em>.</p><div class="calibre31"> </div>
<p class="calibre18">Notice that if no combination of tuples satisfies the join condition, the result of a JOIN is an empty relation with zero tuples. In general, if <em class="calibre13">R</em> has <em class="calibre13">n<sub class="calibre65">R</sub></em> tuples and <em class="calibre13">S</em> has <em class="calibre13">n<sub class="calibre65">S</sub></em> tuples, the result of a JOIN operation <em class="calibre13">R</em>
<img alt="image" src="../images/00124.jpg" class="calibre16"/><sub class="calibre65">&lt;join condition&gt;</sub><em class="calibre13">S</em> will have between zero and <em class="calibre13">n<sub class="calibre65">R</sub></em> * <em class="calibre13">n<sub class="calibre65">S</sub></em> tuples. The expected size of the join result divided by the maximum size <em class="calibre13">n<sub class="calibre65">R</sub></em> * <em class="calibre13">n<sub class="calibre65">S</sub></em> leads to a ratio called <strong class="calibre6">join selectivity</strong>, which is a property of each join condition. If there is no join condition, all combinations of tuples qualify and the JOIN degenerates into a CARTESIAN PRODUCT, also called CROSS PRODUCT or CROSS JOIN.</p><div class="calibre31"> </div>
<p class="calibre18">As we can see, a single JOIN operation is used to combine data from two relations so that related information can be presented in a single table. These operations are also known as <strong class="calibre6">inner joins</strong>, to distinguish them from a different join variation called <a id="filepos585733" class="calibre3"></a><em class="calibre13">outer joins</em> (see Section 6.4.4). Informally, an <em class="calibre13">inner join</em> is a type of match and combine operation defined formally as a combination of CARTESIAN PRODUCT and SELECTION. Note that sometimes a join may be specified between a relation and itself, as we will illustrate in Section 6.4.3. The NATURAL JOIN or EQUIJOIN operation can also be specified among multiple tables, leading to an <em class="calibre13">n-way join</em>. For example, consider the following three-way join:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">((PROJECT <img alt="image" src="../images/00127.jpg" class="calibre16"/><sub class="calibre65">Dnum=Dnumber</sub>DEPARTMENT) <img alt="image" src="../images/00127.jpg" class="calibre16"/><sub class="calibre65">Mgr_ssn=Ssn</sub>EMPLOYEE)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">This combines each project tuple with its controlling department tuple into a single tuple, and then combines that tuple with an employee tuple that is the department manager. The net result is a consolidated relation in which each tuple contains this project-department-manager combined information.</p><div class="calibre31"> </div>
<p class="calibre18">In SQL, JOIN can be realized in several different ways. The first method is to specify the &lt;join conditions&gt; in the WHERE clause, along with any other selection conditions. This is very common, and is illustrated by queries Q1, Q1A, Q1B, Q2, and Q8 in Sections 4.3.1 and 4.3.2, as well as by many other query examples in <a href="dummy_split_019.html#filepos362078" class="calibre41">Chapters 4</a> and <a href="dummy_split_020.html#filepos448575" class="calibre41">5</a>. The second way is to use a nested relation, as illustrated by queries Q4A and Q16 in Section 5.1.2. Another way is to use the concept of joined tables, as illustrated by the queries Q1A, Q1B, Q8B, and Q2A in Section 5.1.6. The construct of joined tables was added to SQL2 to allow the user to specify explicitly all the various types of joins, because the other methods were more limited. It also allows the user to clearly distinguish join conditions from the selection conditions in the WHERE clause.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">6.3.3 A Complete Set of Relational Algebra Operations</span></span></blockquote></h5>
<p class="calibre18">It has been shown that the set of relational algebra operations {σ,π,<img alt="image" src="../images/00128.jpg" class="calibre16"/>,ρ,–,×} is a <strong class="calibre6">complete</strong> set; that is, any of the other original relational algebra operations can be expressed as a <em class="calibre13">sequence of operations from this set</em>. For example, the INTERSECTION operation can be expressed by using UNION and MINUS as follows:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><em class="calibre13">R</em>
<img alt="image" src="../images/00129.jpg" class="calibre16"/><em class="calibre13">S</em> ≡ (<em class="calibre13">R</em>
<img alt="image" src="../images/00024.jpg" class="calibre16"/><em class="calibre13">S</em>) – ((<em class="calibre13">R</em> – <em class="calibre13">S</em>) <img alt="image" src="../images/00024.jpg" class="calibre16"/> (<em class="calibre13">S</em> – <em class="calibre13">R</em>))</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">Although, strictly speaking, INTERSECTION is not required, it is inconvenient to specify this complex expression every time we wish to specify an intersection. As another example, a JOIN operation can be specified as a CARTESIAN PRODUCT followed by a SELECT operation, as we discussed:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><em class="calibre13">R</em>
<img alt="image" src="../images/00127.jpg" class="calibre16"/><sub class="calibre65">&lt;condition&gt;</sub><em class="calibre13">S</em> ≡ σ<sub class="calibre65">&lt;condition&gt;</sub>(<em class="calibre13">R</em>× <em class="calibre13">S</em>)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">Similarly, a NATURAL JOIN can be specified as a CARTESIAN PRODUCT preceded by RENAME and followed by SELECT and PROJECT operations. Hence, the various JOIN operations are also <em class="calibre13">not strictly necessary</em> for the expressive power of the relational algebra. However, they are important to include as separate operations because they are convenient to use and are very commonly applied in database applications. Other operations have been included in the basic relational algebra for convenience rather than necessity. We discuss one of these—the DIVISION operation—in the next section.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1"><a id="filepos590151" class="calibre3"></a>6.3.4 The DIVISION Operation</span></span></blockquote></h5>
<p class="calibre18">The DIVISION operation, denoted by ÷, is useful for a special kind of query that sometimes occurs in database applications. An example is <em class="calibre13">Retrieve the names of employees who work on</em>
<strong class="calibre6"><em class="calibre13">all</em></strong>
<em class="calibre13">the projects that ‘John Smith’ works on</em>. To express this query using the DIVISION operation, proceed as follows. First, retrieve the list of project numbers that ‘John Smith’ works on in the intermediate relation SMITH_PNOS:</p><div class="calibre31"> </div>
<p class="calibre7"><img alt="image" src="../images/00130.jpg" class="calibre16"/></p>
<p class="calibre18">Next, create a relation that includes a tuple &lt;Pno, Essn&gt; whenever the employee whose Ssn is Essn works on the project whose number is Pno in the intermediate relation SSN_PNOS:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">SSN_PNOS ← π<sub class="calibre65">Essn, Pno</sub>(WORKS_ON)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">Finally, apply the DIVISION operation to the two relations, which gives the desired employees’ Social Security numbers:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">SSNS(Ssn) ← SSN_PNOS ÷ SMITH_PNOS</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">RESULT ← π<sub class="calibre65">Fname, Lname</sub>(SSNS * EMPLOYEE)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">The preceding operations are shown in <a href="#filepos591880" class="calibre41">Figure 6.8</a>(a).</p><div class="calibre31"> </div>
<p id="filepos591880" class="calibre7"><img alt="image" src="../images/00131.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 6.8</strong><br class="calibre1"/>The DIVISION operation. (a) Dividing SSN_PNOS by SMITH_PNOS. (b) <em class="calibre13">T</em> ← <em class="calibre13">R</em> ÷ <em class="calibre13">S</em>.</p><div class="calibre31"> </div>
<p class="calibre18"><a id="filepos592198" class="calibre3"></a>In general, the DIVISION operation is applied to two relations <em class="calibre13">R</em>(<em class="calibre13">Z</em>) ÷ <em class="calibre13">S</em>(<em class="calibre13">X</em>), where the attributes of <em class="calibre13">R</em> are a subset of the attributes of <em class="calibre13">S</em>; that is, <em class="calibre13">X</em>
<img alt="image" src="../images/00132.jpg" class="calibre16"/><em class="calibre13">Z</em>. Let <em class="calibre13">Y</em> be the set of attributes of <em class="calibre13">R</em> that are not attributes of <em class="calibre13">S</em>; that is, <em class="calibre13">Y</em> = <em class="calibre13">Z</em> − <em class="calibre13">X</em> (and hence <em class="calibre13">Z</em> = <em class="calibre13">X</em>
<img alt="image" src="../images/00024.jpg" class="calibre16"/><em class="calibre13">Y</em>). The result of DIVISION is a relation <em class="calibre13">T</em>(<em class="calibre13">Y</em>) that includes a tuple <em class="calibre13">t</em> if tuples <em class="calibre13">t<sub class="calibre65">R</sub></em> appear in <em class="calibre13">R</em> with <em class="calibre13">t<sub class="calibre65">R</sub></em> [<em class="calibre13">Y</em>] = <em class="calibre13">t</em>, and with <em class="calibre13">t<sub class="calibre65">R</sub></em> [<em class="calibre13">X</em>] = <em class="calibre13">t<sub class="calibre65">S</sub></em> for <em class="calibre13">every</em> tuple <em class="calibre13">t<sub class="calibre65">S</sub></em> in <em class="calibre13">S</em>. This means that, for a tuple <em class="calibre13">t</em> to appear in the result <em class="calibre13">T</em> of the DIVISION, the values in <em class="calibre13">t</em> must appear in <em class="calibre13">R</em> in combination with <em class="calibre13">every tuple</em> in <em class="calibre13">S</em>. Note that in the formulation of the DIVISION operation, the tuples in the denominator relation <em class="calibre13">S</em> restrict the numerator relation <em class="calibre13">R</em> by selecting those tuples in the result that match all values present in the denominator. It is not necessary to know what those values are as they can be computed by another operation, as illustrated in the SMITH_PNOS relation in the above example.</p><div class="calibre31"> </div>
<p class="calibre18"><a href="#filepos591880" class="calibre41">Figure 6.8</a>(b) illustrates a DIVISION operation where <em class="calibre13">X</em> = {<em class="calibre13">A</em>}, <em class="calibre13">Y</em> = {<em class="calibre13">B</em>}, and <em class="calibre13">Z</em> = {<em class="calibre13">A</em>, <em class="calibre13">B</em>}. Notice that the tuples (values) <em class="calibre13">b</em><sub class="calibre65">1</sub> and <em class="calibre13">b</em><sub class="calibre65">4</sub> appear in <em class="calibre13">R</em> in combination with all three tuples in <em class="calibre13">S</em>; that is why they appear in the resulting relation <em class="calibre13">T</em>. All other values of <em class="calibre13">B</em> in <em class="calibre13">R</em> do not appear with all the tuples in <em class="calibre13">S</em> and are not selected: <em class="calibre13">b</em><sub class="calibre65">2</sub> does not appear with <em class="calibre13">a</em><sub class="calibre65">2</sub>, and <em class="calibre13">b</em><sub class="calibre65">3</sub> does not appear with <em class="calibre13">a</em><sub class="calibre65">1</sub>.</p><div class="calibre31"> </div>
<p class="calibre18">The DIVISION operation can be expressed as a sequence of π,×, and – operations as follows:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><em class="calibre13">T</em>1 ← π<em class="calibre13"><sub class="calibre65">Y</sub></em>(<em class="calibre13">R</em>)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><em class="calibre13">T</em>2 ← π<em class="calibre13"><sub class="calibre65">Y</sub></em>((<em class="calibre13">S</em> × <em class="calibre13">T</em>1) – <em class="calibre13">R</em>)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><em class="calibre13">T</em> ← <em class="calibre13">T</em>1 – <em class="calibre13">T</em>2</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">The DIVISION operation is defined for convenience for dealing with queries that involve <em class="calibre13">universal quantification</em> (see Section 6.6.7) or the <em class="calibre13">all</em> condition. Most RDBMS implementations with SQL as the primary query language do not directly implement division. SQL has a roundabout way of dealing with the type of query illustrated above (see Section 5.1.4, queries Q3A and Q3B). <a href="#filepos596992" class="calibre41">Table 6.1</a> lists the various basic relational algebra operations we have discussed.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">6.3.5 Notation for Query Trees</span></span></blockquote></h5>
<p class="calibre18">In this section we describe a notation typically used in relational systems to represent queries internally. The notation is called a <em class="calibre13">query tree</em> or sometimes it is known as a <em class="calibre13">query evaluation tree</em> or <em class="calibre13">query execution tree</em>. It includes the relational algebra operations being executed and is used as a possible data structure for the internal representation of the query in an RDBMS.</p><div class="calibre31"> </div>
<p class="calibre18">A <strong class="calibre6">query tree</strong> is a tree data structure that corresponds to a relational algebra expression. It represents the input relations of the query as <em class="calibre13">leaf nodes</em> of the tree, and represents the relational algebra operations as internal nodes. An execution of the query tree consists of executing an internal node operation whenever its operands (represented by its child nodes) are available, and then replacing that internal node by the relation that results from executing the operation. The execution terminates when the root node is executed and produces the result relation for the query.</p><div class="calibre31"> </div>
<p class="calibre58"><strong class="calibre6">Table 6.1</strong> Operations of Relational Algebra</p><div class="calibre31"> </div>
<p id="filepos596992" class="calibre7"><a id="filepos597023" class="calibre3"></a><img alt="image" src="../images/00133.jpg" class="calibre16"/></p>
<p class="calibre18"><a href="#filepos599110" class="calibre41">Figure 6.9</a> shows a query tree for Query 2 (see Section 4.3.1): <em class="calibre13">For every project located in ‘Stafford’, list the project number, the controlling department number, and the department manager’s last name, address, and birth date</em>. This query is specified on the relational schema of <a href="dummy_split_018.html#filepos312087" class="calibre41">Figure 3.5</a> and corresponds to the following relational algebra expression:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">π<sub class="calibre65">Pnumber, Dnum, Lname, Address, Bdate</sub>(((σ<sub class="calibre65">Plocation=‘Stafford’</sub>(PROJECT))</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><img alt="image" src="../images/00127.jpg" class="calibre16"/><sub class="calibre65">Dnum=Dnumber</sub>(DEPARTMENT)) <img alt="image" src="../images/00127.jpg" class="calibre16"/><sub class="calibre65">Mgr_ssn=Ssn</sub>(EMPLOYEE))</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">In <a href="#filepos599110" class="calibre41">Figure 6.9</a>, the three leaf nodes P, D, and E represent the three relations PROJECT, DEPARTMENT, and EMPLOYEE. The relational algebra operations in the expression <a id="filepos598267" class="calibre3"></a>are represented by internal tree nodes. The query tree signifies an explicit order of execution in the following sense. In order to execute Q2, the node marked (1) in <a href="#filepos599110" class="calibre41">Figure 6.9</a> must begin execution before node (2) because some resulting tuples of operation (1) must be available before we can begin to execute operation (2). Similarly, node (2) must begin to execute and produce results before node (3) can start execution, and so on. In general, a query tree gives a good visual representation and understanding of the query in terms of the relational operations it uses and is recommended as an additional means for expressing queries in relational algebra. We will revisit query trees when we discuss query processing and optimization in <a href="dummy_split_040.html#filepos2126215" class="calibre41">Chapter 19</a>.</p><div class="calibre31"> </div>
<p id="filepos599110" class="calibre7"><img alt="image" src="../images/00134.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 6.9</strong><br class="calibre1"/>Query tree corresponding to the relational algebra expression for Q2.</p><div class="calibre31"> </div>
<h4 id="filepos599356" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">6.4 Additional Relational Operations</span></span></blockquote></h4><div class="calibre31"> </div>
<p class="calibre18">Some common database requests—which are needed in commercial applications for RDBMSs—cannot be performed with the original relational algebra operations described in Sections 6.1 through 6.3. In this section we define additional operations to express these requests. These operations enhance the expressive power of the original relational algebra.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">6.4.1 Generalized Projection</span></span></blockquote></h5>
<p class="calibre18">The generalized projection operation extends the projection operation by allowing functions of attributes to be included in the projection list. The generalized form can be expressed as:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">π<sub class="calibre65"><em class="calibre13">F</em>1, <em class="calibre13">F</em>2, ..., <em class="calibre13">Fn</em></sub> (<em class="calibre13">R</em>)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18"><a id="filepos600550" class="calibre3"></a>where <em class="calibre13">F</em><sub class="calibre65">1</sub>, <em class="calibre13">F</em><sub class="calibre65">2</sub>, ..., <em class="calibre13">F<sub class="calibre65">n</sub></em> are functions over the attributes in relation <em class="calibre13">R</em> and may involve arithmetic operations and constant values. This operation is helpful when developing reports where computed values have to be produced in the columns of a query result.</p><div class="calibre31"> </div>
<p class="calibre18">As an example, consider the relation</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">EMPLOYEE (Ssn, Salary, Deduction, Years_service)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">A report may be required to show</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">Net Salary = Salary − Deduction,</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">Bonus = 2000 * Years_service, and</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">Tax = 0.25 * Salary.</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">Then a generalized projection combined with renaming may be used as follows:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">REPORT ← ρ<sub class="calibre65">(Ssn, Net_salary, Bonus, Tax)</sub>(π<sub class="calibre65">Ssn, Salary – Deduction, 2000 * Years_service, 0.25 * Salary</sub>(EMPLOYEE)).</p></blockquote><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">6.4.2 Aggregate Functions and Grouping</span></span></blockquote></h5>
<p class="calibre18">Another type of request that cannot be expressed in the basic relational algebra is to specify mathematical <strong class="calibre6">aggregate functions</strong> on collections of values from the database. Examples of such functions include retrieving the average or total salary of all employees or the total number of employee tuples. These functions are used in simple statistical queries that summarize information from the database tuples. Common functions applied to collections of numeric values include SUM, AVERAGE, MAXIMUM, and MINIMUM. The COUNT function is used for counting tuples or values.</p><div class="calibre31"> </div>
<p class="calibre18">Another common type of request involves grouping the tuples in a relation by the value of some of their attributes and then applying an aggregate function <em class="calibre13">independently to each group</em>. An example would be to group EMPLOYEE tuples by Dno, so that each group includes the tuples for employees working in the same department. We can then list each Dno value along with, say, the average salary of employees within the department, or the number of employees who work in the department.</p><div class="calibre31"> </div>
<p class="calibre18">We can define an AGGREGATE FUNCTION operation, using the symbol <img alt="image" src="../images/00135.jpg" class="calibre16"/> (pronounced <em class="calibre13">script F</em>)<a id="filepos603519" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_116.html#filepos4352004" class="calibre41">7</a></sup>, to specify these types of requests as follows:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><sub class="calibre65">&lt;grouping attributes&gt;</sub><img alt="image" src="../images/00135.jpg" class="calibre16"/><sub class="calibre65">&lt;function list&gt;</sub> (<em class="calibre13">R</em>)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">where &lt;grouping attributes&gt; is a list of attributes of the relation specified in <em class="calibre13">R</em>, and &lt;function list&gt; is a list of (&lt;function&gt; &lt;attribute&gt;) pairs. In each such pair, &lt;function&gt; is one of the allowed functions—such as SUM, AVERAGE, MAXIMUM, MINIMUM, COUNT—and &lt;attribute&gt; is an attribute of the relation specified by <em class="calibre13">R</em>. The <a class="calibre3"></a>resulting relation has the grouping attributes plus one attribute for each element in the function list. For example, to retrieve each department number, the number of employees in the department, and their average salary, while renaming the resulting attributes as indicated below, we write:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">ρ<em class="calibre13"><sub class="calibre65">R</sub></em>
<sub class="calibre65">(Dno, No_of_employees, Average_sal)</sub>(<sub class="calibre65">Dno</sub><img alt="image" src="../images/00135.jpg" class="calibre16"/><sub class="calibre65">COUNT Ssn, AVERAGE Salary</sub> (EMPLOYEE))</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">The result of this operation on the EMPLOYEE relation of <a href="dummy_split_018.html#filepos314167" class="calibre41">Figure 3.6</a> is shown in <a href="#filepos606928" class="calibre41">Figure 6.10(a)</a>.</p><div class="calibre31"> </div>
<p class="calibre18">In the above example, we specified a list of attribute names—between parentheses in the RENAME operation—for the resulting relation <em class="calibre13">R</em>. If no renaming is applied, then the attributes of the resulting relation that correspond to the function list will each be the concatenation of the function name with the attribute name in the form &lt;function&gt;_&lt;attribute&gt;.<a id="filepos605524" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_117.html#filepos4352258" class="calibre41">8</a></sup> For example, <a href="#filepos606928" class="calibre41">Figure 6.10(b)</a> shows the result of the following operation:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><sub class="calibre65">Dno</sub><img alt="image" src="../images/00135.jpg" class="calibre16"/><sub class="calibre65">COUNT Ssn, AVERAGE Salary</sub>(EMPLOYEE)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">If no grouping attributes are specified, the functions are applied to <em class="calibre13">all the tuples</em> in the relation, so the resulting relation has a <em class="calibre13">single tuple only</em>. For example, <a href="#filepos606928" class="calibre41">Figure 6.10(c)</a> shows the result of the following operation:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><img alt="image" src="../images/00135.jpg" class="calibre16"/><sub class="calibre65">COUNT Ssn, AVERAGE Salary</sub>(EMPLOYEE)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">It is important to note that, in general, duplicates are <em class="calibre13">not eliminated</em> when an aggregate function is applied; this way, the normal interpretation of functions such as <a id="filepos606608" class="calibre3"></a>SUM and AVERAGE is computed.<a id="filepos606643" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_118.html#filepos4352478" class="calibre41">9</a></sup> It is worth emphasizing that the result of applying an aggregate function is a relation, not a scalar number—even if it has a single value. This makes the relational algebra a closed mathematical system.</p><div class="calibre31"> </div>
<p id="filepos606928" class="calibre7"><img alt="image" src="../images/00136.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 6.10</strong><br class="calibre1"/>The aggregate function operation.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">6.4.3 Recursive Closure Operations</span></span></blockquote></h5>
<p class="calibre18">Another type of operation that, in general, cannot be specified in the basic original relational algebra is <strong class="calibre6">recursive closure.</strong> This operation is applied to a <strong class="calibre6">recursive relationship</strong> between tuples of the same type, such as the relationship between an employee and a supervisor. This relationship is described by the foreign key Super_ssn of the EMPLOYEE relation in <a href="dummy_split_018.html#filepos312087" class="calibre41">Figures 3.5</a> and <a href="dummy_split_018.html#filepos314167" class="calibre41">3.6</a>, and it relates each employee tuple (in the role of supervisee) to another employee tuple (in the role of supervisor). An example of a recursive operation is to retrieve all supervisees of an employee <em class="calibre13">e</em> at all levels—that is, all employees <em class="calibre13">e</em>′ directly supervised by <em class="calibre13">e</em>′, all employees <em class="calibre13">e</em>′<img alt="image" src="../images/00135.jpg" class="calibre16"/> directly supervised by each employee <em class="calibre13">e</em>′, all employees <em class="calibre13">e</em>′″ directly supervised by each employee <em class="calibre13">e</em>″, and so on.</p><div class="calibre31"> </div>
<p class="calibre18">It is relatively straightforward in the relational algebra to specify all employees supervised by <em class="calibre13">e at a specific level</em> by joining the table with itself one or more times. However, it is difficult to specify all supervisees at <em class="calibre13">all</em> levels. For example, to specify the Ssns of all employees <em class="calibre13">e</em>′ directly supervised—<em class="calibre13">at level one</em>—by the employee <em class="calibre13">e</em> whose name is ‘James Borg’ (see <a href="dummy_split_018.html#filepos314167" class="calibre41">Figure 3.6</a>), we can apply the following operation:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">BORG_SSN ← π<sub class="calibre65">Ssn</sub>(σ<sub class="calibre65">Fname=‘James’ <strong class="calibre6">AND</strong> Lname=‘Borg’</sub>(EMPLOYEE))</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">SUPERVISION(Ssn1, Ssn2) ← π<sub class="calibre65">Ssn, Super_ssn</sub>(EMPLOYEE)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">RESULT1(Ssn) ← π<sub class="calibre65">Ssn1</sub>(SUPERVISION <img alt="image" src="../images/00127.jpg" class="calibre16"/><sub class="calibre65">Ssn2=Ssn</sub>BORG_SSN)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">To retrieve all employees supervised by Borg at level 2—that is, all employees <em class="calibre13">e</em>″ supervised by some employee <em class="calibre13">e</em>′ who is directly supervised by Borg—we can apply another <strong class="calibre6">JOIN</strong> to the result of the first query, as follows:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">RESULT2(Ssn) ← π<sub class="calibre65">Ssn1</sub>(SUPERVISION <img alt="image" src="../images/00127.jpg" class="calibre16"/><sub class="calibre65">Ssn2=Ssn</sub>RESULT1)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">To get both sets of employees supervised at levels 1 and 2 by ‘James Borg’, we can apply the UNION operation to the two results, as follows:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">RESULT ← RESULT2 <img alt="image" src="../images/00128.jpg" class="calibre16"/> RESULT1</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">The results of these queries are illustrated in <a href="#filepos611159" class="calibre41">Figure 6.11</a>. Although it is possible to retrieve employees at each level and then take their UNION, we cannot, in general, specify a query such as “retrieve the supervisees of ‘James Borg’ at all levels” without utilizing a looping mechanism unless we know the maximum number of levels.<a id="filepos610928" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_119.html#filepos4352760" class="calibre41">10</a></sup> An operation called the <em class="calibre13">transitive closure</em> of relations has been proposed to compute the recursive relationship as far as the recursion proceeds.</p><div class="calibre31"> </div>
<p id="filepos611159" class="calibre7"><a id="filepos611190" class="calibre3"></a><img alt="image" src="../images/00137.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 6.11</strong><br class="calibre1"/>A two-level recursive query.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">6.4.4 OUTER JOIN Operations</span></span></blockquote></h5>
<p class="calibre18">Next, we discuss some additional extensions to the JOIN operation that are necessary to specify certain types of queries. The JOIN operations described earlier match tuples that satisfy the join condition. For example, for a NATURAL JOIN operation <em class="calibre13">R</em> *<em class="calibre13">S</em>, only tuples from <em class="calibre13">R</em> that have matching tuples in <em class="calibre13">S</em>—and vice versa—appear in the result. Hence, tuples without a <em class="calibre13">matching</em> (or <em class="calibre13">related</em>) tuple are eliminated from the JOIN result. Tuples with NULL values in the join attributes are also eliminated. This type of join, where tuples with no match are eliminated, is known as an <strong class="calibre6">inner join</strong>. The join operations we described earlier in Section 6.3 are all inner joins. This amounts to the loss of information if the user wants the result of the JOIN to include all the tuples in one or more of the component relations.</p><div class="calibre31"> </div>
<p class="calibre18">A set of operations, called <strong class="calibre6">outer joins</strong>, were developed for the case where the user wants to keep all the tuples in <em class="calibre13">R</em>, or all those in <em class="calibre13">S</em>, or all those in both relations in the result of the JOIN, regardless of whether or not they have matching tuples in the other relation. This satisfies the need of queries in which tuples from two tables are <a id="filepos612898" class="calibre3"></a>to be combined by matching corresponding rows, but without losing any tuples for lack of matching values. For example, suppose that we want a list of all employee names as well as the name of the departments they manage <em class="calibre13">if they happen to manage a department</em>; if they do not manage one, we can indicate it with a NULL value. We can apply an operation <strong class="calibre6">LEFT OUTER JOIN</strong>, denoted by <img alt="image" src="../images/00138.jpg" class="calibre16"/>, to retrieve the result as follows:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">TEMP ← (EMPLOYEE <img alt="image" src="../images/00138.jpg" class="calibre16"/><sub class="calibre65">Ssn=Mgr_ssn</sub>DEPARTMENT)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">RESULT ← π<sub class="calibre65">Fname, Minit, Lname, Dname</sub>(TEMP)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">The LEFT OUTER JOIN operation keeps every tuple in the <em class="calibre13">first</em>, or <em class="calibre13">left</em>, relation <em class="calibre13">R</em> in <em class="calibre13">R</em>
<img alt="image" src="../images/00138.jpg" class="calibre16"/><em class="calibre13">S</em>; if no matching tuple is found in <em class="calibre13">S</em>, then the attributes of <em class="calibre13">S</em> in the join result are filled or <em class="calibre13">padded</em> with NULL values. The result of these operations is shown in <a href="#filepos616166" class="calibre41">Figure 6.12</a>.</p><div class="calibre31"> </div>
<p class="calibre18">A similar operation, <strong class="calibre6">RIGHT OUTER JOIN</strong>, denoted by <img alt="image" src="../images/00139.jpg" class="calibre16"/>, keeps every tuple in the <em class="calibre13">second</em>, or right, relation <em class="calibre13">S</em> in the result of <em class="calibre13">R</em>
<img alt="image" src="../images/00139.jpg" class="calibre16"/><em class="calibre13">S</em>. A third operation, <strong class="calibre6">FULL OUTER JOIN</strong>, denoted by <img alt="image" src="../images/00140.jpg" class="calibre16"/>, keeps all tuples in both the left and the right relations when no matching tuples are found, padding them with NULL values as needed. The three outer join operations are part of the SQL2 standard (see Section 5.1.6). These operations were provided later as an extension of relational algebra in response to the typical need in business applications to show related information from multiple tables exhaustively. Sometimes a complete reporting of data from multiple tables is required whether or not there are matching values.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">6.4.5 The OUTER UNION Operation</span></span></blockquote></h5>
<p class="calibre18">The <strong class="calibre6">OUTER UNION</strong> operation was developed to take the union of tuples from two relations that have some common attributes, but are <em class="calibre13">not union (type) compatible</em>. This operation will take the UNION of tuples in two relations <em class="calibre13">R</em>(<em class="calibre13">X</em>, <em class="calibre13">Y</em>) and <em class="calibre13">S</em>(<em class="calibre13">X</em>, <em class="calibre13">Z</em>) that are <strong class="calibre6">partially compatible</strong>, meaning that only some of their attributes, say <em class="calibre13">X</em>, are union compatible. The attributes that are union compatible are represented only once in the result, and those attributes that are not union compatible from either <a id="filepos615965" class="calibre3"></a>relation are also kept in the result relation <em class="calibre13">T</em>(<em class="calibre13">X</em>, <em class="calibre13">Y</em>, <em class="calibre13">Z</em>). It is therefore the same as a FULL OUTER JOIN on the common attributes.</p><div class="calibre31"> </div>
<p id="filepos616166" class="calibre7"><img alt="image" src="../images/00141.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 6.12</strong><br class="calibre1"/>The result of a LEFT OUTER JOIN operation.</p><div class="calibre31"> </div>
<p class="calibre18">Two tuples <em class="calibre13">t</em><sub class="calibre65">1</sub> in <em class="calibre13">R</em> and <em class="calibre13">t</em><sub class="calibre65">2</sub> in <em class="calibre13">S</em> are said to <strong class="calibre6">match</strong> if <em class="calibre13">t</em><sub class="calibre65">1</sub>[<em class="calibre13">X</em>]=<em class="calibre13">t</em><sub class="calibre65">2</sub>[<em class="calibre13">X</em>]. These will be combined (unioned) into a single tuple in <em class="calibre13">t</em>. Tuples in either relation that have no matching tuple in the other relation are padded with NULL values. For example, an OUTER UNION can be applied to two relations whose schemas are STUDENT(Name, Ssn, Department, Advisor) and INSTRUCTOR(Name, Ssn, Department, Rank). Tuples from the two relations are matched based on having the same combination of values of the shared attributes—Name, Ssn, Department. The resulting relation, STUDENT_OR_INSTRUCTOR, will have the following attributes:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">STUDENT_OR_INSTRUCTOR(Name, Ssn, Department, Advisor, Rank)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">All the tuples from both relations are included in the result, but tuples with the same (Name, Ssn, Department) combination will appear only once in the result. Tuples appearing only in STUDENT will have a NULL for the Rank attribute, whereas tuples appearing only in INSTRUCTOR will have a NULL for the Advisor attribute. A tuple that exists in both relations, which represent a student who is also an instructor, will have values for all its attributes.<a id="filepos617838" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_120.html#filepos4352948" class="calibre41">11</a></sup></p><div class="calibre31"> </div>
<p class="calibre18">Notice that the same person may still appear twice in the result. For example, we could have a graduate student in the Mathematics department who is an instructor in the Computer Science department. Although the two tuples representing that person in STUDENT and INSTRUCTOR will have the same (Name, Ssn) values, they will not agree on the Department value, and so will not be matched. This is because Department has two different meanings in STUDENT (the department where the person studies) and INSTRUCTOR (the department where the person is employed as an instructor). If we wanted to apply the OUTER UNION based on the same (Name, Ssn) combination only, we should rename the Department attribute in each table to reflect that they have different meanings and designate them as not being part of the union-compatible attributes. For example, we could rename the attributes as MajorDept in STUDENT and WorkDept in INSTRUCTOR.</p><div class="calibre31"> </div>
<h4 id="filepos618898" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">6.5 Examples of Queries in Relational Algebra</span></span></blockquote></h4><div class="calibre31"> </div>
<p class="calibre18">The following are additional examples to illustrate the use of the relational algebra operations. All examples refer to the database in <a href="dummy_split_018.html#filepos314167" class="calibre41">Figure 3.6</a>. In general, the same query can be stated in numerous ways using the various operations. We will state each query in one way and leave it to the reader to come up with equivalent formulations.</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><strong class="calibre6">Query 1.</strong> Retrieve the name and address of all employees who work for the ‘Research’ department.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><a class="calibre3"></a>RESEARCH_DEPT ← σ<sub class="calibre65">Dname=‘Research’</sub>(DEPARTMENT)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">RESEARCH_EMPS ← (RESEARCH_DEPT <img alt="image" src="../images/00127.jpg" class="calibre16"/><sub class="calibre65">Dnumber=Dno</sub>EMPLOYEE)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">RESULT ← π<sub class="calibre65">Fname, Lname, Address</sub>(RESEARCH_EMPS)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">As a single in-line expression, this query becomes:</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">π<sub class="calibre65">Fname, Lname, Address</sub> (σ<sub class="calibre65">Dname=‘Research’</sub>(DEPARTMENT <img alt="image" src="../images/00127.jpg" class="calibre16"/><sub class="calibre65">Dnumber=Dno</sub>(EMPLOYEE))</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">This query could be specified in other ways; for example, the order of the JOIN and SELECT operations could be reversed, or the JOIN could be replaced by a NATURAL JOIN after renaming one of the join attributes to match the other join attribute name.</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><strong class="calibre6">Query 2.</strong> For every project located in ‘Stafford’, list the project number, the controlling department number, and the department manager’s last name, address, and birth date.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">STAFFORD_PROJS ← σ<sub class="calibre65">Plocation=‘Stafford’</sub>(PROJECT)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">CONTR_DEPTS ← (STAFFORD_PROJS <img alt="image" src="../images/00127.jpg" class="calibre16"/><sub class="calibre65">Dnum=Dnumber</sub>DEPARTMENT)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">PROJ_DEPT_MGRS ← (CONTR_DEPTS <img alt="image" src="../images/00127.jpg" class="calibre16"/><sub class="calibre65">Mgr_ssn=Ssn</sub>EMPLOYEE)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">RESULT ← π<sub class="calibre65">Pnumber, Dnum, Lname, Address, Bdate</sub>(PROJ_DEPT_MGRS)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">In this example, we first select the projects located in Stafford, then join them with their controlling departments, and then join the result with the department managers. Finally, we apply a project operation on the desired attributes.</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><strong class="calibre6">Query 3.</strong> Find the names of employees who work on <em class="calibre13">all</em> the projects controlled by department number 5.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">DEPT5_PROJS ← ρ<sub class="calibre65">(Pno)</sub>(π<sub class="calibre65">Pnumber</sub>(σ<sub class="calibre65">Dnum=5</sub>(PROJECT)))</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">EMP_PROJ ← ρ<sub class="calibre65">(Ssn, Pno)</sub>(π<sub class="calibre65">Essn, Pno</sub>(WORKS_ON))</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">RESULT_EMP_SSNS ← EMP_PROJ ÷ DEPT5_PROJS</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">RESULT ← π<sub class="calibre65">Lname, Fname</sub>(RESULT_EMP_SSNS * EMPLOYEE)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">In this query, we first create a table DEPT5_PROJS that contains the project numbers of all projects controlled by department 5. Then we create a table EMP_PROJ that holds (Ssn, Pno) tuples, and apply the division operation. Notice that we renamed the attributes so that they will be correctly used in the division operation. Finally, we join the result of the division, which holds only Ssn values, with the EMPLOYEE table to retrieve the desired attributes from EMPLOYEE.</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><strong class="calibre6">Query 4.</strong> Make a list of project numbers for projects that involve an employee whose last name is ‘Smith’, either as a worker or as a manager of the department that controls the project.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">SMITHS(Essn) ← π<sub class="calibre65">Ssn</sub> (σ<sub class="calibre65">Lname=‘Smith’</sub>(EMPLOYEE))</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">SMITH_WORKER_PROJS ← π<sub class="calibre65">Pno</sub>(WORKS_ON * SMITHS)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">MGRS ← π<sub class="calibre65">Lname, Dnumber</sub>(EMPLOYEE <img alt="image" src="../images/00127.jpg" class="calibre16"/><sub class="calibre65">Ssn=Mgr_ssn</sub>DEPARTMENT)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">SMITH_MANAGED_DEPTS(Dnum) ← π<sub class="calibre65">Dnumber</sub> (σ<sub class="calibre65">Lname=‘Smith’</sub>(MGRS))</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">SMITH_MGR_PROJS(Pno) ← π<sub class="calibre65">Pnumber</sub>(SMITH_MANAGED_DEPTS * PROJECT)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">RESULT ← (SMITH_WORKER_PROJS <img alt="image" src="../images/00128.jpg" class="calibre16"/> SMITH_MGR_PROJS)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18"><a class="calibre3"></a>In this query, we retrieved the project numbers for projects that involve an employee named Smith as a worker in SMITH_WORKER_PROJS. Then we retrieved the project numbers for projects that involve an employee named Smith as manager of the department that controls the project in SMITH_MGR_PROJS. Finally, we applied the <strong class="calibre6">UNION</strong> operation on SMITH_WORKER_PROJS and SMITH_MGR_PROJS. As a single in-line expression, this query becomes:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">π<sub class="calibre65">Pno</sub> (WORKS_ON <img alt="image" src="../images/00127.jpg" class="calibre16"/><sub class="calibre65">Essn=Ssn</sub>(π<sub class="calibre65">Ssn</sub> (σ<sub class="calibre65">Lname=‘Smith’</sub>(EMPLOYEE))) <img alt="image" src="../images/00128.jpg" class="calibre16"/> π<sub class="calibre65">Pno</sub></p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">((π<sub class="calibre65">Dnumber</sub> (σ<sub class="calibre65">Lname=‘Smith’</sub>(π<sub class="calibre65">Lname, Dnumber</sub>(EMPLOYEE))) <img alt="image" src="../images/00127.jpg" class="calibre16"/></p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><sub class="calibre65">Ssn=Mgr_ssn</sub>DEPARTMENT)) <img alt="image" src="../images/00127.jpg" class="calibre16"/><sub class="calibre65">Dnumber=Dnum</sub>PROJECT)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><strong class="calibre6">Query 5.</strong> List the names of all employees with two or more dependents.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">Strictly speaking, this query cannot be done in the <em class="calibre13">basic</em> (<em class="calibre13">original</em>) <em class="calibre13">relational algebra</em>. We have to use the AGGREGATE FUNCTION operation with the COUNT aggregate function. We assume that dependents of the <em class="calibre13">same</em> employee have <em class="calibre13">distinct</em> Dependent_name values.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><em class="calibre13">T</em>1(Ssn, No_of_dependents)← <sub class="calibre65">Essn</sub><img alt="image" src="../images/00135.jpg" class="calibre16"/><sub class="calibre65">COUNT Dependent_name</sub>(DEPENDENT)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><em class="calibre13">T</em>2 ← σ<sub class="calibre65">No_of_dependents&gt;2</sub>(<em class="calibre13">T</em>1)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">RESULT ← π<sub class="calibre65">Lname, Fname</sub>(<em class="calibre13">T</em>2 * EMPLOYEE)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><strong class="calibre6">Query 6.</strong> Retrieve the names of employees who have no dependents.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">This is an example of the type of query that uses the MINUS (SET DIFFERENCE) operation.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">ALL_EMPS ← π<sub class="calibre65">Ssn</sub>(EMPLOYEE)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">EMPS_WITH_DEPS(Ssn) ← π<sub class="calibre65">Essn</sub>(DEPENDENT)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">EMPS_WITHOUT_DEPS ← (ALL_EMPS – EMPS_WITH_DEPS)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">RESULT ← π<sub class="calibre65">Lname, Fname</sub>(EMPS_WITHOUT_DEPS * EMPLOYEE)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">We first retrieve a relation with all employee Ssns in ALL_EMPS. Then we create a table with the Ssns of employees who have at least one dependent in EMPS_WITH_DEPS. Then we apply the SET DIFFERENCE operation to retrieve employees Ssns with no dependents in EMPS_WITHOUT_DEPS, and finally join this with EMPLOYEE to retrieve the desired attributes. As a single in-line expression, this query becomes:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">π<sub class="calibre65">Lname, Fname</sub>((π<sub class="calibre65">Ssn</sub>(EMPLOYEE) – ρ<sub class="calibre65">Ssn</sub>(π<sub class="calibre65">Essn</sub>(DEPENDENT))) * EMPLOYEE)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><strong class="calibre6">Query 7.</strong> List the names of managers who have at least one dependent.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">MGRS(Ssn) ← π<sub class="calibre65">Mgr_ssn</sub>(DEPARTMENT)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">EMPS_WITH_DEPS(Ssn) ← π<sub class="calibre65">Essn</sub>(DEPENDENT)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">MGRS_WITH_DEPS ← (MGRS <img alt="image" src="../images/00129.jpg" class="calibre16"/> EMPS_WITH_DEPS)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">RESULT ← π<sub class="calibre65">Lname, Fname</sub>(MGRS_WITH_DEPS * EMPLOYEE)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">In this query, we retrieve the Ssns of managers in MGRS, and the Ssns of employees with at least one dependent in EMPS_WITH_DEPS, then we apply the SET INTERSECTION operation to get the Ssns of managers who have at least one dependent.</p><div class="calibre31"> </div>
<p class="calibre18"><a id="filepos630448" class="calibre3"></a>As we mentioned earlier, the same query can be specified in many different ways in relational algebra. In particular, the operations can often be applied in various orders. In addition, some operations can be used to replace others; for example, the INTERSECTION operation in Q7 can be replaced by a NATURAL JOIN. As an exercise, try to do each of these sample queries using different operations.<a id="filepos630851" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_121.html#filepos4353220" class="calibre41">12</a></sup> We showed how to write queries as single relational algebra expressions for queries Q1, Q4, and Q6. Try to write the remaining queries as single expressions. In <a href="dummy_split_019.html#filepos362078" class="calibre41">Chapters 4</a> and <a href="dummy_split_020.html#filepos448575" class="calibre41">5</a> and in Sections 6.6 and 6.7, we show how these queries are written in other relational languages.</p><div class="calibre31"> </div>
<h4 id="filepos631257" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">6.6 The Tuple Relational Calculus</span></span></blockquote></h4><div class="calibre31"> </div>
<p class="calibre18">In this and the next section, we introduce another formal query language for the relational model called <strong class="calibre6">relational calculus</strong>. This section introduces the language known as <strong class="calibre6">tuple relational calculus</strong>, and Section 6.7 introduces a variation called <strong class="calibre6">domain relational calculus</strong>. In both variations of relational calculus, we write one <strong class="calibre6">declarative</strong> expression to specify a retrieval request; hence, there is no description of how, or <em class="calibre13">in what order</em>, to evaluate a query. A calculus expression specifies <em class="calibre13">what</em> is to be retrieved rather than <em class="calibre13">how</em> to retrieve it. Therefore, the relational calculus is considered to be a <strong class="calibre6">nonprocedural</strong> language. This differs from relational algebra, where we must write a <em class="calibre13">sequence of operations</em> to specify a retrieval request <em class="calibre13">in a particular order</em> of applying the operations; thus, it can be considered as a <strong class="calibre6">procedural</strong> way of stating a query. It is possible to nest algebra operations to form a single expression; however, a certain order among the operations is always explicitly specified in a relational algebra expression. This order also influences the strategy for evaluating the query. A calculus expression may be written in different ways, but the way it is written has no bearing on how a query should be evaluated.</p><div class="calibre31"> </div>
<p class="calibre18">It has been shown that any retrieval that can be specified in the basic relational algebra can also be specified in relational calculus, and vice versa; in other words, the <strong class="calibre6">expressive power</strong> of the languages is <em class="calibre13">identical</em>. This led to the definition of the concept of a <em class="calibre13">relationally complete</em> language. A relational query language <em class="calibre13">L</em> is considered <strong class="calibre6">relationally complete</strong> if we can express in <em class="calibre13">L</em> any query that can be expressed in relational calculus. Relational completeness has become an important basis for comparing the expressive power of high-level query languages. However, as we saw in Section 6.4, certain frequently required queries in database applications cannot be expressed in basic relational algebra or calculus. Most relational query languages are relationally complete but have <em class="calibre13">more expressive power</em> than relational algebra or relational calculus because of additional operations such as aggregate functions, grouping, and ordering. As we mentioned in the introduction to this chapter, the relational calculus is important for two reasons. First, it has a firm basis in mathematical logic. Second, the standard query language (SQL) for RDBMSs has some of its foundations in the tuple relational calculus.</p><div class="calibre31"> </div>
<p class="calibre18"><a id="filepos634255" class="calibre3"></a>Our examples refer to the database shown in <a href="dummy_split_018.html#filepos314167" class="calibre41">Figures 3.6</a> and <a href="dummy_split_018.html#filepos323245" class="calibre41">3.7</a>. We will use the same queries that were used in Section 6.5. Sections 6.6.6, 6.6.7, and 6.6.8 discuss dealing with universal quantifiers and safety of expression issues. (Students interested in a basic introduction to tuple relational calculus may skip these sections.)</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">6.6.1 Tuple Variables and Range Relations</span></span></blockquote></h5>
<p class="calibre18">The tuple relational calculus is based on specifying a number of <strong class="calibre6">tuple variables</strong>. Each tuple variable usually <em class="calibre13">ranges over</em> a particular database relation, meaning that the variable may take as its value any individual tuple from that relation. A simple tuple relational calculus query is of the form:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">{<em class="calibre13">t</em> | COND(<em class="calibre13">t</em>)}</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">where <em class="calibre13">t</em> is a tuple variable and COND(<em class="calibre13">t</em>) is a conditional (Boolean) expression involving <em class="calibre13">t</em> that evaluates to either TRUE or FALSE for different assignments of tuples to the variable <em class="calibre13">t</em>. The result of such a query is the set of all tuples <em class="calibre13">t</em> that evaluate COND(<em class="calibre13">t</em>) to TRUE. These tuples are said to <strong class="calibre6">satisfy</strong> COND(<em class="calibre13">t</em>). For example, to find all employees whose salary is above $50,000, we can write the following tuple calculus expression:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">{<em class="calibre13">t</em> | EMPLOYEE(<em class="calibre13">t</em>) <strong class="calibre6">AND</strong>
<em class="calibre13">t</em>.Salary&gt;50000}</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">The condition EMPLOYEE(<em class="calibre13">t</em>) specifies that the <strong class="calibre6">range relation</strong> of tuple variable <em class="calibre13">t</em> is EMPLOYEE. Each EMPLOYEE tuple <em class="calibre13">t</em> that satisfies the condition <em class="calibre13">t</em>.Salary&gt;50000 will be retrieved. Notice that <em class="calibre13">t</em>.Salary references attribute Salary of tuple variable <em class="calibre13">t</em>; this notation resembles how attribute names are qualified with relation names or aliases in SQL, as we saw in <a href="dummy_split_019.html#filepos362078" class="calibre41">Chapter 4</a>. In the notation of <a href="dummy_split_018.html#filepos266551" class="calibre41">Chapter 3</a>, <em class="calibre13">t</em>.Salary is the same as writing <em class="calibre13">t</em>[Salary].</p><div class="calibre31"> </div>
<p class="calibre18">The above query retrieves all attribute values for each selected EMPLOYEE tuple <em class="calibre13">t</em>. To retrieve only <em class="calibre13">some</em> of the attributes—say, the first and last names—we write</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">{<em class="calibre13">t</em>.Fname, <em class="calibre13">t</em>.Lname | EMPLOYEE(<em class="calibre13">t</em>) <strong class="calibre6">AND</strong>
<em class="calibre13">t</em>.Salary&gt;50000}</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">Informally, we need to specify the following information in a tuple relational calculus expression:</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> For each tuple variable <em class="calibre13">t</em>, the <strong class="calibre6">range relation</strong>
<em class="calibre13">R</em> of <em class="calibre13">t</em>. This value is specified by a condition of the form <em class="calibre13">R</em>(<em class="calibre13">t</em>). If we do not specify a range relation, then the variable <em class="calibre13">t</em> will range over all possible tuples “in the universe” as it is not restricted to any one relation.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> A condition to select particular combinations of tuples. As tuple variables range over their respective range relations, the condition is evaluated for every possible combination of tuples to identify the <strong class="calibre6">selected combinations</strong> for which the condition evaluates to TRUE.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> A set of attributes to be retrieved, the <strong class="calibre6">requested attributes</strong>. The values of these attributes are retrieved for each selected combination of tuples.</p></blockquote>
<p class="calibre18">Before we discuss the formal syntax of tuple relational calculus, consider another query.</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><a id="filepos638732" class="calibre3"></a><strong class="calibre6">Query 0.</strong> Retrieve the birth date and address of the employee (or employees) whose name is John B. Smith.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><strong class="calibre6">Q0:</strong> {<em class="calibre13">t</em>.Bdate, <em class="calibre13">t</em>.Address | EMPLOYEE(<em class="calibre13">t</em>) <strong class="calibre6">AND</strong>
<em class="calibre13">t</em>.Fname=‘John’ <strong class="calibre6">AND</strong>
<em class="calibre13">t</em>.Minit=‘B’ <strong class="calibre6">AND</strong>
<em class="calibre13">t</em>.Lname=‘Smith’}</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">In tuple relational calculus, we first specify the requested attributes <em class="calibre13">t</em>.Bdate and <em class="calibre13">t</em>.Address for each selected tuple <em class="calibre13">t</em>. Then we specify the condition for selecting a tuple following the bar (|)—namely, that <em class="calibre13">t</em> be a tuple of the EMPLOYEE relation whose Fname, Minit, and Lname attribute values are ‘John’, ‘B’, and ‘Smith’, respectively.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">6.6.2 Expressions and Formulas in Tuple Relational Calculus</span></span></blockquote></h5>
<p class="calibre18">A general <strong class="calibre6">expression</strong> of the tuple relational calculus is of the form</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">{<em class="calibre13">t</em><sub class="calibre65">1</sub>.<em class="calibre13">A<sub class="calibre65">j</sub></em>, <em class="calibre13">t</em><sub class="calibre65">2</sub>.<em class="calibre13">A<sub class="calibre65">k</sub></em>, ..., <em class="calibre13">t<sub class="calibre65">n</sub></em>.<em class="calibre13">A<sub class="calibre65">m</sub></em> | COND(<em class="calibre13">t</em><sub class="calibre65">1</sub>, <em class="calibre13">t</em><sub class="calibre65">2</sub>, ..., <em class="calibre13">t<sub class="calibre65">n</sub></em>, <em class="calibre13">t</em><sub class="calibre65"><em class="calibre13">n</em>+1</sub>, <em class="calibre13">t</em><sub class="calibre65"><em class="calibre13">n</em>+2</sub>, ..., <em class="calibre13">t</em><sub class="calibre65"><em class="calibre13">n</em>+<em class="calibre13">m</em></sub>)}</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">where <em class="calibre13">t</em><sub class="calibre65">1</sub>, <em class="calibre13">t</em><sub class="calibre65">2</sub>, ..., <em class="calibre13">t<sub class="calibre65">n</sub></em>, <em class="calibre13">t</em><sub class="calibre65"><em class="calibre13">n</em>+1</sub>, ..., <em class="calibre13">t</em><sub class="calibre65"><em class="calibre13">n</em>+<em class="calibre13">m</em></sub> are tuple variables, each <em class="calibre13">A<sub class="calibre65">i</sub></em> is an attribute of the relation on which <em class="calibre13">t<sub class="calibre65">i</sub></em> ranges, and COND is a <strong class="calibre6">condition</strong> or <strong class="calibre6">formula</strong>.<a id="filepos640884" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_122.html#filepos4353558" class="calibre41">13</a></sup> of the tuple relational calculus. A formula is made up of predicate calculus <strong class="calibre6">atoms</strong>, which can be one of the following:</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40"><strong class="calibre6">1.</strong> An atom of the form <em class="calibre13">R</em>(<em class="calibre13">t<sub class="calibre65">i</sub></em>), where <em class="calibre13">R</em> is a relation name and <em class="calibre13">t<sub class="calibre65">i</sub></em> is a tuple variable. This atom identifies the range of the tuple variable <em class="calibre13">t<sub class="calibre65">i</sub></em> as the relation whose name is <em class="calibre13">R</em>. It evaluates to TRUE if <em class="calibre13">t<sub class="calibre65">i</sub></em> is a tuple in the relation <em class="calibre13">R</em>, and evaluates to FALSE otherwise.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><strong class="calibre6">2.</strong> An atom of the form <em class="calibre13">t<sub class="calibre65">i</sub></em>.<em class="calibre13">A</em>
<strong class="calibre6">op</strong>
<em class="calibre13">t<sub class="calibre65">j</sub></em>.<em class="calibre13">B</em>, where <strong class="calibre6">op</strong> is one of the comparison operators in the set {=, &lt;, ≤, &gt;, ≥, ≠}, <em class="calibre13">t<sub class="calibre65">i</sub></em> and <em class="calibre13">t<sub class="calibre65">j</sub></em> are tuple variables, <em class="calibre13">A</em> is an attribute of the relation on which <em class="calibre13">t<sub class="calibre65">i</sub></em> ranges, and <em class="calibre13">B</em> is an attribute of the relation on which <em class="calibre13">t<sub class="calibre65">j</sub></em> ranges.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><strong class="calibre6">3.</strong> An atom of the form <em class="calibre13">t<sub class="calibre65">i</sub></em>.<em class="calibre13">A</em>
<strong class="calibre6">op</strong>
<em class="calibre13">c</em> or <em class="calibre13">c</em>
<strong class="calibre6">op</strong>
<em class="calibre13">t<sub class="calibre65">j</sub></em>.<em class="calibre13">B</em>, where <strong class="calibre6">op</strong> is one of the comparison operators in the set {=, &lt;, ≤, &gt;, ≥, ≠}, <em class="calibre13">t<sub class="calibre65">i</sub></em> and <em class="calibre13">t<sub class="calibre65">j</sub></em> are tuple variables, <em class="calibre13">A</em> is an attribute of the relation on which <em class="calibre13">t<sub class="calibre65">i</sub></em> ranges, <em class="calibre13">B</em> is an attribute of the relation on which <em class="calibre13">t<sub class="calibre65">j</sub></em> ranges, and <em class="calibre13">c</em> is a constant value.</p></blockquote>
<p class="calibre18">Each of the preceding atoms evaluates to either TRUE or FALSE for a specific combination of tuples; this is called the <strong class="calibre6">truth value</strong> of an atom. In general, a tuple variable <em class="calibre13">t</em> ranges over all possible tuples <em class="calibre13">in the universe</em>. For atoms of the form <em class="calibre13">R</em>(<em class="calibre13">t</em>), if <em class="calibre13">t</em> is assigned to a tuple that is a <em class="calibre13">member of the specified relation R</em>, the atom is TRUE; otherwise, it is FALSE. In atoms of types 2 and 3, if the tuple variables are assigned to tuples such that the values of the specified attributes of the tuples satisfy the condition, then the atom is TRUE.</p><div class="calibre31"> </div>
<p class="calibre18">A <strong class="calibre6">formula</strong> (Boolean condition) is made up of one or more atoms connected via the logical operators <strong class="calibre6">AND</strong>, <strong class="calibre6">OR</strong>, and <strong class="calibre6">NOT</strong> and is defined recursively by Rules 1 and 2 as follows:</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/><em class="calibre13">Rule 1</em>: Every atom is a formula.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><a id="filepos643970" class="calibre3"></a><img alt="image" src="../images/00003.jpg" class="calibre16"/><em class="calibre13">Rule 2</em>: If <em class="calibre13">F</em><sub class="calibre65">1</sub> and <em class="calibre13">F</em><sub class="calibre65">2</sub> are formulas, then so are (<em class="calibre13">F</em><sub class="calibre65">1</sub><strong class="calibre6">AND</strong>
<em class="calibre13">F</em><sub class="calibre65">2</sub>), (<em class="calibre13">F</em><sub class="calibre65">1</sub><strong class="calibre6">OR</strong>
<em class="calibre13">F</em><sub class="calibre65">2</sub>), <strong class="calibre6">NOT</strong> (<em class="calibre13">F</em><sub class="calibre65">1</sub>), and <strong class="calibre6">NOT</strong> (<em class="calibre13">F</em><sub class="calibre65">2</sub>). The truth values of these formulas are derived from their component formulas <em class="calibre13">F</em><sub class="calibre65">1</sub> and <em class="calibre13">F</em><sub class="calibre65">2</sub> as follows:</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">a. (<em class="calibre13">F</em><sub class="calibre65">1</sub><strong class="calibre6">AND</strong>
<em class="calibre13">F</em><sub class="calibre65">2</sub>) is TRUE if both <em class="calibre13">F</em><sub class="calibre65">1</sub> and <em class="calibre13">F</em><sub class="calibre65">2</sub> are TRUE; otherwise, it is FALSE.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">b. (<em class="calibre13">F</em><sub class="calibre65">1</sub><strong class="calibre6">OR</strong>
<em class="calibre13">F</em><sub class="calibre65">2</sub>) is FALSE if both <em class="calibre13">F</em><sub class="calibre65">1</sub> and <em class="calibre13">F</em><sub class="calibre65">2</sub> are FALSE; otherwise, it is TRUE.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">c. <strong class="calibre6">NOT</strong> (<em class="calibre13">F</em><sub class="calibre65">1</sub>) is TRUE if <em class="calibre13">F</em><sub class="calibre65">1</sub> is FALSE; it is FALSE if <em class="calibre13">F</em><sub class="calibre65">1</sub> is TRUE.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">d. <strong class="calibre6">NOT</strong> (<em class="calibre13">F</em><sub class="calibre65">2</sub>) is TRUE if <em class="calibre13">F</em><sub class="calibre65">2</sub> is FALSE; it is FALSE if <em class="calibre13">F</em><sub class="calibre65">2</sub> is TRUE.</p></blockquote>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">6.6.3 The Existential and Universal Quantifiers</span></span></blockquote></h5>
<p class="calibre18">In addition, two special symbols called <strong class="calibre6">quantifiers</strong> can appear in formulas; these are the <strong class="calibre6">universal quantifier</strong> (<img alt="image" src="../images/00142.jpg" class="calibre16"/>) and the <strong class="calibre6">existential quantifier</strong> (<img alt="image" src="../images/00143.jpg" class="calibre16"/>). Truth values for formulas with quantifiers are described in Rules 3 and 4 below; first, however, we need to define the concepts of free and bound tuple variables in a formula. Informally, a tuple variable <em class="calibre13">t</em> is bound if it is quantified, meaning that it appears in an (<img alt="image" src="../images/00143.jpg" class="calibre16"/><em class="calibre13">t</em>) or (<img alt="image" src="../images/00142.jpg" class="calibre16"/><em class="calibre13">t</em>) clause; otherwise, it is free. Formally, we define a tuple variable in a formula as <strong class="calibre6">free</strong> or <strong class="calibre6">bound</strong> according to the following rules:</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> An occurrence of a tuple variable in a formula <em class="calibre13">F</em> that <em class="calibre13">is an atom</em> is free in <em class="calibre13">F</em>.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> An occurrence of a tuple variable <em class="calibre13">t</em> is free or bound in a formula made up of logical connectives—(<em class="calibre13">F</em><sub class="calibre65">1</sub><strong class="calibre6">AND</strong>
<em class="calibre13">F</em><sub class="calibre65">2</sub>), (<em class="calibre13">F</em><sub class="calibre65">1</sub><strong class="calibre6">OR</strong>
<em class="calibre13">F</em><sub class="calibre65">2</sub>), <strong class="calibre6">NOT</strong> (<em class="calibre13">F</em><sub class="calibre65">1</sub>), and <strong class="calibre6">NOT</strong>(<em class="calibre13">F</em><sub class="calibre65">2</sub>)—depending on whether it is free or bound in <em class="calibre13">F</em><sub class="calibre65">1</sub> or <em class="calibre13">F</em><sub class="calibre65">2</sub> (if it occurs in either). Notice that in a formula of the form <em class="calibre13">F</em> = (<em class="calibre13">F</em><sub class="calibre65">1</sub><strong class="calibre6">AND</strong>
<em class="calibre13">F</em><sub class="calibre65">2</sub>) or <em class="calibre13">F</em> = (<em class="calibre13">F</em><sub class="calibre65">1</sub><strong class="calibre6">OR</strong>
<em class="calibre13">F</em><sub class="calibre65">2</sub>), a tuple variable may be free in <em class="calibre13">F</em><sub class="calibre65">1</sub> and bound in <em class="calibre13">F</em><sub class="calibre65">2</sub>, or vice versa; in this case, one occurrence of the tuple variable is bound and the other is free in <em class="calibre13">F</em>.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> All <em class="calibre13">free</em> occurrences of a tuple variable <em class="calibre13">t</em> in <em class="calibre13">F</em> are <strong class="calibre6">bound</strong> in a formula <em class="calibre13">F</em>′ of the form <em class="calibre13">F</em>′ = (<img alt="image" src="../images/00143.jpg" class="calibre16"/><em class="calibre13">t</em>)(<em class="calibre13">F</em>) or <em class="calibre13">F</em>′ = (<img alt="image" src="../images/00142.jpg" class="calibre16"/><em class="calibre13">t</em>)(<em class="calibre13">F</em>). The tuple variable is bound to the quantifier specified in <em class="calibre13">F</em>′. For example, consider the following formulas:</p></blockquote>
<blockquote class="calibre30"><p class="calibre17"><em class="calibre13">F</em><sub class="calibre65">1</sub> : <em class="calibre13">d</em>.Dname=‘Research’</p></blockquote>
<blockquote class="calibre30"><p class="calibre17"><em class="calibre13">F</em><sub class="calibre65">2</sub> : (<img alt="image" src="../images/00143.jpg" class="calibre16"/><em class="calibre13">t</em>)(<em class="calibre13">d</em>.Dnumber=<em class="calibre13">t</em>.Dno)</p></blockquote>
<blockquote class="calibre30"><p class="calibre17"><em class="calibre13">F</em><sub class="calibre65">3</sub> : (<img alt="image" src="../images/00142.jpg" class="calibre16"/><em class="calibre13">d</em>)(<em class="calibre13">d</em>.Mgr_ssn=‘333445555’)</p></blockquote>
<p class="calibre18">The tuple variable <em class="calibre13">d</em> is free in both <em class="calibre13">F</em><sub class="calibre65">1</sub> and <em class="calibre13">F</em><sub class="calibre65">2</sub>, whereas it is bound to the (<img alt="image" src="../images/00142.jpg" class="calibre16"/>) quantifier in <em class="calibre13">F</em><sub class="calibre65">3</sub>. Variable <em class="calibre13">t</em> is bound to the (<img alt="image" src="../images/00143.jpg" class="calibre16"/>) quantifier in <em class="calibre13">F</em><sub class="calibre65">2</sub>.</p><div class="calibre31"> </div>
<p class="calibre18">We can now give Rules 3 and 4 for the definition of a formula we started earlier:</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/><em class="calibre13">Rule 3</em>: If <em class="calibre13">F</em> is a formula, then so is (<img alt="image" src="../images/00143.jpg" class="calibre16"/><em class="calibre13">t</em>)(<em class="calibre13">F</em>), where <em class="calibre13">t</em> is a tuple variable. The formula (<img alt="image" src="../images/00143.jpg" class="calibre16"/><em class="calibre13">t</em>)(<em class="calibre13">F</em>) is TRUE if the formula <em class="calibre13">F</em> evaluates to TRUE for <em class="calibre13">some</em> (at least one) tuple assigned to free occurrences of <em class="calibre13">t</em> in <em class="calibre13">F</em>; otherwise, (<img alt="image" src="../images/00143.jpg" class="calibre16"/><em class="calibre13">t</em>)(<em class="calibre13">F</em>) is FALSE.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/><em class="calibre13">Rule 4</em>: If <em class="calibre13">F</em> is a formula, then so is (<img alt="image" src="../images/00142.jpg" class="calibre16"/><em class="calibre13">t</em>)(<em class="calibre13">F</em>), where <em class="calibre13">t</em> is a tuple variable. The formula (<img alt="image" src="../images/00142.jpg" class="calibre16"/><em class="calibre13">t</em>)(<em class="calibre13">F</em>) is TRUE if the formula <em class="calibre13">F</em> evaluates to TRUE for <em class="calibre13">every tuple</em> (in the universe) assigned to free occurrences of <em class="calibre13">t</em> in <em class="calibre13">F</em>; otherwise, (<img alt="image" src="../images/00142.jpg" class="calibre16"/><em class="calibre13">t</em>)(<em class="calibre13">F</em>) is FALSE.</p></blockquote>
<p class="calibre18">The (<img alt="image" src="../images/00143.jpg" class="calibre16"/>) quantifier is called an existential quantifier because a formula (<img alt="image" src="../images/00143.jpg" class="calibre16"/><em class="calibre13">t</em>)(<em class="calibre13">F</em>) is TRUE if <em class="calibre13">there exists</em> some tuple that makes <em class="calibre13">F</em> TRUE. For the universal quantifier, <a id="filepos650877" class="calibre3"></a>(<img alt="image" src="../images/00142.jpg" class="calibre16"/><em class="calibre13">t</em>)(<em class="calibre13">F</em>) is TRUE if every possible tuple that can be assigned to free occurrences of <em class="calibre13">t</em> in <em class="calibre13">F</em> is substituted for <em class="calibre13">t</em>, and <em class="calibre13">F</em> is TRUE for <em class="calibre13">every such substitution</em>. It is called the universal or <em class="calibre13">for all</em> quantifier because every tuple in <em class="calibre13">the universe of</em> tuples must make <em class="calibre13">F</em> TRUE to make the quantified formula TRUE.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">6.6.4 Sample Queries in Tuple Relational Calculus</span></span></blockquote></h5>
<p class="calibre18">We will use some of the same queries from Section 6.5 to give a flavor of how the same queries are specified in relational algebra and in relational calculus. Notice that some queries are easier to specify in the relational algebra than in the relational calculus, and vice versa.</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><strong class="calibre6">Query 1.</strong> List the name and address of all employees who work for the ‘Research’ department.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><strong class="calibre6">Q1:</strong> {<em class="calibre13">t</em>.Fname, <em class="calibre13">t</em>.Lname, <em class="calibre13">t</em>.Address | EMPLOYEE(<em class="calibre13">t</em>) <strong class="calibre6">AND</strong> (<img alt="image" src="../images/00143.jpg" class="calibre16"/><em class="calibre13">d</em>)(DEPARTMENT(<em class="calibre13">d</em>) <strong class="calibre6">AND</strong>
<em class="calibre13">d</em>.Dname=‘Research’ <strong class="calibre6">AND</strong>
<em class="calibre13">d</em>.Dnumber=<em class="calibre13">t</em>.Dno)}</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">The <em class="calibre13">only free tuple variables</em> in a tuple relational calculus expression should be those that appear to the left of the bar (|). In Q1, <em class="calibre13">t</em> is the only free variable; it is then <em class="calibre13">bound successively</em> to each tuple. If a tuple <em class="calibre13">satisfies the conditions</em> specified after the bar in Q1, the attributes Fname, Lname, and Address are retrieved for each such tuple. The conditions EMPLOYEE(<em class="calibre13">t</em>) and DEPARTMENT(<em class="calibre13">d</em>) specify the range relations for <em class="calibre13">t</em> and <em class="calibre13">d</em>. The condition <em class="calibre13">d</em>.Dname = ‘Research’ is a <strong class="calibre6">selection condition</strong> and corresponds to a SELECT operation in the relational algebra, whereas the condition <em class="calibre13">d</em>.Dnumber = <em class="calibre13">t</em>.Dno is a <strong class="calibre6">join condition</strong> and is similar in purpose to the (INNER) JOIN operation (see Section 6.3).</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><strong class="calibre6">Query 2.</strong> For every project located in ‘Stafford’, list the project number, the controlling department number, and the department manager’s last name, birth date, and address.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">Q2:</strong> {<em class="calibre13">p</em>.Pnumber, <em class="calibre13">p</em>.Dnum, <em class="calibre13">m</em>.Lname, <em class="calibre13">m</em>.Bdate, <em class="calibre13">m</em>.Address | PROJECT(<em class="calibre13">p</em>) <strong class="calibre6">AND</strong> EMPLOYEE(<em class="calibre13">m</em>) <strong class="calibre6">AND</strong>
<em class="calibre13">p</em>.Plocation=‘Stafford’ <strong class="calibre6">AND</strong> ((<img alt="image" src="../images/00143.jpg" class="calibre16"/><em class="calibre13">d</em>)(DEPARTMENT(<em class="calibre13">d</em>) <strong class="calibre6">AND</strong>
<em class="calibre13">p</em>.Dnum=<em class="calibre13">d</em>.Dnumber <strong class="calibre6">AND</strong>
<em class="calibre13">d</em>.Mgr_ssn=<em class="calibre13">m</em>.Ssn))}</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">In Q2 there are two free tuple variables, <em class="calibre13">p</em> and <em class="calibre13">m</em>. Tuple variable <em class="calibre13">d</em> is bound to the existential quantifier. The query condition is evaluated for every combination of tuples assigned to <em class="calibre13">p</em> and <em class="calibre13">m</em>, and out of all possible combinations of tuples to which <em class="calibre13">p</em> and <em class="calibre13">m</em> are bound, only the combinations that satisfy the condition are selected.</p><div class="calibre31"> </div>
<p class="calibre18">Several tuple variables in a query can range over the same relation. For example, to specify Q8—for each employee, retrieve the employee’s first and last name and the first and last name of his or her immediate supervisor—we specify two tuple variables <em class="calibre13">e</em> and <em class="calibre13">s</em> that both range over the EMPLOYEE relation:</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">Q8:</strong> {<em class="calibre13">e</em>.Fname, <em class="calibre13">e</em>.Lname, <em class="calibre13">s</em>.Fname, <em class="calibre13">s</em>.Lname | EMPLOYEE(<em class="calibre13">e</em>) <strong class="calibre6">AND</strong> EMPLOYEE(<em class="calibre13">s</em>) <strong class="calibre6">AND</strong>
<em class="calibre13">e</em>.Super_ssn=<em class="calibre13">s</em>.Ssn}</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><strong class="calibre6">Query 3′.</strong> List the name of each employee who works on <em class="calibre13">some</em> project controlled by department number 5. This is a variation of Q3 in which <em class="calibre13">all</em> is <a id="filepos655614" class="calibre3"></a>changed to <em class="calibre13">some</em>. In this case we need two join conditions and two existential quantifiers.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">Q0</strong>′<strong class="calibre6">:</strong> {<em class="calibre13">e</em>.Lname, <em class="calibre13">e</em>.Fname | EMPLOYEE(<em class="calibre13">e</em>) <strong class="calibre6">AND</strong> ((<img alt="image" src="../images/00143.jpg" class="calibre16"/><em class="calibre13">x</em>)(<img alt="image" src="../images/00143.jpg" class="calibre16"/><em class="calibre13">w</em>)(PROJECT(<em class="calibre13">x</em>) <strong class="calibre6">AND</strong> WORKS_ON(<em class="calibre13">w</em>) <strong class="calibre6">AND</strong>
<em class="calibre13">x</em>.Dnum=5 <strong class="calibre6">AND</strong>
<em class="calibre13">w</em>.Essn=<em class="calibre13">e</em>.Ssn <strong class="calibre6">AND</strong>
<em class="calibre13">x</em>.Pnumber=<em class="calibre13">w</em>.Pno))}</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><strong class="calibre6">Query 4.</strong> Make a list of project numbers for projects that involve an employee whose last name is ‘Smith’, either as a worker or as manager of the controlling department for the project.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">Q4:</strong> {<em class="calibre13">p</em>.Pnumber | PROJECT(<em class="calibre13">p</em>) <strong class="calibre6">AND</strong> (((<img alt="image" src="../images/00143.jpg" class="calibre16"/><em class="calibre13">e</em>)(<img alt="image" src="../images/00143.jpg" class="calibre16"/><em class="calibre13">w</em>)(EMPLOYEE(<em class="calibre13">e</em>)<br class="calibre1"/><strong class="calibre6">AND</strong> WORKS_ON(<em class="calibre13">w</em>) <strong class="calibre6">AND</strong>
<em class="calibre13">w</em>.Pno=<em class="calibre13">p</em>.Pnumber<br class="calibre1"/><strong class="calibre6">AND</strong>
<em class="calibre13">e</em>.Lname=‘Smith’ <strong class="calibre6">AND</strong>
<em class="calibre13">e</em>.Ssn=<em class="calibre13">w</em>.Essn))<br class="calibre1"/><strong class="calibre6">OR</strong><br class="calibre1"/>((<img alt="image" src="../images/00143.jpg" class="calibre16"/><em class="calibre13">m</em>)(<img alt="image" src="../images/00143.jpg" class="calibre16"/><em class="calibre13">d</em>)(EMPLOYEE(<em class="calibre13">m</em>) <strong class="calibre6">AND</strong> DEPARTMENT(<em class="calibre13">d</em>)<br class="calibre1"/><strong class="calibre6">AND</strong>
<em class="calibre13">p</em>.Dnum=<em class="calibre13">d</em>.Dnumber <strong class="calibre6">AND</strong>
<em class="calibre13">d</em>.Mgr_ssn=<em class="calibre13">m</em>.Ssn<br class="calibre1"/><strong class="calibre6">AND</strong>
<em class="calibre13">m</em>.Lname=‘Smith’)))}</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">Compare this with the relational algebra version of this query in Section 6.5. The UNION operation in relational algebra can usually be substituted with an OR connective in relational calculus.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">6.6.5 Notation for Query Graphs</span></span></blockquote></h5>
<p class="calibre18">In this section we describe a notation that has been proposed to represent relational calculus queries that do not involve complex quantification in a graphical form. These types of queries are known as <strong class="calibre6">select-project-join queries</strong>, because they only involve these three relational algebra operations. The notation may be expanded to more general queries, but we do not discuss these extensions here. This graphical representation of a query is called a <strong class="calibre6">query graph</strong>. <a href="#filepos659090" class="calibre41">Figure 6.13</a> shows the query graph for Q2. Relations in the query are represented by <strong class="calibre6">relation nodes</strong>, which are displayed as single circles. Constant values, typically from the query selection conditions, are represented by <strong class="calibre6">constant nodes</strong>, which are displayed as double circles or ovals. Selection and join conditions are represented by the graph <strong class="calibre6">edges</strong> (the lines that connect the nodes), as shown in <a href="#filepos659090" class="calibre41">Figure 6.13</a>. Finally, the attributes to be retrieved from each relation are displayed in square brackets above each relation.</p><div class="calibre31"> </div>
<p id="filepos659090" class="calibre7"><img alt="image" src="../images/00144.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 6.13</strong><br class="calibre1"/>Query graph for Q2.</p><div class="calibre31"> </div>
<p class="calibre18"><a id="filepos659315" class="calibre3"></a>The query graph representation does not indicate a particular order to specify which operations to perform first, and is hence a more neutral representation of a select-project-join query than the query tree representation (see Section 6.3.5), where the order of execution is implicitly specified. There is only a single query graph corresponding to each query. Although some query optimization techniques were based on query graphs, it is now generally accepted that query trees are preferable because, in practice, the query optimizer needs to show the order of operations for query execution, which is not possible in query graphs.</p><div class="calibre31"> </div>
<p class="calibre18">In the next section we discuss the relationship between the universal and existential quantifiers and show how one can be transformed into the other.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">6.6.6 Transforming the Universal and Existential Quantifiers</span></span></blockquote></h5>
<p class="calibre18">We now introduce some well-known transformations from mathematical logic that relate the universal and existential quantifiers. It is possible to transform a universal quantifier into an existential quantifier, and vice versa, to get an equivalent expression. One general transformation can be described informally as follows: Transform one type of quantifier into the other with negation (preceded by <strong class="calibre6">NOT</strong>); <strong class="calibre6">AND</strong> and <strong class="calibre6">OR</strong> replace one another; a negated formula becomes unnegated; and an unnegated formula becomes negated. Some special cases of this transformation can be stated as follows, where the ≡ symbol stands for <strong class="calibre6">equivalent to</strong>:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">(<img alt="image" src="../images/00142.jpg" class="calibre16"/><em class="calibre13">x</em>) (<em class="calibre13">P</em>(<em class="calibre13">x</em>)) ≡ <strong class="calibre6">NOT</strong> (<img alt="image" src="../images/00143.jpg" class="calibre16"/><em class="calibre13">x</em>) (<strong class="calibre6">NOT</strong> (<em class="calibre13">P</em>(<em class="calibre13">x</em>)))</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">(<img alt="image" src="../images/00143.jpg" class="calibre16"/><em class="calibre13">x</em>) (<em class="calibre13">P</em>(<em class="calibre13">x</em>)) ≡ <strong class="calibre6">NOT</strong> (<img alt="image" src="../images/00142.jpg" class="calibre16"/><em class="calibre13">x</em>) (<strong class="calibre6">NOT</strong> (<em class="calibre13">P</em>(<em class="calibre13">x</em>)))</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">(<img alt="image" src="../images/00142.jpg" class="calibre16"/><em class="calibre13">x</em>) (<em class="calibre13">P</em>(<em class="calibre13">x</em>) <strong class="calibre6">AND</strong>
<em class="calibre13">Q</em> (<em class="calibre13">x</em>)) ≡ <strong class="calibre6">NOT</strong> (<img alt="image" src="../images/00143.jpg" class="calibre16"/><em class="calibre13">x</em>) (<strong class="calibre6">NOT</strong> (<em class="calibre13">P</em>(<em class="calibre13">x</em>)) <strong class="calibre6">OR NOT</strong>(<em class="calibre13">Q</em>(<em class="calibre13">x</em>)))</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">(<img alt="image" src="../images/00142.jpg" class="calibre16"/><em class="calibre13">x</em>) (<em class="calibre13">P</em>(<em class="calibre13">x</em>) <strong class="calibre6">OR</strong>
<em class="calibre13">Q</em> (<em class="calibre13">x</em>)) ≡ <strong class="calibre6">NOT</strong> (<img alt="image" src="../images/00143.jpg" class="calibre16"/><em class="calibre13">x</em>) (<strong class="calibre6">NOT</strong> (<em class="calibre13">P</em>(<em class="calibre13">x</em>)) <strong class="calibre6">AND NOT</strong> (<em class="calibre13">Q</em>(<em class="calibre13">x</em>)))</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">(<img alt="image" src="../images/00143.jpg" class="calibre16"/><em class="calibre13">x</em>) (<em class="calibre13">P</em>(<em class="calibre13">x</em>)) <strong class="calibre6">OR</strong>
<em class="calibre13">Q</em> (<em class="calibre13">x</em>)) ≡ <strong class="calibre6">NOT</strong> (<img alt="image" src="../images/00142.jpg" class="calibre16"/><em class="calibre13">x</em>) (<strong class="calibre6">NOT</strong> (<em class="calibre13">P</em>(<em class="calibre13">x</em>)) <strong class="calibre6">AND NOT</strong> (<em class="calibre13">Q</em>(<em class="calibre13">x</em>)))</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">(<img alt="image" src="../images/00143.jpg" class="calibre16"/><em class="calibre13">x</em>) (<em class="calibre13">P</em>(<em class="calibre13">x</em>) <strong class="calibre6">AND</strong>
<em class="calibre13">Q</em> (<em class="calibre13">x</em>)) ≡ <strong class="calibre6">NOT</strong> (<img alt="image" src="../images/00142.jpg" class="calibre16"/><em class="calibre13">x</em>) (<strong class="calibre6">NOT</strong> (<em class="calibre13">P</em>(<em class="calibre13">x</em>)) <strong class="calibre6">OR NOT</strong> (<em class="calibre13">Q</em>(<em class="calibre13">x</em>)))</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">Notice also that the following is TRUE, where the ⇒ symbol stands for <strong class="calibre6">implies</strong>:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">(<img alt="image" src="../images/00142.jpg" class="calibre16"/><em class="calibre13">x</em>)(<em class="calibre13">P</em>(<em class="calibre13">x</em>)) ⇒ (<img alt="image" src="../images/00143.jpg" class="calibre16"/><em class="calibre13">x</em>)(<em class="calibre13">P</em>(<em class="calibre13">x</em>))</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><strong class="calibre6">NOT</strong> (<img alt="image" src="../images/00143.jpg" class="calibre16"/><em class="calibre13">x</em>)(<em class="calibre13">P</em>(<em class="calibre13">x</em>)) ⇒ <strong class="calibre6">NOT</strong> (<img alt="image" src="../images/00142.jpg" class="calibre16"/><em class="calibre13">x</em>)(<em class="calibre13">P</em>(<em class="calibre13">x</em>))</p></blockquote><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">6.6.7 Using the Universal Quantifier in Queries</span></span></blockquote></h5>
<p class="calibre18">Whenever we use a universal quantifier, it is quite judicious to follow a few rules to ensure that our expression makes sense. We discuss these rules with respect to the query Q3.</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><strong class="calibre6">Query 3.</strong> List the names of employees who work on <em class="calibre13">all</em> the projects controlled by department number 5. One way to specify this query is to use the universal quantifier as shown:</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">Q3:</strong> {<em class="calibre13">e</em>.Lname, <em class="calibre13">e</em>.Fname | EMPLOYEE(<em class="calibre13">e</em>) <strong class="calibre6">AND</strong> ((<img alt="image" src="../images/00142.jpg" class="calibre16"/><em class="calibre13">x</em>)(<strong class="calibre6">NOT</strong>(PROJECT(<em class="calibre13">x</em>)) <strong class="calibre6">OR NOT</strong> (<em class="calibre13">x</em>.Dnum=5) <strong class="calibre6">OR</strong> ((<img alt="image" src="../images/00143.jpg" class="calibre16"/><em class="calibre13">w</em>)(WORKS_ON(<em class="calibre13">w</em>) <strong class="calibre6">AND</strong>
<em class="calibre13">w</em>.Essn=<em class="calibre13">e</em>.Ssn <strong class="calibre6">AND</strong>
<em class="calibre13">x</em>.Pnumber=<em class="calibre13">w</em>.Pno))))}</p></blockquote><div class="calibre31"> </div>
<p class="calibre18"><a class="calibre3"></a>We can break up Q3 into its basic components as follows:</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">Q3:</strong> {<em class="calibre13">e</em>.Lname, <em class="calibre13">e</em>.Fname | EMPLOYEE(<em class="calibre13">e</em>) <strong class="calibre6">AND</strong>
<em class="calibre13">F</em>′ }<br class="calibre1"/><em class="calibre13">F</em> = ((<img alt="image" src="../images/00145.jpg" class="calibre16"/><em class="calibre13">x</em>)(<strong class="calibre6">NOT</strong>(PROJECT(<em class="calibre13">x</em>)) <strong class="calibre6">OR</strong>
<em class="calibre13">F</em><sub class="calibre65">1</sub>))<br class="calibre1"/><em class="calibre13">F</em><sub class="calibre65">1</sub> = <strong class="calibre6">NOT</strong> (<em class="calibre13">x</em>Dnum=5) <strong class="calibre6">OR</strong>
<em class="calibre13">F</em><sub class="calibre65">2</sub><br class="calibre1"/><em class="calibre13">F</em><sub class="calibre65">2</sub> = ((<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">w</em>)(WORKS_ON(<em class="calibre13">w</em>) <strong class="calibre6">AND</strong>
<em class="calibre13">w</em>.Essn=<em class="calibre13">e</em>.Ssn<br class="calibre1"/><strong class="calibre6">AND</strong><em class="calibre13">x</em>.Pnumber=<em class="calibre13">w</em>.Pno))</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">We want to make sure that a selected employee <em class="calibre13">e</em> works on <em class="calibre13">all the projects</em> controlled by department 5, but the <em class="calibre13">definition of universal quantifier</em> says that to make the quantified formula TRUE, <em class="calibre13">the inner formula</em> must be TRUE <em class="calibre13">for all tuples in the universe</em>. The trick is to exclude from the universal quantification all tuples that we are not interested in by making the condition TRUE <em class="calibre13">for all such tuples</em>. This is necessary because a universally quantified tuple variable, such as <em class="calibre13">x</em> in Q3, must evaluate to TRUE <em class="calibre13">for every possible tuple</em> assigned to it to make the quantified formula TRUE.</p><div class="calibre31"> </div>
<p class="calibre18">The first tuples to exclude (by making them evaluate automatically to TRUE) are those that are not in the relation <em class="calibre13">R</em> of interest. In Q3, using the expression <strong class="calibre6">NOT</strong>(PROJECT(<em class="calibre13">x</em>)) inside the universally quantified formula evaluates to TRUE all tuples <em class="calibre13">x</em> that are not in the PROJECT relation. Then we exclude the tuples we are not interested in from <em class="calibre13">R</em> itself. In Q3, using the expression <strong class="calibre6">NOT</strong>(<em class="calibre13">x</em>.Dnum=5) evaluates to TRUE all tuples <em class="calibre13">x</em> that are in the PROJECT relation but are not controlled by department 5. Finally, we specify a condition <em class="calibre13">F</em><sub class="calibre65">2</sub> that must hold on all the remaining tuples in <em class="calibre13">R</em>. Hence, we can explain Q3 as follows:</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40"><strong class="calibre6">1.</strong> For the formula <em class="calibre13">F</em>″ = (<img alt="image" src="../images/00147.jpg" class="calibre16"/><em class="calibre13">x</em>)(<em class="calibre13">F</em>) to be TRUE, we must have the formula <em class="calibre13">F</em> be TRUE <em class="calibre13">for all tuples in the universe that can be assigned to x</em>. However, in Q3 we are only interested in <em class="calibre13">F</em> being TRUE for all tuples of the PROJECT relation that are controlled by department 5. Hence, the formula <em class="calibre13">F</em> is of the form (<strong class="calibre6">NOT</strong>(PROJECT(<em class="calibre13">x</em>)) <strong class="calibre6">OR</strong>
<em class="calibre13">F</em><sub class="calibre65">1</sub>). The ‘<strong class="calibre6">NOT</strong> (PROJECT(<em class="calibre13">x</em>)) <strong class="calibre6">OR</strong> ...’ condition is TRUE for all tuples <em class="calibre13">not in the PROJECT relation</em> and has the effect of eliminating these tuples from consideration in the truth value of <em class="calibre13">F</em><sub class="calibre65">1</sub>. For every tuple in the PROJECT relation, <em class="calibre13">F</em><sub class="calibre65">1</sub> must be TRUE if <em class="calibre13">F</em>’ is to be TRUE.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><strong class="calibre6">2.</strong> Using the same line of reasoning, we do not want to consider tuples in the PROJECT relation that are not controlled by department number 5, since we are only interested in PROJECT tuples whose Dnum=5. Therefore, we can write:</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><strong class="calibre6">IF</strong> (<em class="calibre13">x</em>.Dnum=5) <strong class="calibre6">THEN</strong>
<em class="calibre13">F</em><sub class="calibre65">2</sub></p></blockquote>
<blockquote class="calibre45"><p class="calibre18">which is equivalent to</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40">(<strong class="calibre6">NOT</strong> (<em class="calibre13">x</em>.Dnum=5) <strong class="calibre6">OR</strong>
<em class="calibre13">F</em><sub class="calibre65">2</sub>)</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><strong class="calibre6">3.</strong> Formula <em class="calibre13">F</em><sub class="calibre65">1</sub>, hence, is of the form <strong class="calibre6">NOT</strong>(<em class="calibre13">x</em>.Dnum=5) <strong class="calibre6">OR</strong>
<em class="calibre13">F</em><sub class="calibre65">2</sub>. In the context of Q3, this means that, for a tuple <em class="calibre13">x</em> in the PROJECT relation, either its Dnum≠5 or it must satisfy <em class="calibre13">F</em><sub class="calibre65">2</sub>.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><strong class="calibre6">4.</strong> Finally, <em class="calibre13">F</em><sub class="calibre65">2</sub> gives the condition that we want to hold for a selected EMPLOYEE tuple: that the employee works on <em class="calibre13">every</em> PROJECT <em class="calibre13">tuple that has not been excluded yet</em> Such employee tuples are selected by the query.</p></blockquote>
<p class="calibre18"><a id="filepos670134" class="calibre3"></a>In English, Q3 gives the following condition for selecting an EMPLOYEE tuple <em class="calibre13">e</em>: For every tuple <em class="calibre13">x</em> in the PROJECT relation with <em class="calibre13">x</em>.Dnum=5, there must exist a tuple <em class="calibre13">w</em> in WORKS_ON such that <em class="calibre13">w</em>.Essn=<em class="calibre13">e</em>.Ssn and <em class="calibre13">w</em>.Pno=<em class="calibre13">x</em>.Pnumber. This is equivalent to saying that EMPLOYEE <em class="calibre13">e</em> works on every PROJECT <em class="calibre13">x</em> in DEPARTMENT number 5. (Whew!)</p><div class="calibre31"> </div>
<p class="calibre18">Using the general transformation from universal to existential quantifiers given in Section 6.6.6, we can rephrase the query in Q3 as shown in Q3A, which uses a negated existential quantifier instead of the universal quantifier:</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">Q3A:</strong> {<em class="calibre13">e</em>.Lname, <em class="calibre13">e</em>.Fname | EMPLOYEE(<em class="calibre13">e</em>) <strong class="calibre6">AND</strong> (<strong class="calibre6">NOT</strong>(<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">x</em>) (PROJECT(<em class="calibre13">x</em>) <strong class="calibre6">AND</strong> (<em class="calibre13">x</em>.Dnum=5) AND (<strong class="calibre6">NOT</strong>(<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">w</em>)(WORKS_ON(<em class="calibre13">w</em>) <strong class="calibre6">AND</strong>
<em class="calibre13">w</em>.Essn=<em class="calibre13">e</em>.Ssn <strong class="calibre6">AND</strong><em class="calibre13">x</em>.Pnumber=<em class="calibre13">w</em>.Pno))))}</p></blockquote><div class="calibre31"> </div>
<p class="calibre58">We now give some additional examples of queries that use quantifiers.</p>
<blockquote class="calibre45"><p class="calibre18"><strong class="calibre6">Query 6.</strong> List the names of employees who have no dependents.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">Q6:</strong> {<em class="calibre13">e</em>.Fname, <em class="calibre13">e</em>.Lname | EMPLOYEE(<em class="calibre13">e</em>) <strong class="calibre6">AND</strong> (<strong class="calibre6">NOT</strong> (<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">d</em>)(DEPENDENT(<em class="calibre13">d</em>) <strong class="calibre6">AND</strong>
<em class="calibre13">e</em>.Ssn=<em class="calibre13">d</em>.Essn))}</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">Using the general transformation rule, we can rephrase Q6 as follows:</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">Q6A:</strong> {<em class="calibre13">e</em>.Fname, <em class="calibre13">e</em>.Lname | EMPLOYEE(<em class="calibre13">e</em>) <strong class="calibre6">AND</strong> ((<img alt="image" src="../images/00147.jpg" class="calibre16"/><em class="calibre13">d</em>)(<strong class="calibre6">NOT</strong>(DEPENDENT(<em class="calibre13">d</em>)) <strong class="calibre6">OR NOT</strong>(<em class="calibre13">e</em>.Ssn=<em class="calibre13">d</em>.Essn)))}</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><strong class="calibre6">Query 7.</strong> List the names of managers who have at least one dependent.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">Q7:</strong> {<em class="calibre13">e</em>.Fname, <em class="calibre13">e</em>.Lname | EMPLOYEE(<em class="calibre13">e</em>) <strong class="calibre6">AND</strong> ((<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">d</em>)(<img alt="image" src="../images/00146.jpg" class="calibre16"/><sub class="calibre65">ρ</sub>)(DEPARTMENT(<em class="calibre13">d</em>) <strong class="calibre6">AND</strong> DEPENDENT(ρ) <strong class="calibre6">AND</strong>
<em class="calibre13">e</em>.Ssn=<em class="calibre13">d</em>.Mgr_ssn <strong class="calibre6">AND</strong> ρ.Essn=<em class="calibre13">e</em>.Ssn))}</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">This query is handled by interpreting <em class="calibre13">managers who have at least one dependent</em> as <em class="calibre13">managers for whom there exists some dependent</em>.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">6.6.8 Safe Expressions</span></span></blockquote></h5>
<p class="calibre18">Whenever we use universal quantifiers, existential quantifiers, or negation of predicates in a calculus expression, we must make sure that the resulting expression makes sense. A <strong class="calibre6">safe expression</strong> in relational calculus is one that is guaranteed to yield a <em class="calibre13">finite number of tuples</em> as its result; otherwise, the expression is called <strong class="calibre6">unsafe</strong>. For example, the expression</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">{<em class="calibre13">t</em> | <strong class="calibre6">NOT</strong> (EMPLOYEE(<em class="calibre13">t</em>))}</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">is <em class="calibre13">unsafe</em> because it yields all tuples in the universe that are <em class="calibre13">not</em> EMPLOYEE tuples, which are infinitely numerous. If we follow the rules for Q3 discussed earlier, we will get a safe expression when using universal quantifiers. We can define safe expressions more precisely by introducing the concept of the <em class="calibre13">domain of a tuple relational calculus expression:</em> This is the set of all values that either appear as constant values in the expression or exist in any tuple in the relations referenced in the expression. For example, the domain of {<em class="calibre13">t</em> | <strong class="calibre6">NOT</strong> (EMPLOYEE(<em class="calibre13">t</em>))} is the set of all attribute values appearing in some tuple of the EMPLOYEE relation (for any attribute). The domain <a id="filepos674877" class="calibre3"></a>of the expression Q3A would include all values appearing in EMPLOYEE, PROJECT, and WORKS_ON (unioned with the value 5 appearing in the query itself).</p><div class="calibre31"> </div>
<p class="calibre18">An expression is said to be <strong class="calibre6">safe</strong> if all values in its result are from the domain of the expression. Notice that the result of {<em class="calibre13">t</em> | <strong class="calibre6">NOT</strong> (EMPLOYEE(<em class="calibre13">t</em>))} is unsafe, since it will, in general, include tuples (and hence values) from outside the EMPLOYEE relation; such values are not in the domain of the expression. All of our other examples are safe expressions.</p><div class="calibre31"> </div>
<h4 id="filepos675529" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">6.7 The Domain Relational Calculus</span></span></blockquote></h4><div class="calibre31"> </div>
<p class="calibre18">There is another type of relational calculus called the domain relational calculus, or simply, <strong class="calibre6">domain calculus</strong>. Historically, while SQL (see <a href="dummy_split_019.html#filepos362078" class="calibre41">Chapters 4</a> and <a href="dummy_split_020.html#filepos448575" class="calibre41">5</a>), which was based on tuple relational calculus, was being developed by IBM Research at San Jose, California, another language called QBE (Query-By-Example), which is related to domain calculus, was being developed almost concurrently at the IBM T.J. Watson Research Center in Yorktown Heights, New York. The formal specification of the domain calculus was proposed after the development of the QBE language and system.</p><div class="calibre31"> </div>
<p class="calibre18">Domain calculus differs from tuple calculus in the <em class="calibre13">type of variables</em> used in formulas: Rather than having variables range over tuples, the variables range over single values from domains of attributes. To form a relation of degree <em class="calibre13">n</em> for a query result, we must have <em class="calibre13">n</em> of these <strong class="calibre6">domain variables</strong>—one for each attribute. An expression of the domain calculus is of the form</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">{<em class="calibre13">x</em><sub class="calibre65">1</sub>, <em class="calibre13">x</em><sub class="calibre65">2</sub>, ..., <em class="calibre13">x<sub class="calibre65">n</sub></em> | COND(<em class="calibre13">x</em><sub class="calibre65">1</sub>, <em class="calibre13">x</em><sub class="calibre65">2</sub>, ..., <em class="calibre13">x</em><sub class="calibre65">n</sub>, <em class="calibre13">x</em><sub class="calibre65"><em class="calibre13">n</em>+1</sub>, <em class="calibre13">x</em><sub class="calibre65"><em class="calibre13">n</em>+2</sub>, ..., <em class="calibre13">x</em><sub class="calibre65">n+m</sub>)}</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">where <em class="calibre13">x</em><sub class="calibre65">1</sub>, <em class="calibre13">x</em><sub class="calibre65">2</sub>, ..., <em class="calibre13">x</em><sub class="calibre65">n</sub>, <em class="calibre13">x</em><sub class="calibre65"><em class="calibre13">n</em>+1</sub>, <em class="calibre13">x</em><sub class="calibre65"><em class="calibre13">n</em>+2</sub>, ..., <em class="calibre13">x</em><sub class="calibre65"><em class="calibre13">n</em>+<em class="calibre13">m</em></sub> are domain variables that range over domains (of attributes), and COND is a <strong class="calibre6">condition</strong> or <strong class="calibre6">formula</strong> of the domain relational calculus.</p><div class="calibre31"> </div>
<p class="calibre18">A formula is made up of <strong class="calibre6">atoms</strong>. The atoms of a formula are slightly different from those for the tuple calculus and can be one of the following:</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40"><strong class="calibre6">1.</strong> An atom of the form R(<em class="calibre13">x</em><sub class="calibre65">1</sub>, <em class="calibre13">x</em><sub class="calibre65">2</sub>, ..., <em class="calibre13">x</em><sub class="calibre65">j</sub>), where <em class="calibre13">R</em> is the name of a relation of degree <em class="calibre13">j</em> and each <em class="calibre13">x</em><sub class="calibre65">i</sub>, 1 ≤ <em class="calibre13">i</em> ≤ <em class="calibre13">j</em>, is a domain variable. This atom states that a list of values of &lt;<em class="calibre13">x</em><sub class="calibre65">1</sub>, <em class="calibre13">x</em><sub class="calibre65">2</sub>, ..., <em class="calibre13">x</em><sub class="calibre65">j</sub>&gt; must be a tuple in the relation whose name is <em class="calibre13">R</em>, where <em class="calibre13">x</em><sub class="calibre65">i</sub> is the value of the <em class="calibre13">i</em>th attribute value of the tuple. To make a domain calculus expression more concise, we can <em class="calibre13">drop the commas</em> in a list of variables; thus, we can write:</p></blockquote>
<blockquote class="calibre45"><p class="calibre21">{<em class="calibre13">x</em><sub class="calibre65">1</sub>, <em class="calibre13">x</em><sub class="calibre65">2</sub>, ..., <em class="calibre13">x</em><sub class="calibre65">n</sub> | <em class="calibre13">R</em> (<em class="calibre13">x</em><sub class="calibre65">1</sub><em class="calibre13">x</em><sub class="calibre65">2</sub><em class="calibre13">x</em><sub class="calibre65">3</sub>) AND...}</p></blockquote>
<blockquote class="calibre45"><p class="calibre18">instead of:</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre21">{<em class="calibre13">x</em><sub class="calibre65">1</sub>, <em class="calibre13">x</em><sub class="calibre65">2</sub>, ..., <em class="calibre13">x</em><sub class="calibre65">n</sub> | <em class="calibre13">R</em> (<em class="calibre13">x</em><sub class="calibre65">1</sub>, <em class="calibre13">x</em><sub class="calibre65">2</sub>, <em class="calibre13">x</em><sub class="calibre65">3</sub>) AND...}</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><strong class="calibre6">2.</strong> An atom of the form <em class="calibre13">x</em><sub class="calibre65">i</sub><strong class="calibre6">op</strong>
<em class="calibre13">x</em><sub class="calibre65">j</sub>, where <strong class="calibre6">op</strong> is one of the comparison operators in the set {=, &lt;, ≤, &gt;, ≥, ≠}, and <em class="calibre13">x</em><sub class="calibre65">i</sub> and <em class="calibre13">x</em><sub class="calibre65">j</sub> are domain variables.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><strong class="calibre6">3.</strong> An atom of the form <em class="calibre13">x</em><sub class="calibre65">i</sub><strong class="calibre6">op</strong>
<em class="calibre13">c</em> or <em class="calibre13">c</em>
<strong class="calibre6">op</strong>
<em class="calibre13">x</em><sub class="calibre65">j</sub>, where <strong class="calibre6">op</strong> is one of the comparison operators in the set {=, &lt;, ≤, &gt;, ≥, ≠}, <em class="calibre13">x</em><sub class="calibre65">i</sub> and <em class="calibre13">x</em><sub class="calibre65">j</sub> are domain variables, and <em class="calibre13">c</em> is a constant value.</p></blockquote>
<p class="calibre18"><a id="filepos680144" class="calibre3"></a>As in tuple calculus, atoms evaluate to either TRUE or FALSE for a specific set of values, called the <strong class="calibre6">truth values</strong> of the atoms. In case 1, if the domain variables are assigned values corresponding to a tuple of the specified relation <em class="calibre13">R</em>, then the atom is TRUE. In cases 2 and 3, if the domain variables are assigned values that satisfy the condition, then the atom is TRUE.</p><div class="calibre31"> </div>
<p class="calibre18">In a similar way to the tuple relational calculus, formulas are made up of atoms, variables, and quantifiers, so we will not repeat the specifications for formulas here. Some examples of queries specified in the domain calculus follow. We will use lowercase letters <em class="calibre13">l</em>, <em class="calibre13">m</em>, <em class="calibre13">n</em>, ..., <em class="calibre13">x</em>, <em class="calibre13">y</em>, <em class="calibre13">z</em> for domain variables.</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><strong class="calibre6">Query 0.</strong> List the birth date and address of the employee whose name is ‘John B. Smith’.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">Q0:</strong> {<em class="calibre13">u</em>, <em class="calibre13">v</em> | (<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">q</em>) (<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">r</em>) (<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">s</em>) (<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">t</em>) (<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">w</em>) (<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">x</em>) (<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">y</em>) (<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">z</em>) (EMPLOYEE(<em class="calibre13">qrstuvwxyz</em>) <strong class="calibre6">AND</strong>
<em class="calibre13">q</em> =‘John’ <strong class="calibre6">AND</strong>
<em class="calibre13">r</em> =‘B’ <strong class="calibre6">AND</strong>
<em class="calibre13">s</em> =‘Smith’)}</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">We need ten variables for the EMPLOYEE relation, one to range over each of the domains of attributes of EMPLOYEE in order. Of the ten variables <em class="calibre13">q</em>, <em class="calibre13">r</em>, <em class="calibre13">s</em>, ..., <em class="calibre13">z</em>, only <em class="calibre13">u</em> and <em class="calibre13">v</em> are free, because they appear to the left of the bar and hence should not be bound to a quantifier. We first specify the <em class="calibre13">requested attributes</em>, Bdate and Address, by the free domain variables <em class="calibre13">u</em> for BDATE and <em class="calibre13">v</em> for ADDRESS. Then we specify the condition for selecting a tuple following the bar (|)—namely, that the sequence of values assigned to the variables <em class="calibre13">qrstuvwxyz</em> be a tuple of the EMPLOYEE relation and that the values for <em class="calibre13">q</em> (Fname), <em class="calibre13">r</em> (Minit), and <em class="calibre13">s</em> (Lname) be equal to ‘John’, ‘B’, and ‘Smith’, respectively. For convenience, we will quantify only those variables <em class="calibre13">actually appearing in a condition</em> (these would be <em class="calibre13">q</em>, <em class="calibre13">r</em>, and <em class="calibre13">s</em> in Q0) in the rest of our examples.<a id="filepos683015" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_123.html#filepos4353789" class="calibre41">14</a></sup></p><div class="calibre31"> </div>
<p class="calibre18">An alternative shorthand notation, used in QBE, for writing this query is to assign the constants ‘John’, ‘B’, and ‘Smith’ directly as shown in Q0A. Here, all variables not appearing to the left of the bar are implicitly existentially quantified:<a id="filepos683401" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_124.html#filepos4354213" class="calibre41">15</a></sup></p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre58"><strong class="calibre6">Q0A:</strong> {<em class="calibre13">u</em>, <em class="calibre13">v</em> | EMPLOYEE(‘John’,‘B’,‘Smith’, <em class="calibre13">t</em>, <em class="calibre13">u</em>, <em class="calibre13">v</em>, <em class="calibre13">w</em>, <em class="calibre13">x</em>, <em class="calibre13">y</em>, <em class="calibre13">z</em>) }</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><strong class="calibre6">Query 1.</strong> Retrieve the name and address of all employees who work for the ‘Research’ department.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">Q1:</strong> {<em class="calibre13">q</em>, <em class="calibre13">s</em>, <em class="calibre13">v</em> | (<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">z</em>) (<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">l</em>) (<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">m</em>) (EMPLOYEE(<em class="calibre13">qrstuvwxyz</em>) <strong class="calibre6">AND</strong> DEPARTMENT(<em class="calibre13">lmno</em>) <strong class="calibre6">AND</strong>
<em class="calibre13">l</em> =‘Research’ <strong class="calibre6">AND</strong>
<em class="calibre13">m=z</em>)}</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">A condition relating two domain variables that range over attributes from two relations, such as <em class="calibre13">m</em> = <em class="calibre13">z</em> in Q1, is a <strong class="calibre6">join condition</strong>, whereas a condition that relates a domain variable to a constant, such as <em class="calibre13">l</em> = ‘Research’, is a <strong class="calibre6">selection condition</strong>.</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><a id="filepos684861" class="calibre3"></a><strong class="calibre6">Query 2.</strong> For every project located in ‘Stafford’, list the project number, the controlling department number, and the department manager’s last name, birth date, and address.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">Q2:</strong> {<em class="calibre13">i</em>, <em class="calibre13">k</em>, <em class="calibre13">s</em>, <em class="calibre13">u</em>, <em class="calibre13">v</em> | (<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">j</em>)(<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">m</em>)(<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">n</em>)(<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">t</em>)(PROJECT(<em class="calibre13">hijk</em>) <strong class="calibre6">AND</strong> EMPLOYEE(<em class="calibre13">qrstuvwxyz</em>) <strong class="calibre6">AND</strong> DEPARTMENT(<em class="calibre13">lmno</em>) <strong class="calibre6">AND</strong>
<em class="calibre13">k</em>=<em class="calibre13">m</em>
<strong class="calibre6">AND</strong>
<em class="calibre13">n</em>=<em class="calibre13">t</em><strong class="calibre6">AND</strong>
<em class="calibre13">j</em>=‘Stafford’)}</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><strong class="calibre6">Query 6.</strong> List the names of employees who have no dependents.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">Q6:</strong> {<em class="calibre13">q</em>, <em class="calibre13">s</em> | (<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">t</em>)(EMPLOYEE(<em class="calibre13">qrstuvwxyz</em>) <strong class="calibre6">AND</strong> (<strong class="calibre6">NOT</strong>(<img alt="image" src="../images/00147.jpg" class="calibre16"/><em class="calibre13">l</em>)(DEPENDENT(<em class="calibre13">lmnop</em>) <strong class="calibre6">AND</strong>
<em class="calibre13">t=l</em>)))}</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">Q6 can be restated using universal quantifiers instead of the existential quantifiers, as shown in Q6A:</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">Q6A:</strong> {<em class="calibre13">q</em>, <em class="calibre13">s</em> | (<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">t</em>)(EMPLOYEE(<em class="calibre13">qrstuvwxyz</em>) <strong class="calibre6">AND</strong> ((<img alt="image" src="../images/00147.jpg" class="calibre16"/><em class="calibre13">l</em>)(<strong class="calibre6">NOT</strong>(DEPENDENT(<em class="calibre13">lmnop</em>)) <strong class="calibre6">OR NOT</strong> (<em class="calibre13">t=l</em>))))}</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><strong class="calibre6">Query 7.</strong> List the names of managers who have at least one dependent.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">Q7:</strong> {<em class="calibre13">s</em>, <em class="calibre13">q</em> | (<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">t</em>)(<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">j</em>)(<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">l</em>)(EMPLOYEE(<em class="calibre13">qrstuvwxyz</em>) <strong class="calibre6">AND</strong> DEPARTMENT(<em class="calibre13">hijk</em>) <strong class="calibre6">AND</strong> DEPENDENT(<em class="calibre13">lmnop</em>) <strong class="calibre6">AND</strong>
<em class="calibre13">t=j</em>
<strong class="calibre6">AND</strong>
<em class="calibre13">l=t</em>)}</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">As we mentioned earlier, it can be shown that any query that can be expressed in the basic relational algebra can also be expressed in the domain or tuple relational calculus. Also, any <em class="calibre13">safe expression</em> in the domain or tuple relational calculus can be expressed in the basic relational algebra.</p><div class="calibre31"> </div>
<p class="calibre18">The QBE language was based on the domain relational calculus, although this was realized later, after the domain calculus was formalized. QBE was one of the first graphical query languages with minimum syntax developed for database systems. It was developed at IBM Research and is available as an IBM commercial product as part of the Query Management Facility (QMF) interface option to DB2. The basic ideas used in QBE have been applied in several other commercial products. Because of its important place in the history of relational languages, we have included an overview of QBE in Appendix C.</p><div class="calibre31"> </div>
<h4 id="filepos688510" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">6.8 Summary</span></span></blockquote></h4><div class="calibre31"> </div>
<p class="calibre18">In this chapter we presented two formal languages for the relational model of data. They are used to manipulate relations and produce new relations as answers to queries. We discussed the relational algebra and its operations, which are used to specify a sequence of operations to specify a query. Then we introduced two types of relational calculi called tuple calculus and domain calculus.</p><div class="calibre31"> </div>
<p class="calibre18">In Sections 6.1 through 6.3, we introduced the basic relational algebra operations and illustrated the types of queries for which each is used. First, we discussed the unary relational operators SELECT and PROJECT, as well as the RENAME operation. Then, we discussed binary set theoretic operations requiring that relations on which they <a class="calibre3"></a>are applied be union (or type) compatible; these include UNION, INTERSECTION, and SET DIFFERENCE. The CARTESIAN PRODUCT operation is a set operation that can be used to combine tuples from two relations, producing all possible combinations. It is rarely used in practice; however, we showed how CARTESIAN PRODUCT followed by SELECT can be used to define matching tuples from two relations and leads to the JOIN operation. Different JOIN operations called THETA JOIN, EQUIJOIN, and NATURAL JOIN were introduced. Query trees were introduced as a graphical representation of relational algebra queries, which can also be used as the basis for internal data structures that the DBMS can use to represent a query.</p><div class="calibre31"> </div>
<p class="calibre18">We discussed some important types of queries that <em class="calibre13">cannot</em> be stated with the basic relational algebra operations but are important for practical situations. We introduced GENERALIZED PROJECTION to use functions of attributes in the projection list and the AGGREGATE FUNCTION operation to deal with aggregate types of statistical requests that summarize the information in the tables. We discussed recursive queries, for which there is no direct support in the algebra but which can be handled in a step-by-step approach, as we demonstrated. Then we presented the OUTER JOIN and OUTER UNION operations, which extend JOIN and UNION and allow all information in source relations to be preserved in the result.</p><div class="calibre31"> </div>
<p class="calibre18">The last two sections described the basic concepts behind relational calculus, which is based on the branch of mathematical logic called predicate calculus. There are two types of relational calculi: (1) the tuple relational calculus, which uses tuple variables that range over tuples (rows) of relations, and (2) the domain relational calculus, which uses domain variables that range over domains (columns of relations). In relational calculus, a query is specified in a single declarative statement, without specifying any order or method for retrieving the query result. Hence, relational calculus is often considered to be a higher-level <em class="calibre13">declarative</em> language than the relational algebra, because a relational calculus expression states <em class="calibre13">what</em> we want to retrieve regardless of <em class="calibre13">how</em> the query may be executed.</p><div class="calibre31"> </div>
<p class="calibre18">We discussed the syntax of relational calculus queries using both tuple and domain variables. We introduced query graphs as an internal representation for queries in relational calculus. We also discussed the existential quantifier (<img alt="image" src="../images/00143.jpg" class="calibre16"/>) and the universal quantifier (<img alt="image" src="../images/00145.jpg" class="calibre16"/>). We saw that relational calculus variables are bound by these quantifiers. We described in detail how queries with universal quantification are written, and we discussed the problem of specifying safe queries whose results are finite. We also discussed rules for transforming universal into existential quantifiers, and vice versa. It is the quantifiers that give expressive power to the relational calculus, making it equivalent to the basic relational algebra. There is no analog to grouping and aggregation functions in basic relational calculus, although some extensions have been suggested.</p><div class="calibre31"> </div>
<h4 id="filepos692880" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">Review Questions</span></span></blockquote></h4><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.1.</strong> List the operations of relational algebra and the purpose of each.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><a class="calibre3"></a><strong class="calibre6">6.2.</strong> What is union compatibility? Why do the UNION, INTERSECTION, and DIFFERENCE operations require that the relations on which they are applied be union compatible?</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.3.</strong> Discuss some types of queries for which renaming of attributes is necessary in order to specify the query unambiguously.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.4.</strong> Discuss the various types of <em class="calibre13">inner join</em> operations. Why is theta join required?</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.5.</strong> What role does the concept of <em class="calibre13">foreign key</em> play when specifying the most common types of meaningful join operations?</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.6.</strong> What is the FUNCTION operation? What is it used for?</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.7.</strong> How are the OUTER JOIN operations different from the INNER JOIN operations? How is the OUTER UNION operation different from UNION?</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.8.</strong> In what sense does relational calculus differ from relational algebra, and in what sense are they similar?</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.9.</strong> How does tuple relational calculus differ from domain relational calculus?</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.10.</strong> Discuss the meanings of the existential quantifier (<img alt="image" src="../images/00143.jpg" class="calibre16"/>) and the universal quantifier (<img alt="image" src="../images/00145.jpg" class="calibre16"/>).</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.11.</strong> Define the following terms with respect to the tuple calculus: <em class="calibre13">tuple variable</em>, <em class="calibre13">range relation</em>, <em class="calibre13">atom</em>, <em class="calibre13">formula</em>, and <em class="calibre13">expression</em>.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.12.</strong> Define the following terms with respect to the domain calculus: <em class="calibre13">domain variable</em>, <em class="calibre13">range relation</em>, <em class="calibre13">atom</em>, <em class="calibre13">formula</em>, and <em class="calibre13">expression</em>.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.13.</strong> What is meant by a <em class="calibre13">safe expression</em> in relational calculus?</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.14.</strong> When is a query language called relationally complete?</p></blockquote><div class="calibre31"> </div>
<h4 id="filepos696065" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">Exercises</span></span></blockquote></h4><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.15.</strong> Show the result of each of the sample queries in Section 6.5 as it would apply to the database state in <a href="dummy_split_018.html#filepos314167" class="calibre41">Figure 3.6</a>.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.16.</strong> Specify the following queries on the COMPANYrelational database schema shown in Figure 5.5, using the relational operators discussed in this chapter. Also show the result of each query as it would apply to the database state in <a href="dummy_split_018.html#filepos314167" class="calibre41">Figure 3.6</a>.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40">a. Retrieve the names of all employees in department 5 who work more than 10 hours per week on the ProductX project.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">b. List the names of all employees who have a dependent with the same first name as themselves.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">c. Find the names of all employees who are directly supervised by ‘Franklin Wong’.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">d. For each project, list the project name and the total hours per week (by all employees) spent on that project.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><a class="calibre3"></a>e. Retrieve the names of all employees who work on every project.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">f. Retrieve the names of all employees who do not work on any project.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">g. For each department, retrieve the department name and the average salary of all employees working in that department.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">h. Retrieve the average salary of all female employees.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">i. Find the names and addresses of all employees who work on at least one project located in Houston but whose department has no location in Houston.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">j. List the last names of all department managers who have no dependents.</p></blockquote>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.17.</strong> Consider the AIRLINE relational database schema shown in <a href="dummy_split_018.html#filepos350401" class="calibre41">Figure 3.8</a>, which was described in Exercise 3.12. Specify the following queries in relational algebra:</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40">a. For each flight, list the flight number, the departure airport for the first leg of the flight, and the arrival airport for the last leg of the flight.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">b. List the flight numbers and weekdays of all flights or flight legs that depart from Houston Intercontinental Airport (airport code ‘IAH’) and arrive in Los Angeles International Airport (airport code ‘LAX’).</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">c. List the flight number, departure airport code, scheduled departure time, arrival airport code, scheduled arrival time, and weekdays of all flights or flight legs that depart from some airport in the city of Houston and arrive at some airport in the city of Los Angeles.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">d. List all fare information for flight number ‘CO197’.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">e. Retrieve the number of available seats for flight number ‘CO197’ on ‘2009-10-09’.</p></blockquote>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.18.</strong> Consider the LIBRARY relational database schema shown in <a href="#filepos701663" class="calibre41">Figure 6.14</a>, which is used to keep track of books, borrowers, and book loans. Referential integrity constraints are shown as directed arcs in <a href="#filepos701663" class="calibre41">Figure 6.14</a>, as in the notation of <a href="dummy_split_018.html#filepos323245" class="calibre41">Figure 3.7</a>. Write down relational expressions for the following queries:</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40">a. How many copies of the book titled <em class="calibre13">The Lost Tribe</em> are owned by the library branch whose name is ‘Sharpstown’?</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">b. How many copies of the book titled <em class="calibre13">The Lost Tribe</em> are owned by each library branch?</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">c. Retrieve the names of all borrowers who do not have any books checked out.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">d. For each book that is loaned out from the Sharpstown branch and whose Due_date is today, retrieve the book title, the borrower’s name, and the borrower’s address.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">e. For each library branch, retrieve the branch name and the total number of books loaned out from that branch.</p></blockquote>
<p id="filepos701663" class="calibre7"><a class="calibre3"></a><img alt="image" src="../images/00148.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 6.14</strong><br class="calibre1"/>A relational database schema for a LIBRARY database.</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40">f. Retrieve the names, addresses, and number of books checked out for all borrowers who have more than five books checked out.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">g. For each book authored (or coauthored) by Stephen King, retrieve the title and the number of copies owned by the library branch whose name is Central.</p></blockquote>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.19.</strong> Specify the following queries in relational algebra on the database schema given in Exercise 3.14:</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40">a. List the Order# and Ship_date for all orders shipped from Warehouse# W2.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">b. List the WAREHOUSE information from which the CUSTOMER named Jose Lopez was supplied his orders. Produce a listing: Order#, Warehouse#.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><a class="calibre3"></a>c. Produce a listing Cname, No_of_orders, Avg_order_amt, where the middle column is the total number of orders by the customer and the last column is the average order amount for that customer.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">d. List the orders that were not shipped within 30 days of ordering.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">e. List the Order# for orders that were shipped from <em class="calibre13">all</em> warehouses that the company has in New York.</p></blockquote>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.20.</strong> Specify the following queries in relational algebra on the database schema given in Exercise 3.15: a. Give the details (all attributes of trip relation) for trips that exceeded $2,000 in expenses.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40">b. Print the Ssns of salespeople who took trips to Honolulu.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">c. Print the total trip expenses incurred by the salesperson with SSN = ‘234-56-7890’.</p></blockquote>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.21.</strong> Specify the following queries in relational algebra on the database schema given in Exercise 3.16:</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40">a. List the number of courses taken by all students named John Smith in Winter 2009 (i.e., Quarter=W09).</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">b. Produce a list of textbooks (include Course#, Book_isbn, Book_title) for courses offered by the ‘CS’ department that have used more than two books.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">c. List any department that has all its adopted books published by ‘Pearson Publishing’.</p></blockquote>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.22.</strong> Consider the two tables <em class="calibre13">T</em>1 and <em class="calibre13">T</em>2 shown in <a href="#filepos705252" class="calibre41">Figure 6.15</a>. Show the results of the following operations:</p></blockquote><div class="calibre31"> </div>
<p id="filepos705252" class="calibre7"><img alt="image" src="../images/00149.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 6.15</strong><br class="calibre1"/>A database state for the relations T1 and T 2.</p><div class="calibre31"> </div>
<p class="calibre7"><img alt="image" src="../images/00150.jpg" class="calibre16"/></p>
<blockquote class="calibre30"><p class="calibre63"><a class="calibre3"></a><strong class="calibre6">6.23.</strong> Specify the following queries in relational algebra on the database schema in Exercise 3.17:</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40">a. For the salesperson named ‘Jane Doe’, list the following information for all the cars she sold: Serial#, Manufacturer, Sale_price.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">b. List the Serial# and Model of cars that have no options.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">c. Consider the NATURAL JOIN operation between SALESPERSON and SALE. What is the meaning of a left outer join for these tables (do not change the order of relations)? Explain with an example.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">d. Write a query in relational algebra involving selection and one set operation and say in words what the query does.</p></blockquote>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.24.</strong> Specify queries a, b, c, e, f, i, and j of Exercise 6.16 in both tuple and domain relational calculus.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.25.</strong> Specify queries a, b, c, and d of Exercise 6.17 in both tuple and domain relational calculus.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.26.</strong> Specify queries c, d, and f of Exercise 6.18 in both tuple and domain relational calculus.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.27.</strong> In a tuple relational calculus query with <em class="calibre13">n</em> tuple variables, what would be the typical minimum number of join conditions? Why? What is the effect of having a smaller number of join conditions?</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.28.</strong> Rewrite the domain relational calculus queries that followed Q0 in Section 6.7 in the style of the abbreviated notation of Q0A, where the objective is to minimize the number of domain variables by writing constants in place of variables wherever possible.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.29.</strong> Consider this query: Retrieve the Ssns of employees who work on at least those projects on which the employee with Ssn=123456789 works. This may be stated as (<strong class="calibre6">FORALL</strong><em class="calibre13">x</em>) (<strong class="calibre6">IF</strong><em class="calibre13">P</em>
<strong class="calibre6">THEN</strong>
<em class="calibre13">Q</em>), where</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre61"><img alt="image" src="../images/00003.jpg" class="calibre16"/><em class="calibre13">x</em> is a tuple variable that ranges over the PROJECT relation.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre61"><img alt="image" src="../images/00003.jpg" class="calibre16"/><em class="calibre13">P</em> ≡ EMPLOYEE with Ssn=123456789 works on PROJECT <em class="calibre13">x</em>.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre61"><img alt="image" src="../images/00003.jpg" class="calibre16"/><em class="calibre13">Q</em> ≡ EMPLOYEE <em class="calibre13">e</em> works on PROJECT <em class="calibre13">x</em>.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre61">Express the query in tuple relational calculus, using the rules</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre61"><img alt="image" src="../images/00003.jpg" class="calibre16"/>(<img alt="image" src="../images/00147.jpg" class="calibre16"/><em class="calibre13">x</em>)(<em class="calibre13">P</em>(<em class="calibre13">x</em>)) ≡ <strong class="calibre6">NOT</strong> (<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">x</em>)(<strong class="calibre6">NOT</strong>(<em class="calibre13">P</em>(<em class="calibre13">x</em>))).</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre61"><img alt="image" src="../images/00003.jpg" class="calibre16"/>(<strong class="calibre6">IF</strong><em class="calibre13">P</em>
<strong class="calibre6">THEN</strong>
<em class="calibre13">Q</em>) ≡ (<strong class="calibre6">NOT</strong>(<em class="calibre13">P</em>) <strong class="calibre6">OR</strong>
<em class="calibre13">Q</em>).</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.30.</strong> Show how you can specify the following relational algebra operations in both tuple and domain relational calculus.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40">a.σ<sub class="calibre65"><em class="calibre13">A</em> = <em class="calibre13">C</em></sub>(<em class="calibre13">R</em>(<em class="calibre13">A</em>, <em class="calibre13">B</em>, <em class="calibre13">C</em>))</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">b.π<sub class="calibre65">&lt; <em class="calibre13">A</em>, <em class="calibre13">B</em>&gt;</sub>(<em class="calibre13">R</em>(<em class="calibre13">A</em>, <em class="calibre13">B</em>, <em class="calibre13">C</em>))</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">c. <em class="calibre13">R</em> (<em class="calibre13">A</em>, <em class="calibre13">B</em>, <em class="calibre13">C</em>) * <em class="calibre13">S</em> (<em class="calibre13">C</em>, <em class="calibre13">D</em>, <em class="calibre13">E</em>)</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">d. <em class="calibre13">R</em> (<em class="calibre13">A</em>, <em class="calibre13">B</em>, <em class="calibre13">C</em>) <img alt="image" src="../images/00024.jpg" class="calibre16"/><em class="calibre13">S</em> (<em class="calibre13">A</em>, <em class="calibre13">B</em>, <em class="calibre13">C</em>)</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">e. <em class="calibre13">R</em> (<em class="calibre13">A</em>, <em class="calibre13">B</em>, <em class="calibre13">C</em>) <img alt="image" src="../images/00119.jpg" class="calibre16"/><em class="calibre13">S</em> (<em class="calibre13">A</em>, <em class="calibre13">B</em>, <em class="calibre13">C</em>)</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><a class="calibre3"></a>f.<em class="calibre13">R</em> (<em class="calibre13">A</em>, <em class="calibre13">B</em>, <em class="calibre13">C</em>) = <em class="calibre13">S</em>(<em class="calibre13">A</em>, <em class="calibre13">B</em>, <em class="calibre13">C</em>)</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">g.<em class="calibre13">R</em> (<em class="calibre13">A</em>, <em class="calibre13">B</em>, <em class="calibre13">C</em>) × <em class="calibre13">S</em> (<em class="calibre13">D</em>, <em class="calibre13">E</em>, <em class="calibre13">F</em>)</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">h.<em class="calibre13">R</em> (<em class="calibre13">A</em>, <em class="calibre13">B</em>) ÷ <em class="calibre13">S</em> (<em class="calibre13">A</em>)</p></blockquote>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.31.</strong> Suggest extensions to the relational calculus so that it may express the following types of operations that were discussed in Section 6.4: (a) aggregate functions and grouping; (b) OUTER JOIN operations; (c) recursive closure queries.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.32.</strong> A nested query is a query within a query. More specifically, a nested query is a parenthesized query whose result can be used as a value in a number of places, such as instead of a relation. Specify the following queries on the database specified in <a href="dummy_split_018.html#filepos312087" class="calibre41">Figure 3.5</a> using the concept of nested queries and the relational operators discussed in this chapter. Also show the result of each query as it would apply to the database state in <a href="dummy_split_018.html#filepos314167" class="calibre41">Figure 3.6</a>.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40">a. List the names of all employees who work in the department that has the employee with the highest salary among all employees.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">b. List the names of all employees whose supervisor’s supervisor has ‘888665555’ for Ssn.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">c. List the names of employees who make at least $10,000 more than the employee who is paid the least in the company.</p></blockquote>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.33.</strong> State whether the following conclusions are true or false:</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40">a. <strong class="calibre6">NOT</strong> (<em class="calibre13">P</em>(<em class="calibre13">x</em>) <strong class="calibre6">OR</strong>
<em class="calibre13">Q</em>(<em class="calibre13">x</em>)) → (<strong class="calibre6">NOT</strong> (<em class="calibre13">P</em>(<em class="calibre13">x</em>)) <strong class="calibre6">AND</strong> (<strong class="calibre6">NOT</strong> (<em class="calibre13">Q</em>(<em class="calibre13">x</em>)))</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">b. <strong class="calibre6">NOT</strong> (<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">x</em>) (<em class="calibre13">P</em>(<em class="calibre13">x</em>)) → <img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">x</em> (<strong class="calibre6">NOT</strong> (<em class="calibre13">P</em>(<em class="calibre13">x</em>))</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">c. (<img alt="image" src="../images/00146.jpg" class="calibre16"/><em class="calibre13">x</em>) (<em class="calibre13">P</em>(<em class="calibre13">x</em>)) → <img alt="image" src="../images/00147.jpg" class="calibre16"/><em class="calibre13">x</em> ((<em class="calibre13">P</em>(<em class="calibre13">x</em>))</p></blockquote>
<h4 id="filepos713862" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">Laboratory Exercises</span></span></blockquote></h4><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.34.</strong> Specify and execute the following queries in relational algebra (RA) using the RA interpreter on the COMPANY database schema in <a href="dummy_split_018.html#filepos312087" class="calibre41">Figure 3.5</a>.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40">a. List the names of all employees in department 5 who work more than 10 hours per week on the ProductX project.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">b. List the names of all employees who have a dependent with the same first name as themselves.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">c. List the names of employees who are directly supervised by Franklin Wong.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">d. List the names of employees who work on every project.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">e. List the names of employees who do not work on any project.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">f. List the names and addresses of employees who work on at least one project located in Houston but whose department has no location in Houston.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">g. List the names of department managers who have no dependents.</p></blockquote>
<blockquote class="calibre30"><p class="calibre63"><a class="calibre3"></a><strong class="calibre6">6.35.</strong> Consider the following MAILORDER relational schema describing the data for a mail order company.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00151.jpg" class="calibre16"/></p></blockquote>
<blockquote class="calibre45"><p class="calibre18">Qoh stands for <em class="calibre13">quantity on hand</em>: the other attribute names are self-explanatory. Specify and execute the following queries using the RA interpreter on the MAILORDER database schema.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40">a. Retrieve the names of parts that cost less than $20.00.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">b. Retrieve the names and cities of employees who have taken orders for parts costing more than $50.00.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">c. Retrieve the pairs of customer number values of customers who live in the same ZIP Code.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">d. Retrieve the names of customers who have ordered parts from employees living in Wichita.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">e. Retrieve the names of customers who have ordered parts costing less than $20.00.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">f. Retrieve the names of customers who have not placed an order.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">g. Retrieve the names of customers who have placed exactly two orders.</p></blockquote>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.36.</strong> Consider the following GRADEBOOK relational schema describing the data for a grade book of a particular instructor. (<em class="calibre13">Note</em>: The attributes A, B, C, and D of COURSES store grade cutoffs.)</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00152.jpg" class="calibre16"/></p></blockquote>
<blockquote class="calibre45"><p class="calibre18">Specify and execute the following queries using the RA interpreter on the GRADEBOOK database schema.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40">a. Retrieve the names of students enrolled in the Automata class during the fall 2009 term.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">b. Retrieve the Sid values of students who have enrolled in CSc226 and CSc227.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">c. Retrieve the Sid values of students who have enrolled in CSc226 or CSc227.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">d. Retrieve the names of students who have not enrolled in any class.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">e. Retrieve the names of students who have enrolled in all courses in the CATALOG table.</p></blockquote>
<blockquote class="calibre30"><p class="calibre63"><a id="filepos718717" class="calibre3"></a><strong class="calibre6">6.37.</strong> Consider a database that consists of the following relations.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40">SUPPLIER(<span><span class="underline">Sno</span></span>, Sname)</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">PART(<span><span class="underline">Pno</span></span>, Pname)</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">PROJECT(<span><span class="underline">Jno</span></span>, Jname)</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">SUPPLY(<span><span class="underline">Sno</span></span>, <span><span class="underline">Pno</span></span>, <span><span class="underline">Jno</span></span>)</p></blockquote>
<blockquote class="calibre45"><p class="calibre18">The database records information about suppliers, parts, and projects and includes a ternary relationship between suppliers, parts, and projects. This relationship is a many-many-many relationship. Specify and execute the following queries using the RA interpreter.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40">a. Retrieve the part numbers that are supplied to exactly two projects.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">b. Retrieve the names of suppliers who supply more than two parts to project ‘J1’.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">c. Retrieve the part numbers that are supplied by every supplier.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">d. Retrieve the project names that are supplied by supplier ‘S1’ only.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">e. Retrieve the names of suppliers who supply at least two different parts each to at least two different projects.</p></blockquote>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.38.</strong> Specify and execute the following queries for the database in Exercise 3.16 using the RA interpreter.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40">a. Retrieve the names of students who have enrolled in a course that uses a textbook published by Addison-Wesley.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">b. Retrieve the names of courses in which the textbook has been changed at least once.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">c. Retrieve the names of departments that adopt textbooks published by Addison-Wesley only.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">d. Retrieve the names of departments that adopt textbooks written by Navathe and published by Addison-Wesley.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">e. Retrieve the names of students who have never used a book (in a course) written by Navathe and published by Addison-Wesley.</p></blockquote>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">6.39.</strong> Repeat Laboratory Exercises 6.34 through 6.38 in domain relational calculus (DRC) by using the DRC interpreter.</p></blockquote><div class="calibre31"> </div>
<h4 id="filepos721943" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">Selected Bibliography</span></span></blockquote></h4><div class="calibre31"> </div>
<p class="calibre18">Codd (1970) defined the basic relational algebra. Date (1983a) discusses outer joins. Work on extending relational operations is discussed by Carlis (1986) and Ozsoyoglu et al. (1985). Cammarata et al. (1989) extends the relational model integrity constraints and joins.</p><div class="calibre31"> </div>
<p class="calibre18">Codd (1971) introduced the language Alpha, which is based on concepts of tuple relational calculus. Alpha also includes the notion of aggregate functions, which goes beyond relational calculus. The original formal definition of relational calculus <a class="calibre3"></a>was given by Codd (1972), which also provided an algorithm that transforms any tuple relational calculus expression to relational algebra. The QUEL (Stonebraker et al. 1976) is based on tuple relational calculus, with implicit existential quantifiers, but no universal quantifiers, and was implemented in the INGRES system as a commercially available language. Codd defined relational completeness of a query language to mean at least as powerful as relational calculus. Ullman (1988) describes a formal proof of the equivalence of relational algebra with the safe expressions of tuple and domain relational calculus. Abiteboul et al. (1995) and Atzeni and deAntonellis (1993) give a detailed treatment of formal relational languages.</p><div class="calibre31"> </div>
<p class="calibre18">Although ideas of domain relational calculus were initially proposed in the QBE language (Zloof 1975), the concept was formally defined by Lacroix and Pirotte (1977a). The experimental version of the Query-By-Example system is described in Zloof (1975). The ILL (Lacroix and Pirotte 1977b) is based on domain relational calculus. Whang et al. (1990) extends QBE with universal quantifiers. Visual query languages, of which QBE is an example, are being proposed as a means of querying databases; conferences such as the Visual Database Systems Working Conference (e.g., Arisawa and Catarci (2000) or Zhou and Pu (2002)) have a number of proposals for such languages.</p><div class="calibre31"> </div>  <div class="mbppagebreak" id="calibre_pb_29"></div></body>
</html>
