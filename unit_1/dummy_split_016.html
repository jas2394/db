<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
	<title>Fundamentals of Database Systems</title>
	<meta content="http://www.w3.org/1999/xhtml; charset=utf-8" http-equiv="Content-Type"/><link href="../stylesheet.css" type="text/css" rel="stylesheet"/><style type="text/css">
		@page { margin-bottom: 5.000000pt; margin-top: 5.000000pt; }</style></head>
  <body class="calibre">
<h3 id="filepos180230" class="calibre55"><span class="calibre47"><span class="bold"><a id="filepos180304" class="calibre35"></a>chapter 2<br class="calibre54"/><br class="calibre54"/>Database System Concepts and Architecture</span></span></h3><div class="calibre56"> </div>
<p class="calibre37">The architecture of DBMS packages has evolved from the early monolithic systems, where the whole DBMS software package was one tightly integrated system, to the modern DBMS packages that are modular in design, with a client/server system architecture. This evolution mirrors the trends in computing, where large centralized mainframe computers are being replaced by hundreds of distributed workstations and personal computers connected via communications networks to various types of server machines—Web servers, database servers, file servers, application servers, and so on.</p>
<p class="calibre18">In a basic client/server DBMS architecture, the system functionality is distributed between two types of modules.<a id="filepos181192" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_064.html#filepos4337217" class="calibre41">1</a></sup> A <strong class="calibre6">client module</strong> is typically designed so that it will run on a user workstation or personal computer. Typically, application programs and user interfaces that access the database run in the client module. Hence, the client module handles user interaction and provides the user-friendly interfaces such as forms- or menu-based GUIs (graphical user interfaces). The other kind of module, called a <strong class="calibre6">server module</strong>, typically handles data storage, access, search, and other functions. We discuss client/server architectures in more detail in Section 2.5. First, we must study more basic concepts that will give us a better understanding of modern database architectures.</p><div class="calibre31"> </div>
<p class="calibre18">In this chapter we present the terminology and basic concepts that will be used throughout the book. Section 2.1 discusses data models and defines the concepts of schemas and instances, which are fundamental to the study of database systems. Then, we discuss the three-schema DBMS architecture and data independence in Section 2.2; this provides a user’s perspective on what a DBMS is supposed to do. In Section 2.3 we describe the types of interfaces and languages that are typically provided by a DBMS. Section 2.4 discusses the database system software environment.</p><div class="calibre31"> </div>
<p class="calibre18"><a id="filepos182625" class="calibre3"></a>Section 2.5 gives an overview of various types of client/server architectures. Finally, Section 2.6 presents a classification of the types of DBMS packages. Section 2.7 summarizes the chapter.</p><div class="calibre31"> </div>
<p class="calibre18">The material in Sections 2.4 through 2.6 provides more detailed concepts that may be considered as supplementary to the basic introductory material.</p><div class="calibre31"> </div>
<h4 id="filepos183058" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">2.1 Data Models, Schemas, and Instances</span></span></blockquote></h4><div class="calibre31"> </div>
<p class="calibre18">One fundamental characteristic of the database approach is that it provides some level of data abstraction. <strong class="calibre6">Data abstraction</strong> generally refers to the suppression of details of data organization and storage, and the highlighting of the essential features for an improved understanding of data. One of the main characteristics of the database approach is to support data abstraction so that different users can perceive data at their preferred level of detail. A <strong class="calibre6">data model</strong>—a collection of concepts that can be used to describe the structure of a database—provides the necessary means to achieve this abstraction.<a id="filepos183919" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_065.html#filepos4337461" class="calibre41">2</a></sup> By <em class="calibre13">structure of a database</em> we mean the data types, relationships, and constraints that apply to the data. Most data models also include a set of <strong class="calibre6">basic operations</strong> for specifying retrievals and updates on the database.</p><div class="calibre31"> </div>
<p class="calibre18">In addition to the basic operations provided by the data model, it is becoming more common to include concepts in the data model to specify the <strong class="calibre6">dynamic aspect</strong> or <strong class="calibre6">behavior</strong> of a database application. This allows the database designer to specify a set of valid user-defined operations that are allowed on the database objects.<a id="filepos184622" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_066.html#filepos4337777" class="calibre41">3</a></sup> An example of a user-defined operation could be COMPUTE_GPA, which can be applied to a STUDENT object. On the other hand, generic operations to insert, delete, modify, or retrieve any kind of object are often included in the <em class="calibre13">basic data model operations</em>. Concepts to specify behavior are fundamental to object-oriented data models (see <a href="dummy_split_028.html#filepos1161565" class="calibre41">Chapter 11</a>) but are also being incorporated in more traditional data models. For example, object-relational models (see <a href="dummy_split_028.html#filepos1161565" class="calibre41">Chapter 11</a>) extend the basic relational model to include such concepts, among others. In the basic relational data model, there is a provision to attach behavior to the relations in the form of persistent stored modules, popularly known as stored procedures (see <a href="dummy_split_031.html#filepos1417305" class="calibre41">Chapter 13</a>).</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">2.1.1 Categories of Data Models</span></span></blockquote></h5>
<p class="calibre18">Many data models have been proposed, which we can categorize according to the types of concepts they use to describe the database structure. <strong class="calibre6">High-level</strong> or <strong class="calibre6">conceptual data models</strong> provide concepts that are close to the way many users perceive data, whereas <strong class="calibre6">low-level</strong> or <strong class="calibre6">physical data models</strong> provide concepts that describe the details of how data is stored on the computer storage media, typically <a id="filepos186178" class="calibre3"></a>magnetic disks. Concepts provided by low-level data models are generally meant for computer specialists, not for end users. Between these two extremes is a class of <strong class="calibre6">representational</strong> (or <strong class="calibre6">implementation</strong>) <strong class="calibre6">data models</strong>,<a id="filepos186450" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_067.html#filepos4338153" class="calibre41">4</a></sup> which provide concepts that may be easily understood by end users but that are not too far removed from the way data is organized in computer storage. Representational data models hide many details of data storage on disk but can be implemented on a computer system directly.</p><div class="calibre31"> </div>
<p class="calibre18">Conceptual data models use concepts such as entities, attributes, and relationships. An <strong class="calibre6">entity</strong> represents a real-world object or concept, such as an employee or a project from the miniworld that is described in the database. An <strong class="calibre6">attribute</strong> represents some property of interest that further describes an entity, such as the employee’s name or salary. A <strong class="calibre6">relationship</strong> among two or more entities represents an association among the entities, for example, a works-on relationship between an employee and a project. <a href="dummy_split_023.html#filepos724415" class="calibre41">Chapter 7</a> presents the <strong class="calibre6">Entity-Relationship model</strong>—a popular high-level conceptual data model. <a href="dummy_split_024.html#filepos851508" class="calibre41">Chapter 8</a> describes additional abstractions used for advanced modeling, such as generalization, specialization, and categories (union types).</p><div class="calibre31"> </div>
<p class="calibre18">Representational or implementation data models are the models used most frequently in traditional commercial DBMSs. These include the widely used <strong class="calibre6">relational data model</strong>, as well as the so-called legacy data models—the <strong class="calibre6">network</strong> and <strong class="calibre6">hierarchical models</strong>—that have been widely used in the past. <a href="dummy_split_017.html#filepos266356" class="calibre41">Part 2</a> is devoted to the relational data model, and its constraints, operations and languages.<a id="filepos188235" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_068.html#filepos4338443" class="calibre41">5</a></sup> The SQL standard for relational databases is described in <a href="dummy_split_019.html#filepos362078" class="calibre41">Chapters 4</a> and <a href="dummy_split_020.html#filepos448575" class="calibre41">5</a>. Representational data models represent data by using record structures and hence are sometimes called <strong class="calibre6">record-based data models</strong>.</p><div class="calibre31"> </div>
<p class="calibre18">We can regard the <strong class="calibre6">object data model</strong> as an example of a new family of higher-level implementation data models that are closer to conceptual data models. A standard for object databases called the ODMG object model has been proposed by the Object Data Management Group (ODMG). We describe the general characteristics of object databases and the object model proposed standard in <a href="dummy_split_028.html#filepos1161565" class="calibre41">Chapter 11</a>. Object data models are also frequently utilized as high-level conceptual models, particularly in the software engineering domain.</p><div class="calibre31"> </div>
<p class="calibre18">Physical data models describe how data is stored as files in the computer by representing information such as record formats, record orderings, and access paths. An <strong class="calibre6">access path</strong> is a structure that makes the search for particular database records efficient. We discuss physical storage techniques and access structures in <a href="dummy_split_037.html#filepos1840823" class="calibre41">Chapters 17</a> and <a href="dummy_split_038.html#filepos1998996" class="calibre41">18</a>. An <strong class="calibre6">index</strong> is an example of an access path that allows direct access to data using an index term or a keyword. It is similar to the index at the end of this book, except that it may be organized in a linear, hierarchical (tree-structured), or some other fashion.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1"><a id="filepos190034" class="calibre3"></a>2.1.2 Schemas, Instances, and Database State</span></span></blockquote></h5>
<p class="calibre18">In any data model, it is important to distinguish between the <em class="calibre13">description</em> of the database and the <em class="calibre13">database itself</em>. The description of a database is called the <strong class="calibre6">database schema</strong>, which is specified during database design and is not expected to change frequently.<a id="filepos190461" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_069.html#filepos4338714" class="calibre41">6</a></sup> Most data models have certain conventions for displaying schemas as diagrams.<a id="filepos190585" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_070.html#filepos4339088" class="calibre41">7</a></sup> A displayed schema is called a <strong class="calibre6">schema diagram</strong>. <a href="#filepos192649" class="calibre41">Figure 2.1</a> shows a schema diagram for the database shown in <a href="dummy_split_015.html#filepos107062" class="calibre41">Figure 1.2</a>; the diagram displays the structure of each record type but not the actual instances of records. We call each object in the schema—such as STUDENT or COURSE—a <strong class="calibre6">schema construct</strong>.</p><div class="calibre31"> </div>
<p class="calibre18">A schema diagram displays only <em class="calibre13">some aspects</em> of a schema, such as the names of record types and data items, and some types of constraints. Other aspects are not specified in the schema diagram; for example, <a href="#filepos192649" class="calibre41">Figure 2.1</a> shows neither the data type of each data item, nor the relationships among the various files. Many types of constraints are not represented in schema diagrams. A constraint such as <em class="calibre13">students majoring in computer science must take CS1310 before the end of their sophomore year</em> is quite difficult to represent diagrammatically.</p><div class="calibre31"> </div>
<p class="calibre18">The actual data in a database may change quite frequently. For example, the database shown in <a href="dummy_split_015.html#filepos107062" class="calibre41">Figure 1.2</a> changes every time we add a new student or enter a new grade. The data in the database at a particular moment in time is called a <strong class="calibre6">database state</strong> or <strong class="calibre6">snapshot</strong>. It is also called the <em class="calibre13">current</em> set of <strong class="calibre6">occurrences</strong> or <strong class="calibre6">instances</strong> in the <a id="filepos192162" class="calibre3"></a>database. In a given database state, each schema construct has its own <em class="calibre13">current set</em> of instances; for example, the STUDENT construct will contain the set of individual student entities (records) as its instances. Many database states can be constructed to correspond to a particular database schema. Every time we insert or delete a record or change the value of a data item in a record, we change one state of the database into another state.</p><div class="calibre31"> </div>
<p id="filepos192649" class="calibre7"><img alt="image" src="../images/00013.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 2.1</strong><br class="calibre1"/>Schema diagram for the database in <a href="dummy_split_015.html#filepos107062" class="calibre41">Figure 1.2</a>.</p><div class="calibre31"> </div>
<p class="calibre18">The distinction between database schema and database state is very important. When we <strong class="calibre6">define</strong> a new database, we specify its database schema only to the DBMS. At this point, the corresponding database state is the <em class="calibre13">empty state</em> with no data. We get the <em class="calibre13">initial state</em> of the database when the database is first <strong class="calibre6">populated</strong> or <strong class="calibre6">loaded</strong> with the initial data. From then on, every time an update operation is applied to the database, we get another database state. At any point in time, the database has a <em class="calibre13">current state</em>.<a id="filepos193514" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_071.html#filepos4339432" class="calibre41">8</a></sup> The DBMS is partly responsible for ensuring that every state of the database is a <strong class="calibre6">valid state</strong>—that is, a state that satisfies the structure and constraints specified in the schema. Hence, specifying a correct schema to the DBMS is extremely important and the schema must be designed with utmost care. The DBMS stores the descriptions of the schema constructs and constraints—also called the <strong class="calibre6">meta-data</strong>—in the DBMS catalog so that DBMS software can refer to the schema whenever it needs to. The schema is sometimes called the <strong class="calibre6">intension</strong>, and a database state is called an <strong class="calibre6">extension</strong> of the schema.</p><div class="calibre31"> </div>
<p class="calibre18">Although, as mentioned earlier, the schema is not supposed to change frequently, it is not uncommon that changes occasionally need to be applied to the schema as the application requirements change. For example, we may decide that another data item needs to be stored for each record in a file, such as adding the Date_of_birth to the STUDENT schema in <a href="#filepos192649" class="calibre41">Figure 2.1</a>. This is known as <strong class="calibre6">schema evolution</strong>. Most modern DBMSs include some operations for schema evolution that can be applied while the database is operational.</p><div class="calibre31"> </div>
<h4 id="filepos194887" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">2.2 Three-Schema Architecture and Data Independence</span></span></blockquote></h4><div class="calibre31"> </div>
<p class="calibre18">Three of the four important characteristics of the database approach, listed in Section 1.3, are (1) use of a catalog to store the database description (schema) so as to make it self-describing, (2) insulation of programs and data (program-data and program-operation independence), and (3) support of multiple user views. In this section we specify an architecture for database systems, called the <strong class="calibre6">three-schema architecture</strong>,<a id="filepos195545" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_072.html#filepos4339776" class="calibre41">9</a></sup> that was proposed to help achieve and visualize these characteristics. Then we discuss the concept of data independence further.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1"><a id="filepos195833" class="calibre3"></a>2.2.1 The Three-Schema Architecture</span></span></blockquote></h5>
<p class="calibre18">The goal of the three-schema architecture, illustrated in <a href="#filepos197871" class="calibre41">Figure 2.2</a>, is to separate the user applications from the physical database. In this architecture, schemas can be defined at the following three levels:</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40"><strong class="calibre6">1.</strong> The <strong class="calibre6">internal level</strong> has an <strong class="calibre6">internal schema</strong>, which describes the physical storage structure of the database. The internal schema uses a physical data model and describes the complete details of data storage and access paths for the database.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><strong class="calibre6">2.</strong> The <strong class="calibre6">conceptual level</strong> has a <strong class="calibre6">conceptual schema</strong>, which describes the structure of the whole database for a community of users. The conceptual schema hides the details of physical storage structures and concentrates on describing entities, data types, relationships, user operations, and constraints. Usually, a representational data model is used to describe the conceptual schema when a database system is implemented. This <em class="calibre13">implementation conceptual schema</em> is often based on a <em class="calibre13">conceptual schema design</em> in a high-level data model.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><strong class="calibre6">3.</strong> The <strong class="calibre6">external</strong> or <strong class="calibre6">view level</strong> includes a number of <strong class="calibre6">external schemas</strong> or <strong class="calibre6">user views</strong>. Each external schema describes the part of the database that a particular user group is interested in and hides the rest of the database from that user group. As in the previous level, each external schema is typically implemented using a representational data model, possibly based on an external schema design in a high-level data model.</p></blockquote>
<p id="filepos197871" class="calibre7"><img alt="image" src="../images/00014.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 2.2</strong><br class="calibre1"/>The three-schema architecture.</p><div class="calibre31"> </div>
<p class="calibre18"><a id="filepos198106" class="calibre3"></a>The three-schema architecture is a convenient tool with which the user can visualize the schema levels in a database system. Most DBMSs do not separate the three levels completely and explicitly, but support the three-schema architecture to some extent. Some older DBMSs may include physical-level details in the conceptual schema. The three-level ANSI architecture has an important place in database technology development because it clearly separates the users’ external level, the database’s conceptual level, and the internal storage level for designing a database. It is very much applicable in the design of DBMSs, even today. In most DBMSs that support user views, external schemas are specified in the same data model that describes the conceptual-level information (for example, a relational DBMS like Oracle uses SQL for this). Some DBMSs allow different data models to be used at the conceptual and external levels. An example is Universal Data Base (UDB), a DBMS from IBM, which uses the relational model to describe the conceptual schema, but may use an object-oriented model to describe an external schema.</p><div class="calibre31"> </div>
<p class="calibre18">Notice that the three schemas are only <em class="calibre13">descriptions</em> of data; the stored data that <em class="calibre13">actually</em> exists is at the physical level only. In a DBMS based on the three-schema architecture, each user group refers to its own external schema. Hence, the DBMS must transform a request specified on an external schema into a request against the conceptual schema, and then into a request on the internal schema for processing over the stored database. If the request is a database retrieval, the data extracted from the stored database must be reformatted to match the user’s external view. The processes of transforming requests and results between levels are called <strong class="calibre6">mappings</strong>. These mappings may be time-consuming, so some DBMSs—especially those that are meant to support small databases—do not support external views. Even in such systems, however, a certain amount of mapping is necessary to transform requests between the conceptual and internal levels.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">2.2.2 Data Independence</span></span></blockquote></h5>
<p class="calibre18">The three-schema architecture can be used to further explain the concept of <strong class="calibre6">data independence</strong>, which can be defined as the capacity to change the schema at one level of a database system without having to change the schema at the next higher level. We can define two types of data independence:</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40"><strong class="calibre6">1. Logical data independence</strong> is the capacity to change the conceptual schema without having to change external schemas or application programs. We may change the conceptual schema to expand the database (by adding a record type or data item), to change constraints, or to reduce the database (by removing a record type or data item). In the last case, external schemas that refer only to the remaining data should not be affected. For example, the external schema of <a href="dummy_split_015.html#filepos125620" class="calibre41">Figure 1.5(a)</a> should not be affected by changing the GRADE_REPORT file (or record type) shown in <a href="dummy_split_015.html#filepos107062" class="calibre41">Figure 1.2</a> into the one shown in <a href="dummy_split_015.html#filepos142265" class="calibre41">Figure 1.6(a)</a>. Only the view definition and the mappings need to be changed in a DBMS that supports logical data independence. After the conceptual schema undergoes a logical reorganization, application programs that reference the external schema constructs must work as before. <a id="filepos201870" class="calibre3"></a>Changes to constraints can be applied to the conceptual schema without affecting the external schemas or application programs.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><strong class="calibre6">2. Physical data independence</strong> is the capacity to change the internal schema without having to change the conceptual schema. Hence, the external schemas need not be changed as well. Changes to the internal schema may be needed because some physical files were reorganized—for example, by creating additional access structures—to improve the performance of retrieval or update. If the same data as before remains in the database, we should not have to change the conceptual schema. For example, providing an access path to improve retrieval speed of section records (<a href="dummy_split_015.html#filepos107062" class="calibre41">Figure 1.2</a>) by semester and year should not require a query such as <em class="calibre13">list all sections offered in fall 2008</em> to be changed, although the query would be executed more efficiently by the DBMS by utilizing the new access path.</p></blockquote>
<p class="calibre18">Generally, physical data independence exists in most databases and file environments where physical details such as the exact location of data on disk, and hardware details of storage encoding, placement, compression, splitting, merging of records, and so on are hidden from the user. Applications remain unaware of these details. On the other hand, logical data independence is harder to achieve because it allows structural and constraint changes without affecting application programs—a much stricter requirement.</p><div class="calibre31"> </div>
<p class="calibre18">Whenever we have a multiple-level DBMS, its catalog must be expanded to include information on how to map requests and data among the various levels. The DBMS uses additional software to accomplish these mappings by referring to the mapping information in the catalog. Data independence occurs because when the schema is changed at some level, the schema at the next higher level remains unchanged; only the <em class="calibre13">mapping</em> between the two levels is changed. Hence, application programs referring to the higher-level schema need not be changed.</p><div class="calibre31"> </div>
<p class="calibre18">The three-schema architecture can make it easier to achieve true data independence, both physical and logical. However, the two levels of mappings create an overhead during compilation or execution of a query or program, leading to inefficiencies in the DBMS. Because of this, few DBMSs have implemented the full three-schema architecture.</p><div class="calibre31"> </div>
<h4 id="filepos204556" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">2.3 Database Languages and Interfaces</span></span></blockquote></h4><div class="calibre31"> </div>
<p class="calibre18">In Section 1.4 we discussed the variety of users supported by a DBMS. The DBMS must provide appropriate languages and interfaces for each category of users. In this section we discuss the types of languages and interfaces provided by a DBMS and the user categories targeted by each interface.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">2.3.1 DBMS Languages</span></span></blockquote></h5>
<p class="calibre18">Once the design of a database is completed and a DBMS is chosen to implement the database, the first step is to specify conceptual and internal schemas for the database <a id="filepos205435" class="calibre3"></a>and any mappings between the two. In many DBMSs where no strict separation of levels is maintained, one language, called the <strong class="calibre6">data definition language</strong> (<strong class="calibre6">DDL</strong>), is used by the DBA and by database designers to define both schemas. The DBMS will have a DDL compiler whose function is to process DDL statements in order to identify descriptions of the schema constructs and to store the schema description in the DBMS catalog.</p><div class="calibre31"> </div>
<p class="calibre18">In DBMSs where a clear separation is maintained between the conceptual and internal levels, the DDL is used to specify the conceptual schema only. Another language, the <strong class="calibre6">storage definition language</strong> (<strong class="calibre6">SDL</strong>), is used to specify the internal schema. The mappings between the two schemas may be specified in either one of these languages. In most relational DBMSs today, there <em class="calibre13">is no specific language</em> that performs the role of SDL. Instead, the internal schema is specified by a combination of functions, parameters, and specifications related to storage. These permit the DBA staff to control indexing choices and mapping of data to storage. For a true three-schema architecture, we would need a third language, the <strong class="calibre6">view definition language</strong> (<strong class="calibre6">VDL</strong>), to specify user views and their mappings to the conceptual schema, but in most DBMSs <em class="calibre13">the DDL is used to define both conceptual and external schemas</em>. In relational DBMSs, SQL is used in the role of VDL to define user or application <strong class="calibre6">views</strong> as results of predefined queries (see <a href="dummy_split_019.html#filepos362078" class="calibre41">Chapters 4</a> and <a href="dummy_split_020.html#filepos448575" class="calibre41">5</a>).</p><div class="calibre31"> </div>
<p class="calibre18">Once the database schemas are compiled and the database is populated with data, users must have some means to manipulate the database. Typical manipulations include retrieval, insertion, deletion, and modification of the data. The DBMS provides a set of operations or a language called the <strong class="calibre6">data manipulation language</strong> (<strong class="calibre6">DML</strong>) for these purposes.</p><div class="calibre31"> </div>
<p class="calibre18">In current DBMSs, the preceding types of languages are usually <em class="calibre13">not considered distinct languages</em>; rather, a comprehensive integrated language is used that includes constructs for conceptual schema definition, view definition, and data manipulation. Storage definition is typically kept separate, since it is used for defining physical storage structures to fine-tune the performance of the database system, which is usually done by the DBA staff. A typical example of a comprehensive database language is the SQL relational database language (see <a href="dummy_split_019.html#filepos362078" class="calibre41">Chapters 4</a> and <a href="dummy_split_020.html#filepos448575" class="calibre41">5</a>), which represents a combination of DDL, VDL, and DML, as well as statements for constraint specification, schema evolution, and other features. The SDL was a component in early versions of SQL but has been removed from the language to keep it at the conceptual and external levels only.</p><div class="calibre31"> </div>
<p class="calibre18">There are two main types of DMLs. A <strong class="calibre6">high-level</strong> or <strong class="calibre6">nonprocedural</strong> DML can be used on its own to specify complex database operations concisely. Many DBMSs allow high-level DML statements either to be entered interactively from a display monitor or terminal or to be embedded in a general-purpose programming language. In the latter case, DML statements must be identified within the program so that they can be extracted by a precompiler and processed by the DBMS. A <strong class="calibre6">low-level</strong> or <strong class="calibre6">procedural</strong> DML <em class="calibre13">must</em> be embedded in a general-purpose programming language. This type of DML typically retrieves individual records or objects from the database and processes each separately. Therefore, it needs to use programming <a id="filepos209389" class="calibre3"></a>language constructs, such as looping, to retrieve and process each record from a set of records. Low-level DMLs are also called <strong class="calibre6">record-at-a-time</strong> DMLs because of this property. DL/1, a DML designed for the hierarchical model, is a low-level DML that uses commands such as GET UNIQUE, GET NEXT, or GET NEXT WITHIN PARENT to navigate from record to record within a hierarchy of records in the database. High-level DMLs, such as SQL, can specify and retrieve many records in a single DML statement; therefore, they are called <strong class="calibre6">set-at-a-time</strong> or <strong class="calibre6">set-oriented</strong> DMLs. A query in a high-level DML often specifies <em class="calibre13">which</em> data to retrieve rather than <em class="calibre13">how</em> to retrieve it; therefore, such languages are also called <strong class="calibre6">declarative</strong>.</p><div class="calibre31"> </div>
<p class="calibre18">Whenever DML commands, whether high level or low level, are embedded in a general-purpose programming language, that language is called the <strong class="calibre6">host language</strong> and the DML is called the <strong class="calibre6">data sublanguage</strong>.<a id="filepos210481" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_073.html#filepos4340023" class="calibre41">10</a></sup> On the other hand, a high-level DML used in a standalone interactive manner is called a <strong class="calibre6">query language</strong>. In general, both retrieval and update commands of a high-level DML may be used interactively and are hence considered part of the query language.<a id="filepos210795" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_074.html#filepos4340424" class="calibre41">11</a></sup></p><div class="calibre31"> </div>
<p class="calibre18">Casual end users typically use a high-level query language to specify their requests, whereas programmers use the DML in its embedded form. For naive and parametric users, there usually are <strong class="calibre6">user-friendly interfaces</strong> for interacting with the database; these can also be used by casual users or others who do not want to learn the details of a high-level query language. We discuss these types of interfaces next.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">2.3.2 DBMS Interfaces</span></span></blockquote></h5>
<p class="calibre18">User-friendly interfaces provided by a DBMS may include the following:</p><div class="calibre31"> </div>
<p class="calibre18"><strong class="calibre6">Menu-Based Interfaces for Web Clients or Browsing.</strong> These interfaces present the user with lists of options (called <strong class="calibre6">menus)</strong> that lead the user through the formulation of a request. Menus do away with the need to memorize the specific commands and syntax of a query language; rather, the query is composed step-by-step by picking options from a menu that is displayed by the system. Pull-down menus are a very popular technique in <strong class="calibre6">Web-based user interfaces</strong>. They are also often used in <strong class="calibre6">browsing interfaces</strong>, which allow a user to look through the contents of a database in an exploratory and unstructured manner.</p><div class="calibre31"> </div>
<p class="calibre18"><strong class="calibre6">Forms-Based Interfaces.</strong> A forms-based interface displays a form to each user. Users can fill out all of the <strong class="calibre6">form</strong> entries to insert new data, or they can fill out only certain entries, in which case the DBMS will retrieve matching data for the remaining entries. Forms are usually designed and programmed for naive users as interfaces to canned transactions. Many DBMSs have <strong class="calibre6">forms specification languages</strong>, <a id="filepos212858" class="calibre3"></a>which are special languages that help programmers specify such forms. SQL*Forms is a form-based language that specifies queries using a form designed in conjunction with the relational database schema. Oracle Forms is a component of the Oracle product suite that provides an extensive set of features to design and build applications using forms. Some systems have utilities that define a form by letting the end user interactively construct a sample form on the screen.</p><div class="calibre31"> </div>
<p class="calibre18"><strong class="calibre6">Graphical User Interfaces.</strong> A GUI typically displays a schema to the user in diagrammatic form. The user then can specify a query by manipulating the diagram. In many cases, GUIs utilize both menus and forms. Most GUIs use a <strong class="calibre6">pointing device</strong>, such as a mouse, to select certain parts of the displayed schema diagram.</p><div class="calibre31"> </div>
<p class="calibre18"><strong class="calibre6">Natural Language Interfaces.</strong> These interfaces accept requests written in English or some other language and attempt to <em class="calibre13">understand</em> them. A natural language interface usually has its own <em class="calibre13">schema</em>, which is similar to the database conceptual schema, as well as a dictionary of important words. The natural language interface refers to the words in its schema, as well as to the set of standard words in its dictionary, to interpret the request. If the interpretation is successful, the interface generates a high-level query corresponding to the natural language request and submits it to the DBMS for processing; otherwise, a dialogue is started with the user to clarify the request. The capabilities of natural language interfaces have not advanced rapidly. Today, we see search engines that accept strings of natural language (like English or Spanish) words and match them with documents at specific sites (for local search engines) or Web pages on the Web at large (for engines like Google or Ask). They use predefined indexes on words and use ranking functions to retrieve and present resulting documents in a decreasing degree of match. Such “free form” textual query interfaces are not yet common in structured relational or legacy model databases, although a research area called <strong class="calibre6">keyword-based querying</strong> has emerged recently for relational databases.</p><div class="calibre31"> </div>
<p class="calibre18"><strong class="calibre6">Speech Input and Output.</strong> Limited use of speech as an input query and speech as an answer to a question or result of a request is becoming commonplace. Applications with limited vocabularies such as inquiries for telephone directory, flight arrival/departure, and credit card account information are allowing speech for input and output to enable customers to access this information. The speech input is detected using a library of predefined words and used to set up the parameters that are supplied to the queries. For output, a similar conversion from text or numbers into speech takes place.</p><div class="calibre31"> </div>
<p class="calibre18"><strong class="calibre6">Interfaces for Parametric Users.</strong> Parametric users, such as bank tellers, often have a small set of operations that they must perform repeatedly. For example, a teller is able to use single function keys to invoke routine and repetitive transactions such as account deposits or withdrawals, or balance inquiries. Systems analysts and programmers design and implement a special interface for each known class of naive users. Usually a small set of abbreviated commands is included, with the goal of minimizing the number of keystrokes required for each request. For example, <a id="filepos216529" class="calibre3"></a>function keys in a terminal can be programmed to initiate various commands. This allows the parametric user to proceed with a minimal number of keystrokes.</p><div class="calibre31"> </div>
<p class="calibre18"><strong class="calibre6">Interfaces for the DBA.</strong> Most database systems contain privileged commands that can be used only by the DBA staff. These include commands for creating accounts, setting system parameters, granting account authorization, changing a schema, and reorganizing the storage structures of a database.</p><div class="calibre31"> </div>
<h4 id="filepos217086" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">2.4 The Database System Environment</span></span></blockquote></h4><div class="calibre31"> </div>
<p class="calibre18">A DBMS is a complex software system. In this section we discuss the types of software components that constitute a DBMS and the types of computer system software with which the DBMS interacts.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">2.4.1 DBMS Component Modules</span></span></blockquote></h5>
<p class="calibre18"><a href="#filepos221062" class="calibre41">Figure 2.3</a> illustrates, in a simplified form, the typical DBMS components. The figure is divided into two parts. The top part of the figure refers to the various users of the database environment and their interfaces. The lower part shows the internals of the DBMS responsible for storage of data and processing of transactions.</p><div class="calibre31"> </div>
<p class="calibre18">The database and the DBMS catalog are usually stored on disk. Access to the disk is controlled primarily by the <strong class="calibre6">operating system</strong> (<strong class="calibre6">OS</strong>), which schedules disk read/write. Many DBMSs have their own <strong class="calibre6">buffer management</strong> module to schedule disk read/write, because this has a considerable effect on performance. Reducing disk read/write improves performance considerably. A higher-level <strong class="calibre6">stored data manager</strong> module of the DBMS controls access to DBMS information that is stored on disk, whether it is part of the database or the catalog.</p><div class="calibre31"> </div>
<p class="calibre18">Let us consider the top part of <a href="#filepos221062" class="calibre41">Figure 2.3</a> first. It shows interfaces for the DBA staff, casual users who work with interactive interfaces to formulate queries, application programmers who create programs using some host programming languages, and parametric users who do data entry work by supplying parameters to predefined transactions. The DBA staff works on defining the database and tuning it by making changes to its definition using the DDL and other privileged commands.</p><div class="calibre31"> </div>
<p class="calibre18">The DDL compiler processes schema definitions, specified in the DDL, and stores descriptions of the schemas (meta-data) in the DBMS catalog. The catalog includes information such as the names and sizes of files, names and data types of data items, storage details of each file, mapping information among schemas, and constraints. In addition, the catalog stores many other types of information that are needed by the DBMS modules, which can then look up the catalog information as needed.</p><div class="calibre31"> </div>
<p class="calibre18">Casual users and persons with occasional need for information from the database interact using some form of interface, which we call the <strong class="calibre6">interactive query</strong> interface in <a href="#filepos221062" class="calibre41">Figure 2.3</a>. We have not explicitly shown any menu-based or form-based interaction that may be used to generate the interactive query automatically. These queries are parsed and validated for correctness of the query syntax, the names of files and <a id="filepos220333" class="calibre3"></a>data elements, and so on by a <strong class="calibre6">query compiler</strong> that compiles them into an internal form. This internal query is subjected to query optimization (discussed in <a href="dummy_split_040.html#filepos2126215" class="calibre41">Chapters 19</a> and <a href="dummy_split_041.html#filepos2284299" class="calibre41">20</a>). Among other things, the <strong class="calibre6">query optimizer</strong> is concerned with the rearrangement and possible reordering of operations, elimination of redundancies, and use of correct algorithms and indexes during execution. It consults the system catalog for statistical and other physical information about the stored data and generates executable code that performs the necessary operations for the query and makes calls on the runtime processor.</p><div class="calibre31"> </div>
<p id="filepos221062" class="calibre7"><img alt="image" src="../images/00015.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 2.3</strong><br class="calibre1"/>Component modules of a DBMS and their interactions.</p><div class="calibre31"> </div>
<p class="calibre18"><a id="filepos221318" class="calibre3"></a>Application programmers write programs in host languages such as Java, C, or C++ that are submitted to a precompiler. The <strong class="calibre6">precompiler</strong> extracts DML commands from an application program written in a host programming language. These commands are sent to the DML compiler for compilation into object code for database access. The rest of the program is sent to the host language compiler. The object codes for the DML commands and the rest of the program are linked, forming a canned transaction whose executable code includes calls to the runtime database processor. Canned transactions are executed repeatedly by parametric users, who simply supply the parameters to the transactions. Each execution is considered to be a separate transaction. An example is a bank withdrawal transaction where the account number and the amount may be supplied as parameters.</p><div class="calibre31"> </div>
<p class="calibre18">In the lower part of <a href="#filepos221062" class="calibre41">Figure 2.3</a>, the <strong class="calibre6">runtime database processor</strong> executes (1) the privileged commands, (2) the executable query plans, and (3) the canned transactions with runtime parameters. It works with the <strong class="calibre6">system catalog</strong> and may update it with statistics. It also works with the <strong class="calibre6">stored data manager</strong>, which in turn uses basic operating system services for carrying out low-level input/output (read/write) operations between the disk and main memory. The runtime database processor handles other aspects of data transfer, such as management of buffers in the main memory. Some DBMSs have their own buffer management module while others depend on the OS for buffer management. We have shown <strong class="calibre6">concurrency control</strong> and <strong class="calibre6">backup and recovery systems</strong> separately as a module in this figure. They are integrated into the working of the runtime database processor for purposes of transaction management.</p><div class="calibre31"> </div>
<p class="calibre18">It is now common to have the <strong class="calibre6">client program</strong> that accesses the DBMS running on a separate computer from the computer on which the database resides. The former is called the <strong class="calibre6">client computer</strong> running a DBMS client software and the latter is called the <strong class="calibre6">database server</strong>. In some cases, the client accesses a middle computer, called the <strong class="calibre6">application server</strong>, which in turn accesses the database server. We elaborate on this topic in Section 2.5.</p><div class="calibre31"> </div>
<p class="calibre18"><a href="#filepos221062" class="calibre41">Figure 2.3</a> is not meant to describe a specific DBMS; rather, it illustrates typical DBMS modules. The DBMS interacts with the operating system when disk accesses—to the database or to the catalog—are needed. If the computer system is shared by many users, the OS will schedule DBMS disk access requests and DBMS processing along with other processes. On the other hand, if the computer system is mainly dedicated to running the database server, the DBMS will control main memory buffering of disk pages. The DBMS also interfaces with compilers for general-purpose host programming languages, and with application servers and client programs running on separate machines through the system network interface.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">2.4.2 Database System Utilities</span></span></blockquote></h5>
<p class="calibre18">In addition to possessing the software modules just described, most DBMSs have <strong class="calibre6">database utilities</strong> that help the DBA manage the database system. Common utilities have the following types of functions:</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/><strong class="calibre6">Loading.</strong> A loading utility is used to load existing data files—such as text files or sequential files—into the database. Usually, the current (source) format <a id="filepos225363" class="calibre3"></a>of the data file and the desired (target) database file structure are specified to the utility, which then automatically reformats the data and stores it in the database. With the proliferation of DBMSs, transferring data from one DBMS to another is becoming common in many organizations. Some vendors are offering products that generate the appropriate loading programs, given the existing source and target database storage descriptions (internal schemas). Such tools are also called <strong class="calibre6">conversion tools</strong>. For the hierarchical DBMS called IMS (IBM) and for many network DBMSs including IDMS (Computer Associates), SUPRA (Cincom), and IMAGE (HP), the vendors or third-party companies are making a variety of conversion tools available (e.g., Cincom’s SUPRA Server SQL) to transform data into the relational model.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/><strong class="calibre6">Backup.</strong> A backup utility creates a backup copy of the database, usually by dumping the entire database onto tape or other mass storage medium. The backup copy can be used to restore the database in case of catastrophic disk failure. Incremental backups are also often used, where only changes since the previous backup are recorded. Incremental backup is more complex, but saves storage space.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/><strong class="calibre6">Database storage reorganization.</strong> This utility can be used to reorganize a set of database files into different file organizations, and create new access paths to improve performance.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/><strong class="calibre6">Performance monitoring.</strong> Such a utility monitors database usage and provides statistics to the DBA. The DBA uses the statistics in making decisions such as whether or not to reorganize files or whether to add or drop indexes to improve performance.</p></blockquote>
<p class="calibre18">Other utilities may be available for sorting files, handling data compression, monitoring access by users, interfacing with the network, and performing other functions.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">2.4.3 Tools, Application Environments, and Communications Facilities</span></span></blockquote></h5>
<p class="calibre18">Other tools are often available to database designers, users, and the DBMS. CASE tools<a id="filepos228035" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_075.html#filepos4340683" class="calibre41">12</a></sup> are used in the design phase of database systems. Another tool that can be quite useful in large organizations is an expanded <strong class="calibre6">data dictionary</strong> (or <strong class="calibre6">data repository</strong>) <strong class="calibre6">system</strong>. In addition to storing catalog information about schemas and constraints, the data dictionary stores other information, such as design decisions, usage standards, application program descriptions, and user information. Such a system is also called an <strong class="calibre6">information repository</strong>. This information can be accessed <em class="calibre13">directly</em> by users or the DBA when needed. A data dictionary utility is similar to the DBMS catalog, but it includes a wider variety of information and is accessed mainly by users rather than by the DBMS software.</p><div class="calibre31"> </div>
<p class="calibre18"><a id="filepos228908" class="calibre3"></a><strong class="calibre6">Application development environments</strong>, such as PowerBuilder (Sybase) or JBuilder (Borland), have been quite popular. These systems provide an environment for developing database applications and include facilities that help in many facets of database systems, including database design, GUI development, querying and updating, and application program development.</p><div class="calibre31"> </div>
<p class="calibre18">The DBMS also needs to interface with <strong class="calibre6">communications software</strong>, whose function is to allow users at locations remote from the database system site to access the database through computer terminals, workstations, or personal computers. These are connected to the database site through data communications hardware such as Internet routers, phone lines, long-haul networks, local networks, or satellite communication devices. Many commercial database systems have communication packages that work with the DBMS. The integrated DBMS and data communications system is called a <strong class="calibre6">DB/DC</strong> system. In addition, some distributed DBMSs are physically distributed over multiple machines. In this case, communications networks are needed to connect the machines. These are often <strong class="calibre6">local area networks (LANs)</strong>, but they can also be other types of networks.</p><div class="calibre31"> </div>
<h4 id="filepos230267" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">2.5 Centralized and Client/Server Architectures for DBMSs</span></span></blockquote></h4><div class="calibre31"> </div>
<h5 class="calibre64"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">2.5.1 Centralized DBMSs Architecture</span></span></blockquote></h5>
<p class="calibre18">Architectures for DBMSs have followed trends similar to those for general computer system architectures. Earlier architectures used mainframe computers to provide the main processing for all system functions, including user application programs and user interface programs, as well as all the DBMS functionality. The reason was that most users accessed such systems via computer terminals that did not have processing power and only provided display capabilities. Therefore, all processing was performed remotely on the computer system, and only display information and controls were sent from the computer to the display terminals, which were connected to the central computer via various types of communications networks.</p><div class="calibre31"> </div>
<p class="calibre18">As prices of hardware declined, most users replaced their terminals with PCs and workstations. At first, database systems used these computers similarly to how they had used display terminals, so that the DBMS itself was still a <strong class="calibre6">centralized</strong> DBMS in which all the DBMS functionality, application program execution, and user interface processing were carried out on one machine. <a href="#filepos234217" class="calibre41">Figure 2.4</a> illustrates the physical components in a centralized architecture. Gradually, DBMS systems started to exploit the available processing power at the user side, which led to client/server DBMS architectures.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">2.5.2 Basic Client/Server Architectures</span></span></blockquote></h5>
<p class="calibre18">First, we discuss client/server architecture in general, then we see how it is applied to DBMSs. The <strong class="calibre6">client/server architecture</strong> was developed to deal with computing environments in which a large number of PCs, workstations, file servers, printers, database servers, Web servers, e-mail servers, and other software and equipment are connected via a network. The idea is to define <strong class="calibre6">specialized servers</strong> with specific functionalities. For example, it is possible to connect a number of PCs or small workstations as clients to a <strong class="calibre6">file server</strong> that maintains the files of the client machines. Another machine can be designated as a <strong class="calibre6">printer server</strong> by being connected to various printers; all print requests by the clients are forwarded to this machine. <strong class="calibre6">Web servers</strong> or <strong class="calibre6">e-mail servers</strong> also fall into the specialized server category. The resources provided by specialized servers can be accessed by many client machines. The <strong class="calibre6">client machines</strong> provide the user with the appropriate interfaces to utilize these servers, as well as with local processing power to run local applications. This concept can be carried over to other software packages, with specialized programs—such as a CAD (computer-aided design) package—being stored on specific server machines and being made accessible to multiple clients. <a href="#filepos234437" class="calibre41">Figure 2.5</a> illustrates client/server architecture at the logical level; <a href="#filepos234658" class="calibre41">Figure 2.6</a> is a simplified diagram that shows the physical architecture. Some machines would be client sites only (for example, diskless workstations or workstations/PCs with disks that have only client software installed). Other machines would be dedicated servers, and others would have both client and server functionality.</p><div class="calibre31"> </div>
<p id="filepos234217" class="calibre7"><a id="filepos234248" class="calibre3"></a><img alt="image" src="../images/00016.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 2.4</strong><br class="calibre1"/>A physical centralized architecture.</p><div class="calibre31"> </div>
<p id="filepos234437" class="calibre7"><img alt="image" src="../images/00017.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 2.5</strong><br class="calibre1"/>Logical two-tier client/server architecture.</p><div class="calibre31"> </div>
<p id="filepos234658" class="calibre7"><a id="filepos234689" class="calibre3"></a><img alt="image" src="../images/00018.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 2.6</strong><br class="calibre1"/>Physical two-tier client/server architecture.</p><div class="calibre31"> </div>
<p class="calibre18">The concept of client/server architecture assumes an underlying framework that consists of many PCs and workstations as well as a smaller number of mainframe machines, connected via LANs and other types of computer networks. A <strong class="calibre6">client</strong> in this framework is typically a user machine that provides user interface capabilities and local processing. When a client requires access to additional functionality—such as database access—that does not exist at that machine, it connects to a server that provides the needed functionality. A <strong class="calibre6">server</strong> is a system containing both hardware and software that can provide services to the client machines, such as file access, printing, archiving, or database access. In general, some machines install only client software, others only server software, and still others may include both client and server software, as illustrated in <a href="#filepos234658" class="calibre41">Figure 2.6</a>. However, it is more common that client and server software usually run on separate machines. Two main types of basic DBMS architectures were created on this underlying client/server framework: <strong class="calibre6">two-tier</strong> and <strong class="calibre6">three-tier</strong>.<a id="filepos236114" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_076.html#filepos4340932" class="calibre41">13</a></sup> We discuss them next.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">2.5.3 Two-Tier Client/Server Architectures for DBMSs</span></span></blockquote></h5>
<p class="calibre18">In relational database management systems (RDBMSs), many of which started as centralized systems, the system components that were first moved to the client side were the user interface and application programs. Because SQL (see <a href="dummy_split_019.html#filepos362078" class="calibre41">Chapters 4</a> and <a href="dummy_split_020.html#filepos448575" class="calibre41">5</a>) provided a standard language for RDBMSs, this created a logical dividing point <a id="filepos236809" class="calibre3"></a>between client and server. Hence, the query and transaction functionality related to SQL processing remained on the server side. In such an architecture, the server is often called a <strong class="calibre6">query server</strong> or <strong class="calibre6">transaction server</strong> because it provides these two functionalities. In an RDBMS, the server is also often called an <strong class="calibre6">SQL server</strong>.</p><div class="calibre31"> </div>
<p class="calibre18">The user interface programs and application programs can run on the client side. When DBMS access is required, the program establishes a connection to the DBMS (which is on the server side); once the connection is created, the client program can communicate with the DBMS. A standard called <strong class="calibre6">Open Database Connectivity</strong> (<strong class="calibre6">ODBC</strong>) provides an <strong class="calibre6">application programming interface</strong> (<strong class="calibre6">API</strong>), which allows client-side programs to call the DBMS, as long as both client and server machines have the necessary software installed. Most DBMS vendors provide ODBC drivers for their systems. A client program can actually connect to several RDBMSs and send query and transaction requests using the ODBC API, which are then processed at the server sites. Any query results are sent back to the client program, which can process and display the results as needed. A related standard for the Java programming language, called <strong class="calibre6">JDBC</strong>, has also been defined. This allows Java client programs to access one or more DBMSs through a standard interface.</p><div class="calibre31"> </div>
<p class="calibre18">The different approach to two-tier client/server architecture was taken by some object-oriented DBMSs, where the software modules of the DBMS were divided between client and server in a more integrated way. For example, the <strong class="calibre6">server level</strong> may include the part of the DBMS software responsible for handling data storage on disk pages, local concurrency control and recovery, buffering and caching of disk pages, and other such functions. Meanwhile, the <strong class="calibre6">client level</strong> may handle the user interface; data dictionary functions; DBMS interactions with programming language compilers; global query optimization, concurrency control, and recovery across multiple servers; structuring of complex objects from the data in the buffers; and other such functions. In this approach, the client/server interaction is more tightly coupled and is done internally by the DBMS modules—some of which reside on the client and some on the server—rather than by the users/programmers. The exact division of functionality can vary from system to system. In such a client/server architecture, the server has been called a <strong class="calibre6">data server</strong> because it provides data in disk pages to the client. This data can then be structured into objects for the client programs by the client-side DBMS software.</p><div class="calibre31"> </div>
<p class="calibre18">The architectures described here are called <strong class="calibre6">two-tier architectures</strong> because the software components are distributed over two systems: client and server. The advantages of this architecture are its simplicity and seamless compatibility with existing systems. The emergence of the Web changed the roles of clients and servers, leading to the three-tier architecture.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">2.5.4 Three-Tier and n-Tier Architectures for Web Applications</span></span></blockquote></h5>
<p class="calibre18">Many Web applications use an architecture called the <strong class="calibre6">three-tier architecture</strong>, which adds an intermediate layer between the client and the database server, as illustrated in <a href="#filepos240691" class="calibre41">Figure 2.7(a)</a>.</p><div class="calibre31"> </div>
<p id="filepos240691" class="calibre7"><a id="filepos240722" class="calibre3"></a><img alt="image" src="../images/00019.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 2.7</strong><br class="calibre1"/>Logical three-tier client/server architecture, with a couple of commonly used nomenclatures.</p><div class="calibre31"> </div>
<p class="calibre18">This intermediate layer or <strong class="calibre6">middle tier</strong> is called the <strong class="calibre6">application server</strong> or the <strong class="calibre6">Web server</strong>, depending on the application. This server plays an intermediary role by running application programs and storing business rules (procedures or constraints) that are used to access data from the database server. It can also improve database security by checking a client’s credentials before forwarding a request to the database server. Clients contain GUI interfaces and some additional application-specific business rules. The intermediate server accepts requests from the client, processes the request and sends database queries and commands to the database server, and then acts as a conduit for passing (partially) processed data from the database server to the clients, where it may be processed further and filtered to be presented to users in GUI format. Thus, the <em class="calibre13">user interface, application rules</em>, and <em class="calibre13">data access</em> act as the three tiers. <a href="#filepos240691" class="calibre41">Figure 2.7(b)</a> shows another architecture used by database and other application package vendors. The presentation layer displays information to the user and allows data entry. The business logic layer handles intermediate rules and constraints before data is passed up to the user or down to the DBMS. The bottom layer includes all data management services. The middle layer can also act as a Web server, which retrieves query results from the database server and formats them into dynamic Web pages that are viewed by the Web browser at the client side.</p><div class="calibre31"> </div>
<p class="calibre18">Other architectures have also been proposed. It is possible to divide the layers between the user and the stored data further into finer components, thereby giving rise to <em class="calibre13">n</em>-tier architectures, where <em class="calibre13">n</em> may be four or five tiers. Typically, the business logic layer is divided into multiple layers. Besides distributing programming and data throughout a network, <em class="calibre13">n</em>-tier applications afford the advantage that any one tier can run on an appropriate processor or operating system platform and can be handled independently. Vendors of ERP (enterprise resource planning) and CRM (customer relationship management) packages often use a <em class="calibre13">middleware layer</em>, which accounts for the front-end modules (clients) communicating with a number of back-end databases (servers).</p><div class="calibre31"> </div>
<p class="calibre18"><a id="filepos243498" class="calibre3"></a>Advances in encryption and decryption technology make it safer to transfer sensitive data from server to client in encrypted form, where it will be decrypted. The latter can be done by the hardware or by advanced software. This technology gives higher levels of data security, but the network security issues remain a major concern. Various technologies for data compression also help to transfer large amounts of data from servers to clients over wired and wireless networks.</p><div class="calibre31"> </div>
<h4 id="filepos244010" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">2.6 Classification of Database Management Systems</span></span></blockquote></h4><div class="calibre31"> </div>
<p class="calibre18">Several criteria are normally used to classify DBMSs. The first is the <strong class="calibre6">data model</strong> on which the DBMS is based. The main data model used in many current commercial DBMSs is the <strong class="calibre6">relational data model</strong>. The <strong class="calibre6">object data model</strong> has been implemented in some commercial systems but has not had widespread use. Many legacy applications still run on database systems based on the <strong class="calibre6">hierarchical</strong> and <strong class="calibre6">network data models</strong>. Examples of hierarchical DBMSs include IMS (IBM) and some other systems like System 2K (SAS Inc.) and TDMS. IMS is still used at governmental and industrial installations, including hospitals and banks, although many of its users have converted to relational systems. The network data model was used by many vendors and the resulting products like IDMS (Cullinet—now Computer Associates), DMS 1100 (Univac—now Unisys), IMAGE (Hewlett-Packard), VAX-DBMS (Digital—then Compaq and now HP), and SUPRA (Cincom) still have a following and their user groups have their own active organizations. If we add IBM’s popular VSAM file system to these, we can easily say that a reasonable percentage of worldwide-computerized data is still in these so-called <strong class="calibre6">legacy database systems</strong>.</p><div class="calibre31"> </div>
<p class="calibre18">The relational DBMSs are evolving continuously, and, in particular, have been incorporating many of the concepts that were developed in object databases. This has led to a new class of DBMSs called <strong class="calibre6">object-relational DBMS</strong>s. We can categorize DBMSs based on the data model: relational, object, object-relational, hierarchical, network, and other.</p><div class="calibre31"> </div>
<p class="calibre18">More recently, some experimental DBMSs are based on the XML (eXtended Markup Language) model, which is a tree-structured (hierarchical) data model. These have been called <strong class="calibre6">native XML DBMSs.</strong> Several commercial relational DBMSs have added XML interfaces and storage to their products.</p><div class="calibre31"> </div>
<p class="calibre18">The second criterion used to classify DBMSs is the <strong class="calibre6">number of users</strong> supported by the system. <strong class="calibre6">Single-user systems</strong> support only one user at a time and are mostly used with PCs. <strong class="calibre6">Multiuser systems</strong>, which include the majority of DBMSs, support concurrent multiple users.</p><div class="calibre31"> </div>
<p class="calibre18">The third criterion is the <strong class="calibre6">number of sites</strong> over which the database is distributed. A DBMS is <strong class="calibre6">centralized</strong> if the data is stored at a single computer site. A centralized DBMS can support multiple users, but the DBMS and the database reside totally at a single computer site. A <strong class="calibre6">distributed</strong> DBMS (DDBMS) can have the actual database and DBMS software distributed over many sites, connected by a computer network. <strong class="calibre6">Homogeneous</strong> DDBMSs use the same DBMS software at all the sites, whereas <a id="filepos247277" class="calibre3"></a><strong class="calibre6">heterogeneous</strong> DDBMSs can use different DBMS software at each site. It is also possible to develop <strong class="calibre6">middleware software</strong> to access several autonomous preexisting databases stored under heterogeneousDBMSs. This leads to a <strong class="calibre6">federated</strong> DBMS (or <strong class="calibre6">multidatabase system</strong>), in which the participating DBMSs are loosely coupled and have a degree of local autonomy. Many DDBMSs use client-server architecture, as we described in Section 2.5.</p><div class="calibre31"> </div>
<p class="calibre18">The fourth criterion is cost. It is difficult to propose a classification of DBMSs based on cost. Today we have open source (free) DBMS products like MySQL and PostgreSQL that are supported by third-party vendors with additional services. The main RDBMS products are available as free examination 30-day copy versions as well as personal versions, which may cost under $100 and allow a fair amount of functionality. The giant systems are being sold in modular form with components to handle distribution, replication, parallel processing, mobile capability, and so on, and with a large number of parameters that must be defined for the configuration. Furthermore, they are sold in the form of licenses—site licenses allow unlimited use of the database system with any number of copies running at the customer site. Another type of license limits the number of concurrent users or the number of user seats at a location. Standalone single user versions of some systems like Microsoft Access are sold per copy or included in the overall configuration of a desktop or laptop. In addition, data warehousing and mining features, as well as support for additional data types, are made available at extra cost. It is possible to pay millions of dollars for the installation and maintenance of large database systems annually.</p><div class="calibre31"> </div>
<p class="calibre18">We can also classify a DBMS on the basis of the <strong class="calibre6">types of access path</strong> options for storing files. One well-known family of DBMSs is based on inverted file structures. Finally, a DBMS can be <strong class="calibre6">general purpose</strong> or <strong class="calibre6">special purpose</strong>. When performance is a primary consideration, a special-purpose DBMS can be designed and built for a specific application; such a system cannot be used for other applications without major changes. Many airline reservations and telephone directory systems developed in the past are special-purpose DBMSs. These fall into the category of <strong class="calibre6">online transaction processing</strong> (<strong class="calibre6">OLTP</strong>) systems, which must support a large number of concurrent transactions without imposing excessive delays.</p><div class="calibre31"> </div>
<p class="calibre18">Let us briefly elaborate on the main criterion for classifying DBMSs: the data model. The basic <strong class="calibre6">relational data model</strong> represents a database as a collection of tables, where each table can be stored as a separate file. The database in <a href="dummy_split_015.html#filepos107062" class="calibre41">Figure 1.2</a> resembles a relational representation. Most relational databases use the high-level query language called SQL and support a limited form of user views. We discuss the relational model and its languages and operations in <a href="dummy_split_018.html#filepos266551" class="calibre41">Chapters 3</a> through <a href="dummy_split_021.html#filepos533169" class="calibre41">6</a>, and techniques for programming relational applications in <a href="dummy_split_031.html#filepos1417305" class="calibre41">Chapters 13</a> and <a href="dummy_split_032.html#filepos1523831" class="calibre41">14</a>.</p><div class="calibre31"> </div>
<p class="calibre18">The <strong class="calibre6">object data model</strong> defines a database in terms of objects, their properties, and their operations. Objects with the same structure and behavior belong to a <strong class="calibre6">class</strong>, and classes are organized into <strong class="calibre6">hierarchies</strong> (or <strong class="calibre6">acyclic graphs</strong>). The operations of each class are specified in terms of predefined procedures called <strong class="calibre6">methods</strong>. Relational DBMSs have been extending their models to incorporate object database <a id="filepos251320" class="calibre3"></a>concepts and other capabilities; these systems are referred to as <strong class="calibre6">object-relational</strong> or <strong class="calibre6">extended relational systems</strong>. We discuss object databases and object-relational systems in <a href="dummy_split_028.html#filepos1161565" class="calibre41">Chapter 11</a>.</p><div class="calibre31"> </div>
<p class="calibre18">The <strong class="calibre6">XML model</strong> has emerged as a standard for exchanging data over the Web, and has been used as a basis for implementing several prototype native XML systems. XML uses hierarchical tree structures. It combines database concepts with concepts from document representation models. Data is represented as elements; with the use of tags, data can be nested to create complex hierarchical structures. This model conceptually resembles the object model but uses different terminology. XML capabilities have been added to many commercial DBMS products. We present an overview of XML in <a href="dummy_split_029.html#filepos1340308" class="calibre41">Chapter 12</a>.</p><div class="calibre31"> </div>
<p class="calibre18">Two older, historically important data models, now known as <strong class="calibre6">legacy data models</strong>, are the network and hierarchical models. The <strong class="calibre6">network model</strong> represents data as record types and also represents a limited type of 1:N relationship, called a <strong class="calibre6">set type</strong>. A 1:N, or one-to-many, relationship relates one instance of a record to many record instances using some pointer linking mechanism in these models. <a href="#filepos254273" class="calibre41">Figure 2.8</a> shows a network schema diagram for the database of <a href="#filepos192649" class="calibre41">Figure 2.1</a>, where record types are shown as rectangles and set types are shown as labeled directed arrows.</p><div class="calibre31"> </div>
<p class="calibre18">The network model, also known as the CODASYL DBTG model,<a id="filepos253103" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_077.html#filepos4341168" class="calibre41">14</a></sup> has an associated record-at-a-time language that must be embedded in a host programming language. The network DML was proposed in the 1971 Database Task Group (DBTG) Report as an extension of the COBOL language. It provides commands for locating records directly (e.g., FIND ANY &lt;record-type&gt; USING &lt;field-list&gt;, or FIND DUPLICATE &lt;record-type&gt; USING &lt;field-list&gt;). It has commands to support traversals within set-types (e.g., GET OWNER, GET {FIRST, NEXT, LAST} MEMBER WITHIN &lt;set-type&gt; WHERE &lt;condition&gt;). It also has commands to store new data <a id="filepos253746" class="calibre3"></a>(e.g., STORE &lt;record-type&gt;) and to make it part of a set type (e.g., CONNECT &lt;record-type&gt; TO &lt;set-type&gt;). The language also handles many additional considerations, such as the currency of record types and set types, which are defined by the current position of the navigation process within the database. It is prominently used by IDMS, IMAGE, and SUPRA DBMSs today.</p><div class="calibre31"> </div>
<p class="calibre7"><img alt="image" src="../images/00020.jpg" class="calibre16"/></p>
<p id="filepos254273" class="calibre58"><strong class="calibre6">Figure 2.8</strong><br class="calibre1"/>The schema of <a href="#filepos192649" class="calibre41">Figure 2.1</a> in network model notation.</p><div class="calibre31"> </div>
<p class="calibre18">The <strong class="calibre6">hierarchical model</strong> represents data as hierarchical tree structures. Each hierarchy represents a number of related records. There is no standard language for the hierarchical model. A popular hierarchical DML is DL/1 of the IMS system. It dominated the DBMS market for over 20 years between 1965 and 1985 and is still a widely used DBMS worldwide, holding a large percentage of data in governmental, health care, and banking and insurance databases. Its DML, called DL/1, was a de facto industry standard for a long time. DL/1 has commands to locate a record (e.g., GET { UNIQUE, NEXT} &lt;record-type&gt; WHERE &lt;condition&gt;). It has navigational facilities to navigate within hierarchies (e.g., GET NEXT WITHIN PARENT or GET {FIRST, NEXT} PATH &lt;hierarchical-path-specification&gt; WHERE &lt;condition&gt;). It has appropriate facilities to store and update records (e.g., INSERT &lt;record-type&gt;, REPLACE &lt;record-type&gt;). Currency issues during navigation are also handled with additional features in the language.<a id="filepos255519" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_078.html#filepos4341455" class="calibre41">15</a></sup></p><div class="calibre31"> </div>
<h4 id="filepos255595" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">2.7 Summary</span></span></blockquote></h4><div class="calibre31"> </div>
<p class="calibre18">In this chapter we introduced the main concepts used in database systems. We defined a data model and we distinguished three main categories:</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> High-level or conceptual data models (based on entities and relationships)</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> Low-level or physical data models</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> Representational or implementation data models (record-based, object-oriented)</p></blockquote>
<p class="calibre18">We distinguished the schema, or description of a database, from the database itself. The schema does not change very often, whereas the database state changes every time data is inserted, deleted, or modified. Then we described the three-schema DBMS architecture, which allows three schema levels:</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> An internal schema describes the physical storage structure of the database.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> A conceptual schema is a high-level description of the whole database.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> External schemas describe the views of different user groups.</p></blockquote>
<p class="calibre18">A DBMS that cleanly separates the three levels must have mappings between the schemas to transform requests and query results from one level to the next. Most DBMSs do not separate the three levels completely. We used the three-schema architecture to define the concepts of logical and physical data independence.</p><div class="calibre31"> </div>
<p class="calibre18"><a class="calibre3"></a>Then we discussed the main types of languages and interfaces that DBMSs support. A data definition language (DDL) is used to define the database conceptual schema. In most DBMSs, the DDL also defines user views and, sometimes, storage structures; in other DBMSs, separate languages or functions exist for specifying storage structures. This distinction is fading away in today’s relational implementations, with SQL serving as a catchall language to perform multiple roles, including view definition. The storage definition part (SDL) was included in SQL’s early versions, but is now typically implemented as special commands for the DBA in relational DBMSs. The DBMS compiles all schema definitions and stores their descriptions in the DBMS catalog.</p><div class="calibre31"> </div>
<p class="calibre18">A data manipulation language (DML) is used for specifying database retrievals and updates. DMLs can be high level (set-oriented, nonprocedural) or low level (record-oriented, procedural). A high-level DML can be embedded in a host programming language, or it can be used as a standalone language; in the latter case it is often called a query language.</p><div class="calibre31"> </div>
<p class="calibre18">We discussed different types of interfaces provided by DBMSs, and the types of DBMS users with which each interface is associated. Then we discussed the database system environment, typical DBMS software modules, and DBMS utilities for helping users and the DBA staff perform their tasks. We continued with an overview of the two-tier and three-tier architectures for database applications, progressively moving toward <em class="calibre13">n</em>-tier, which are now common in many applications, particularly Web database applications.</p><div class="calibre31"> </div>
<p class="calibre18">Finally, we classified DBMSs according to several criteria: data model, number of users, number of sites, types of access paths, and cost. We discussed the availability of DBMSs and additional modules—from no cost in the form of open source software, to configurations that annually cost millions to maintain. We also pointed out the variety of licensing arrangements for DBMS and related products. The main classification of DBMSs is based on the data model. We briefly discussed the main data models used in current commercial DBMSs.</p><div class="calibre31"> </div>
<h4 id="filepos260210" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">Review Questions</span></span></blockquote></h4><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">2.1.</strong> Define the following terms: <em class="calibre13">data model, database schema, database state, internal schema, conceptual schema, external schema, data independence, DDL, DML, SDL, VDL, query language, host language, data sublanguage, database utility, catalog, client/server architecture, three-tier architecture</em>, and n<em class="calibre13">-tier architecture</em>.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">2.2.</strong> Discuss the main categories of data models. What are the basic differences between the relational model, the object model, and the XML model?</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">2.3.</strong> What is the difference between a database schema and a database state?</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">2.4.</strong> Describe the three-schema architecture. Why do we need mappings between schema levels? How do different schema definition languages support this architecture?</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><a class="calibre3"></a><strong class="calibre6">2.5.</strong> What is the difference between logical data independence and physical data independence? Which one is harder to achieve? Why?</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">2.6.</strong> What is the difference between procedural and nonprocedural DMLs?</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">2.7.</strong> Discuss the different types of user-friendly interfaces and the types of users who typically use each.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">2.8.</strong> With what other computer system software does a DBMS interact?</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">2.9.</strong> What is the difference between the two-tier and three-tier client/server architectures?</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">2.10.</strong> Discuss some types of database utilities and tools and their functions.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">2.11.</strong> What is the additional functionality incorporated in <em class="calibre13">n</em>-tier architecture (<em class="calibre13">n</em> &gt; 3)?</p></blockquote><div class="calibre31"> </div>
<h4 id="filepos262848" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">Exercises</span></span></blockquote></h4><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">2.12.</strong> Think of different users for the database shown in <a href="dummy_split_015.html#filepos107062" class="calibre41">Figure 1.2</a>. What types of applications would each user need? To which user category would each belong, and what type of interface would each need?</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">2.13.</strong> Choose a database application with which you are familiar. Design a schema and show a sample database for that application, using the notation of <a href="dummy_split_015.html#filepos107062" class="calibre41">Figures 1.2</a> and <a href="#filepos192649" class="calibre41">2.1</a>. What types of additional information and constraints would you like to represent in the schema? Think of several users of your database, and design a view for each.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">2.14.</strong> If you were designing a Web-based system to make airline reservations and sell airline tickets, which DBMS architecture would you choose from Section 2.5? Why? Why would the other architectures not be a good choice?</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">2.15.</strong> Consider <a href="#filepos192649" class="calibre41">Figure 2.1</a>. In addition to constraints relating the values of columns in one table to columns in another table, there are also constraints that impose restrictions on values in a column or a combination of columns within a table. One such constraint dictates that a column or a group of columns must be unique across all rows in the table. For example, in the STUDENT table, the Student_number column must be unique (to prevent two different students from having the same Student_number). Identify the column or the group of columns in the other tables that must be unique across all rows in the table.</p></blockquote><div class="calibre31"> </div>
<h4 id="filepos264881" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1"><a class="calibre3"></a>Selected Bibliography</span></span></blockquote></h4><div class="calibre31"> </div>
<p class="calibre18">Many database textbooks, including Date (2004), Silberschatz et al. (2006), Ramakrishnan and Gehrke (2003), Garcia-Molina et al. (2000, 2009), and Abiteboul et al. (1995), provide a discussion of the various database concepts presented here. Tsichritzis and Lochovsky (1982) is an early textbook on data models. Tsichritzis and Klug (1978) and Jardine (1977) present the three-schema architecture, which was first suggested in the DBTG CODASYL report (1971) and later in an American National Standards Institute (ANSI) report (1975). An in-depth analysis of the relational data model and some of its possible extensions is given in Codd (1990). The proposed standard for object-oriented databases is described in Cattell et al. (2000). Many documents describing XML are available on the Web, such as XML (2005).</p><div class="calibre31"> </div>
<p class="calibre18">Examples of database utilities are the ETI Connect, Analyze and Transform tools (<span><span class="calibre42"><a href="http://www.eti.com" class="calibre41">http://www.eti.com</a></span></span>) and the database administration tool, DBArtisan, from Embarcadero Technologies (<span><span class="calibre42"><a href="http://www.embarcadero.com" class="calibre41">http://www.embarcadero.com</a></span></span>).</p><div class="calibre31"> </div>  <div class="mbppagebreak" id="calibre_pb_22"></div></body>
</html>
