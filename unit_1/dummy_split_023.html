<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
	<title>Fundamentals of Database Systems</title>
	<meta content="http://www.w3.org/1999/xhtml; charset=utf-8" http-equiv="Content-Type"/><link href="../stylesheet.css" type="text/css" rel="stylesheet"/><style type="text/css">
		@page { margin-bottom: 5.000000pt; margin-top: 5.000000pt; }</style></head>
  <body class="calibre">
<h3 id="filepos724415" class="calibre55"><span class="calibre47"><span class="bold"><a class="calibre35"></a><a id="filepos724496" class="calibre35"></a>chapter 7<br class="calibre54"/><br class="calibre54"/>Data Modeling Using the Entity-Relationship (ER) Model</span></span></h3><div class="calibre56"> </div>
<p class="calibre37">Conceptual modeling is a very important phase in designing a successful database application. Generally, the term <strong class="calibre6">database application</strong> refers to a particular database and the associated programs that implement the database queries and updates. For example, a BANK database application that keeps track of customer accounts would include programs that implement database updates corresponding to customer deposits and withdrawals. These programs provide user-friendly graphical user interfaces (GUIs) utilizing forms and menus for the end users of the application—the bank tellers, in this example. Hence, a major part of the database application will require the design, implementation, and testing of these application programs. Traditionally, the design and testing of <strong class="calibre6">application programs</strong> has been considered to be part of <em class="calibre13">software engineering</em> rather than <em class="calibre13">database design</em>. In many software design tools, the database design methodologies and software engineering methodologies are intertwined since these activities are strongly related.</p>
<p class="calibre18">In this chapter, we follow the traditional approach of concentrating on the database structures and constraints during conceptual database design. The design of application programs is typically covered in software engineering courses. We present the modeling concepts of the <strong class="calibre6">Entity-Relationship</strong> (<strong class="calibre6">ER</strong>) <strong class="calibre6">model</strong>, which is a popular high-level conceptual data model. This model and its variations are frequently used for the conceptual design of database applications, and many database design tools employ its concepts. We describe the basic data-structuring concepts and constraints of the ER model and discuss their use in the design of conceptual schemas for database applications. We also present the diagrammatic notation associated with the ER model, known as <strong class="calibre6">ER diagrams</strong>.</p><div class="calibre31"> </div>
<p class="calibre18"><a id="filepos726698" class="calibre3"></a>Object modeling methodologies such as the <strong class="calibre6">Unified Modeling Language</strong>(<strong class="calibre6">UML</strong>) are becoming increasingly popular in both database and software design. These methodologies go beyond database design to specify detailed design of software modules and their interactions using various types of diagrams. An important part of these methodologies—namely, <em class="calibre13">class diagrams</em>
<a id="filepos727112" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_125.html#filepos4354393" class="calibre41">1</a></sup>—are similar in many ways to the ER diagrams. In class diagrams, <em class="calibre13">operations</em> on objects are specified, in addition to specifying the database schema structure. Operations can be used to specify the <em class="calibre13">functional requirements</em> during database design, as we will discuss in Section 7.1. We present some of the UML notation and concepts for class diagrams that are particularly relevant to database design in Section 7.8, and briefly compare these to ER notation and concepts. Additional UML notation and concepts are presented in Section 8.6 and in <a href="dummy_split_026.html#filepos1020863" class="calibre41">Chapter 10</a>.</p><div class="calibre31"> </div>
<p class="calibre18">This chapter is organized as follows: Section 7.1 discusses the role of high-level conceptual data models in database design. We introduce the requirements for a sample database application in Section 7.2 to illustrate the use of concepts from the ER model. This sample database is also used throughout the book. In Section 7.3 we present the concepts of entities and attributes, and we gradually introduce the diagrammatic technique for displaying an ER schema. In Section 7.4 we introduce the concepts of binary relationships and their roles and structural constraints. Section 7.5 introduces weak entity types. Section 7.6 shows how a schema design is refined to include relationships. Section 7.7 reviews the notation for ER diagrams, summarizes the issues and common pitfalls that occur in schema design, and discusses how to choose the names for database schema constructs. Section 7.8 introduces some UML class diagram concepts, compares them to ER model concepts, and applies them to the same database example. Section 7.9 discusses more complex types of relationships. Section 7.10 summarizes the chapter.</p><div class="calibre31"> </div>
<p class="calibre18">The material in Sections 7.8 and 7.9 may be excluded from an introductory course. If a more thorough coverage of data modeling concepts and conceptual database design is desired, the reader should continue to <a href="dummy_split_024.html#filepos851508" class="calibre41">Chapter 8</a>, where we describe extensions to the ER model that lead to the Enhanced-ER (EER) model, which includes concepts such as specialization, generalization, inheritance, and union types (categories). We also introduce some additional UML concepts and notation in <a href="dummy_split_024.html#filepos851508" class="calibre41">Chapter 8</a>.</p><div class="calibre31"> </div>
<h4 id="filepos729560" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">7.1 Using High-Level Conceptual Data Models for Database Design</span></span></blockquote></h4><div class="calibre31"> </div>
<p class="calibre18"><a href="#filepos731011" class="calibre41">Figure 7.1</a> shows a simplified overview of the database design process. The first step shown is <strong class="calibre6">requirements collection and analysis</strong>. During this step, the database designers interview prospective database users to understand and document their <strong class="calibre6">data requirements</strong>. The result of this step is a concisely written set of users’ requirements. These requirements should be specified in as detailed and complete a form as possible. In parallel with specifying the data requirements, it is useful to specify the known <strong class="calibre6">functional requirements</strong> of the application. These consist of the user-defined <strong class="calibre6">operations</strong> (or <strong class="calibre6">transactions</strong>) that will be applied to the database, including both retrievals and updates. In software design, it is common to use <em class="calibre13">data flow diagrams</em>, <em class="calibre13">sequence diagrams</em>, <em class="calibre13">scenarios</em>, and other techniques to specify functional requirements. We will not discuss any of these techniques here; they are usually described in detail in software engineering texts. We give an overview of some of these techniques in <a href="dummy_split_026.html#filepos1020863" class="calibre41">Chapter 10</a>.</p><div class="calibre31"> </div>
<p id="filepos731011" class="calibre7"><a id="filepos731042" class="calibre3"></a><img alt="image" src="../images/00153.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 7.1</strong><br class="calibre1"/>A simplified diagram to illustrate the main phases of database design.</p><div class="calibre31"> </div>
<p class="calibre18">Once the requirements have been collected and analyzed, the next step is to create a <strong class="calibre6">conceptual schema</strong> for the database, using a high-level conceptual data model. This step is called <strong class="calibre6">conceptual design</strong>. The conceptual schema is a concise description of <a id="filepos731579" class="calibre3"></a>the data requirements of the users and includes detailed descriptions of the entity types, relationships, and constraints; these are expressed using the concepts provided by the high-level data model. Because these concepts do not include implementation details, they are usually easier to understand and can be used to communicate with nontechnical users. The high-level conceptual schema can also be used as a reference to ensure that all users’ data requirements are met and that the requirements do not conflict. This approach enables database designers to concentrate on specifying the properties of the data, without being concerned with storage and implementation details. This makes it is easier to create a good conceptual database design.</p><div class="calibre31"> </div>
<p class="calibre18">During or after the conceptual schema design, the basic data model operations can be used to specify the high-level user queries and operations identified during functional analysis. This also serves to confirm that the conceptual schema meets all the identified functional requirements. Modifications to the conceptual schema can be introduced if some functional requirements cannot be specified using the initial schema.</p><div class="calibre31"> </div>
<p class="calibre18">The next step in database design is the actual implementation of the database, using a commercial DBMS. Most current commercial DBMSs use an implementation data model—such as the relational or the object-relational database model—so the conceptual schema is transformed from the high-level data model into the implementation data model. This step is called <strong class="calibre6">logical design</strong> or <strong class="calibre6">data model mapping</strong>; its result is a database schema in the implementation data model of the DBMS. Data model mapping is often automated or semiautomated within the database design tools.</p><div class="calibre31"> </div>
<p class="calibre18">The last step is the <strong class="calibre6">physical design</strong> phase, during which the internal storage structures, file organizations, indexes, access paths, and physical design parameters for the database files are specified. In parallel with these activities, application programs are designed and implemented as database transactions corresponding to the high-level transaction specifications. We discuss the database design process in more detail in <a href="dummy_split_026.html#filepos1020863" class="calibre41">Chapter 10</a>.</p><div class="calibre31"> </div>
<p class="calibre18">We present only the basic ER model concepts for conceptual schema design in this chapter. Additional modeling concepts are discussed in <a href="dummy_split_024.html#filepos851508" class="calibre41">Chapter 8</a>, when we introduce the EER model.</p><div class="calibre31"> </div>
<h4 id="filepos734316" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">7.2 A Sample Database Application</span></span></blockquote></h4><div class="calibre31"> </div>
<p class="calibre18">In this section we describe a sample database application, called COMPANY, which serves to illustrate the basic ER model concepts and their use in schema design. We list the data requirements for the database here, and then create its conceptual schema step-by-step as we introduce the modeling concepts of the ER model. The COMPANY database keeps track of a company’s employees, departments, and projects. Suppose that after the requirements collection and analysis phase, the database designers provide the following description of the <em class="calibre13">miniworld</em>—the part of the company that will be represented in the database.</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40"><a id="filepos735219" class="calibre3"></a><img alt="image" src="../images/00003.jpg" class="calibre16"/> The company is organized into departments. Each department has a unique name, a unique number, and a particular employee who manages the department. We keep track of the start date when that employee began managing the department. A department may have several locations.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> A department controls a number of projects, each of which has a unique name, a unique number, and a single location.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> We store each employee’s name, Social Security number,<a id="filepos735962" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_126.html#filepos4354600" class="calibre41">2</a></sup> address, salary, sex (gender), and birth date. An employee is assigned to one department, but may work on several projects, which are not necessarily controlled by the same department. We keep track of the current number of hours per week that an employee works on each project. We also keep track of the direct supervisor of each employee (who is another employee).</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> We want to keep track of the dependents of each employee for insurance purposes. We keep each dependent’s first name, sex, birth date, and relationship to the employee.</p></blockquote>
<p class="calibre18"><a href="#filepos738906" class="calibre41">Figure 7.2</a> shows how the schema for this database application can be displayed by means of the graphical notation known as <strong class="calibre6">ER diagrams</strong>. This figure will be explained gradually as the ER model concepts are presented. We describe the step-by-step process of deriving this schema from the stated requirements—and explain the ER diagrammatic notation—as we introduce the ER model concepts.</p><div class="calibre31"> </div>
<h4 id="filepos737213" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">7.3 Entity Types, Entity Sets, Attributes, and Keys</span></span></blockquote></h4><div class="calibre31"> </div>
<p class="calibre18">The ER model describes data as <em class="calibre13">entities</em>, <em class="calibre13">relationships</em>, and <em class="calibre13">attributes</em>. In Section 7.3.1 we introduce the concepts of entities and their attributes. We discuss entity types and key attributes in Section 7.3.2. Then, in Section 7.3.3, we specify the initial conceptual design of the entity types for the COMPANY database. Relationships are described in Section 7.4.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">7.3.1 Entities and Attributes</span></span></blockquote></h5>
<p class="calibre18"><strong class="calibre6">Entities and Their Attributes.</strong> The basic object that the ER model represents is an <strong class="calibre6">entity</strong>, which is a <em class="calibre13">thing</em> in the real world with an independent existence. An entity may be an object with a physical existence (for example, a particular person, car, house, or employee) or it may be an object with a conceptual existence (for instance, a company, a job, or a university course). Each entity has <strong class="calibre6">attributes</strong>—the particular properties that describe it. For example, an EMPLOYEE entity may be described by the employee’s name, age, address, salary, and job. A particular entity will have a <a class="calibre3"></a>value for each of its attributes. The attribute values that describe each entity become a major part of the data stored in the database.</p><div class="calibre31"> </div>
<p class="calibre7"><a id="filepos738906" class="calibre3"></a><img alt="image" src="../images/00154.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 7.2</strong><br class="calibre1"/>An ER schema diagram for the COMPANY database. The diagrammatic notation is introduced gradually throughout this chapter and is summarized in <a href="#filepos793480" class="calibre41">Figure 7.14</a>.</p><div class="calibre31"> </div>
<p class="calibre18"><a href="#filepos740254" class="calibre41">Figure 7.3</a> shows two entities and the values of their attributes. The EMPLOYEE entity <em class="calibre13">e</em><sub class="calibre65">1</sub> has four attributes: Name, Address, Age, and Home_phone; their values are ‘John Smith,’ ‘2311 Kirby, Houston, Texas 77001’, ‘55’, and ‘713-749-2630’, respectively. The COMPANY entity <em class="calibre13">c</em><sub class="calibre65">1</sub> has three attributes: Name, Headquarters, and President; their values are ‘Sunco Oil’, ‘Houston’, and ‘John Smith’, respectively.</p><div class="calibre31"> </div>
<p class="calibre18">Several types of attributes occur in the ER model: <em class="calibre13">simple</em> versus <em class="calibre13">composite</em>, <em class="calibre13">single-valued</em> versus <em class="calibre13">multivalued</em>, and <em class="calibre13">stored</em> versus <em class="calibre13">derived</em>. First we define these attribute <a id="filepos740103" class="calibre3"></a>types and illustrate their use via examples. Then we discuss the concept of a <em class="calibre13">NULL value</em> for an attribute.</p><div class="calibre31"> </div>
<p id="filepos740254" class="calibre7"><img alt="image" src="../images/00155.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 7.3</strong><br class="calibre1"/>Two entities, EMPLOYEE <em class="calibre13">e</em><sub class="calibre65">1</sub>, and COMPANY <em class="calibre13">c</em><sub class="calibre65">1</sub>, and their attributes.</p><div class="calibre31"> </div>
<p class="calibre18"><strong class="calibre6">Composite versus Simple (Atomic) Attributes. Composite attributes</strong> can be divided into smaller subparts, which represent more basic attributes with independent meanings. For example, the Address attribute of the EMPLOYEE entity shown in <a href="#filepos740254" class="calibre41">Figure 7.3</a> can be subdivided into Street_address, City, State, and Zip,<a id="filepos740914" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_127.html#filepos4355013" class="calibre41">3</a></sup> with the values ‘2311 Kirby’, ‘Houston’, ‘Texas’, and ‘77001.’ Attributes that are not divisible are called <strong class="calibre6">simple</strong> or <strong class="calibre6">atomic attributes</strong>. Composite attributes can form a hierarchy; for example, Street_address can be further subdivided into three simple component attributes: Number, Street, and Apartment_number, as shown in <a href="#filepos742105" class="calibre41">Figure 7.4</a>. The value of a composite attribute is the concatenation of the values of its component simple attributes.</p><div class="calibre31"> </div>
<p class="calibre18">Composite attributes are useful to model situations in which a user sometimes refers to the composite attribute as a unit but at other times refers specifically to its components. If the composite attribute is referenced only as a whole, there is no need to subdivide it into component attributes. For example, if there is no need to refer to the individual components of an address (Zip Code, street, and so on), then the whole address can be designated as a simple attribute.</p><div class="calibre31"> </div>
<p class="calibre7"><a id="filepos742105" class="calibre3"></a><img alt="image" src="../images/00156.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 7.4</strong><br class="calibre1"/>A hierarchy of composite attributes.</p><div class="calibre31"> </div>
<p class="calibre18"><a id="filepos742322" class="calibre3"></a><strong class="calibre6">Single-Valued versus Multivalued Attributes.</strong> Most attributes have a single value for a particular entity; such attributes are called <strong class="calibre6">single-valued</strong>. For example, Age is a single-valued attribute of a person. In some cases an attribute can have a set of values for the same entity—for instance, a Colors attribute for a car, or a College_degrees attribute for a person. Cars with one color have a single value, whereas two-tone cars have two color values. Similarly, one person may not have a college degree, another person may have one, and a third person may have two or more degrees; therefore, different people can have different <em class="calibre13">numbers</em> of <em class="calibre13">values</em> for the College_degrees attribute. Such attributes are called <strong class="calibre6">multivalued</strong>. A multivalued attribute may have lower and upper bounds to constrain the <em class="calibre13">number of values</em> allowed for each individual entity. For example, the Colors attribute of a car may be restricted to have between one and three values, if we assume that a car can have three colors at most.</p><div class="calibre31"> </div>
<p class="calibre18"><strong class="calibre6">Stored versus Derived Attributes.</strong> In some cases, two (or more) attribute values are related—for example, the Age and Birth_date attributes of a person. For a particular person entity, the value of Age can be determined from the current (today’s) date and the value of that person’s Birth_date. The Age attribute is hence called a <strong class="calibre6">derived attribute</strong> and is said to be <strong class="calibre6">derivable from</strong> the Birth_date attribute, which is called a <strong class="calibre6">stored attribute</strong>. Some attribute values can be derived from <em class="calibre13">related entities</em>; for example, an attribute Number_of_employees of a DEPARTMENT entity can be derived by counting the number of employees related to (working for) that department.</p><div class="calibre31"> </div>
<p class="calibre18"><strong class="calibre6">NULL Values.</strong> In some cases, a particular entity may not have an applicable value for an attribute. For example, the Apartment_number attribute of an address applies only to addresses that are in apartment buildings and not to other types of residences, such as single-family homes. Similarly, a College_degrees attribute applies only to people with college degrees. For such situations, a special value called NULL is created. An address of a single-family home would have NULL for its Apartment_number attribute, and a person with no college degree would have NULL for College_degrees. NULL can also be used if we do not know the value of an attribute for a particular entity—for example, if we do not know the home phone number of ‘John Smith’ in <a href="#filepos740254" class="calibre41">Figure 7.3</a>. The meaning of the former type of NULL is <em class="calibre13">not applicable</em>, whereas the meaning of the latter is <em class="calibre13">unknown</em>. The <em class="calibre13">unknown</em> category of NULL can be further classified into two cases. The first case arises when it is known that the attribute value exists but is <em class="calibre13">missing</em>—for instance, if the Height attribute of a person is listed as NULL. The second case arises when it is <em class="calibre13">not known</em> whether the attribute value exists—for example, if the Home_phone attribute of a person is NULL.</p><div class="calibre31"> </div>
<p class="calibre18"><strong class="calibre6">Complex Attributes.</strong> Notice that, in general, composite and multivalued attributes can be nested arbitrarily. We can represent arbitrary nesting by grouping components <a id="filepos745881" class="calibre3"></a>of a composite attribute between parentheses () and separating the components with commas, and by displaying multivalued attributes between braces { }. Such attributes are called <strong class="calibre6">complex attributes</strong>. For example, if a person can have more than one residence and each residence can have a single address and multiple phones, an attribute Address_phone for a person can be specified as shown in <a href="#filepos747923" class="calibre41">Figure 7.5</a>.<a id="filepos746335" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_128.html#filepos4355336" class="calibre41">4</a></sup> Both Phone and Address are themselves composite attributes.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">7.3.2 Entity Types, Entity Sets, Keys, and Value Sets</span></span></blockquote></h5>
<p class="calibre18"><strong class="calibre6">Entity Types and Entity Sets.</strong> A database usually contains groups of entities that are similar. For example, a company employing hundreds of employees may want to store similar information concerning each of the employees. These employee entities share the same attributes, but each entity has its <em class="calibre13">own value</em>(<em class="calibre13">s</em>) for each attribute. An <strong class="calibre6">entity type</strong> defines a <em class="calibre13">collection</em> (or <em class="calibre13">set</em>) of entities that have the same attributes. Each entity type in the database is described by its name and attributes. <a href="#filepos748206" class="calibre41">Figure 7.6</a> shows two entity types: EMPLOYEE and COMPANY, and a list of some of the attributes for each. A few individual entities of each type are also illustrated, along with the values of their attributes. The collection of all entities of a particular entity type in the database at any point in time is called an <strong class="calibre6">entity set</strong>; the entity set is usually referred to using the same name as the entity type. For example, EMPLOYEE refers to both a <em class="calibre13">type of entity</em> as well as the current set <em class="calibre13">of all employee entities</em> in the database.</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><a id="filepos747923" class="calibre3"></a>{Address_phone( {Phone(Area_code,Phone_number)},Address(Street_address (Number,Street,Apartment_number),City,State,Zip) )}</p></blockquote><div class="calibre31"> </div>
<p class="calibre58"><strong class="calibre6">Figure 7.5</strong><br class="calibre1"/>A complex attribute: Address_phone.</p><div class="calibre31"> </div>
<p id="filepos748206" class="calibre7"><img alt="image" src="../images/00157.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 7.6</strong><br class="calibre1"/>Two entity types, EMPLOYEE and COMPANY, and some member entities of each.</p><div class="calibre31"> </div>
<p class="calibre18"><a id="filepos748484" class="calibre3"></a>An entity type is represented in ER diagrams<a id="filepos748535" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_129.html#filepos4355591" class="calibre41">5</a></sup> (see <a href="#filepos738906" class="calibre41">Figure 7.2</a>) as a rectangular box enclosing the entity type name. Attribute names are enclosed in ovals and are attached to their entity type by straight lines. Composite attributes are attached to their component attributes by straight lines. Multivalued attributes are displayed in double ovals. <a href="#filepos750885" class="calibre41">Figure 7.7(a)</a> shows a CAR entity type in this notation.</p><div class="calibre31"> </div>
<p class="calibre18">An entity type describes the <strong class="calibre6">schema</strong> or <strong class="calibre6">intension</strong> for a <em class="calibre13">set of entities</em> that share the same structure. The collection of entities of a particular entity type is grouped into an entity set, which is also called the <strong class="calibre6">extension</strong> of the entity type.</p><div class="calibre31"> </div>
<p class="calibre18"><strong class="calibre6">Key Attributes of an Entity Type.</strong> An important constraint on the entities of an entity type is the <strong class="calibre6">key</strong> or <strong class="calibre6">uniqueness constraint</strong> on attributes. An entity type usually has one or more attributes whose values are distinct for each individual entity in the entity set. Such an attribute is called a <strong class="calibre6">key attribute</strong>, and its values can be used to identify each entity uniquely. For example, the Name attribute is a key of the COMPANY entity type in <a href="#filepos748206" class="calibre41">Figure 7.6</a> because no two companies are allowed to have the same name. For the PERSON entity type, a typical key attribute is Ssn (Social Security number). Sometimes several attributes together form a key, meaning that the <em class="calibre13">combination</em> of the attribute values must be distinct for each entity. If a set of attributes possesses this property, the proper way to represent this in the ER model that we describe here is to define a <em class="calibre13">composite attribute</em> and designate it as a key attribute of the entity type. Notice that such a composite key must be <em class="calibre13">minimal</em>; that is, all component attributes must be included in the composite attribute to have the uniqueness property. Superfluous attributes must not be included in a key. In ER diagrammatic notation, each key attribute has its name <strong class="calibre6">underlined</strong> inside the oval, as illustrated in <a href="#filepos750885" class="calibre41">Figure 7.7(a)</a>.</p><div class="calibre31"> </div>
<p id="filepos750885" class="calibre7"><img alt="image" src="../images/00158.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 7.7</strong><br class="calibre1"/>The CAR entity type with two key attributes, Registration and Vehicle_id. (a) ER diagram notation. (b) Entity set with three entities.</p><div class="calibre31"> </div>
<p class="calibre18"><a id="filepos751224" class="calibre3"></a>Specifying that an attribute is a key of an entity type means that the preceding uniqueness property must hold for <em class="calibre13">every entity set</em> of the entity type. Hence, it is a constraint that prohibits any two entities from having the same value for the key attribute at the same time. It is not the property of a particular entity set; rather, it is a constraint on <em class="calibre13">any entity set</em> of the entity type at any point in time. This key constraint (and other constraints we discuss later) is derived from the constraints of the miniworld that the database represents.</p><div class="calibre31"> </div>
<p class="calibre18">Some entity types have <em class="calibre13">more than one</em> key attribute. For example, each of the Vehicle_id and Registration attributes of the entity type CAR (<a href="#filepos750885" class="calibre41">Figure 7.7</a>) is a key in its own right. The Registration attribute is an example of a composite key formed from two simple component attributes, State and Number, neither of which is a key on its own. An entity type may also have <em class="calibre13">no key</em>, in which case it is called a <em class="calibre13">weak entity type</em> (see Section 7.5).</p><div class="calibre31"> </div>
<p class="calibre18">In our diagrammatic notation, if two attributes are underlined separately, then <em class="calibre13">each is a key on its own</em>. Unlike the relational model (see Section 3.2.2), there is no concept of primary key in the ER model that we present here; the primary key will be chosen during mapping to a relational schema (see <a href="dummy_split_025.html#filepos971294" class="calibre41">Chapter 9</a>).</p><div class="calibre31"> </div>
<p class="calibre18"><strong class="calibre6">Value Sets (Domains) of Attributes.</strong> Each simple attribute of an entity type is associated with a <strong class="calibre6">value set</strong> (or <strong class="calibre6">domain</strong> of values), which specifies the set of values that may be assigned to that attribute for each individual entity. In <a href="#filepos748206" class="calibre41">Figure 7.6</a>, if the range of ages allowed for employees is between 16 and 70, we can specify the value set of the Age attribute of EMPLOYEE to be the set of integer numbers between 16 and 70. Similarly, we can specify the value set for the Name attribute to be the set of strings of alphabetic characters separated by blank characters, and so on. Value sets are not displayed in ER diagrams, and are typically specified using the basic <strong class="calibre6">data types</strong> available in most programming languages, such as integer, string, Boolean, float, enumerated type, subrange, and so on. Additional data types to represent common database types such as date, time, and other concepts are also employed.</p><div class="calibre31"> </div>
<p class="calibre18"><a id="filepos753883" class="calibre3"></a>Mathematically, an attribute <em class="calibre13">A</em> of entity set <em class="calibre13">E</em> whose value set is <em class="calibre13">V</em> can be defined as a <strong class="calibre6">function</strong> from <em class="calibre13">E</em> to the power set<a id="filepos754063" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_130.html#filepos4355979" class="calibre41">6</a></sup><em class="calibre13">P</em>(<em class="calibre13">V</em>) of <em class="calibre13">V</em>:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><em class="calibre13">A</em> : <em class="calibre13">E</em> → <em class="calibre13">P</em>(<em class="calibre13">V</em>)</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">We refer to the value of attribute <em class="calibre13">A</em> for entity <em class="calibre13">e</em> as <em class="calibre13">A</em>(<em class="calibre13">e</em>). The previous definition covers both single-valued and multivalued attributes, as well as NULLs. A NULL value is represented by the <em class="calibre13">empty set</em>. For single-valued attributes, <em class="calibre13">A</em>(<em class="calibre13">e</em>) is restricted to being a <em class="calibre13">singleton set</em> for each entity <em class="calibre13">e</em> in <em class="calibre13">E</em>, whereas there is no restriction on multivalued attributes.<a id="filepos754799" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_131.html#filepos4356224" class="calibre41">7</a></sup> For a composite attribute <em class="calibre13">A</em>, the value set <em class="calibre13">V</em> is the power set of the Cartesian product of <em class="calibre13">P</em>(<em class="calibre13">V</em><sub class="calibre65">1</sub>), <em class="calibre13">P</em>(<em class="calibre13">V</em><sub class="calibre65">2</sub>), ..., <em class="calibre13">P</em>(<em class="calibre13">V<sub class="calibre65">n</sub></em>), where <em class="calibre13">V</em><sub class="calibre65">1</sub>, <em class="calibre13">V</em><sub class="calibre65">2</sub>, ..., <em class="calibre13">V<sub class="calibre65">n</sub></em> are the value sets of the simple component attributes that form <em class="calibre13">A</em>:</p><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18"><em class="calibre13">V</em> = <em class="calibre13">P</em>(<em class="calibre13">P</em>(<em class="calibre13">V</em><sub class="calibre65">1</sub>) × <em class="calibre13">P</em>(<em class="calibre13">V</em><sub class="calibre65">2</sub>) × ...× <em class="calibre13">P</em>(<em class="calibre13">V<sub class="calibre65">n</sub></em>))</p></blockquote><div class="calibre31"> </div>
<p class="calibre18">The value set provides all possible values. Usually only a small number of these values exist in the database at a particular time. Those values represent the data from the current state of the miniworld. They correspond to the data as it actually exists in the miniworld.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">7.3.3 Initial Conceptual Design of the COMPANY Database</span></span></blockquote></h5>
<p class="calibre18">We can now define the entity types for the COMPANY database, based on the requirements described in Section 7.2. After defining several entity types and their attributes here, we refine our design in Section 7.4 after we introduce the concept of a relationship. According to the requirements listed in Section 7.2, we can identify four entity types—one corresponding to each of the four items in the specification (see <a href="#filepos757852" class="calibre41">Figure 7.8</a>):</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40"><strong class="calibre6">1.</strong> An entity type DEPARTMENT with attributes Name, Number, Locations, Manager, and Manager_start_date. Locations is the only multivalued attribute. We can specify that both Name and Number are (separate) key attributes because each was specified to be unique.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><strong class="calibre6">2.</strong> An entity type PROJECT with attributes Name, Number, Location, and Controlling_department. Both Name and Number are (separate) key attributes.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><strong class="calibre6">3.</strong> An entity type EMPLOYEE with attributes Name, Ssn, Sex, Address, Salary, Birth_date, Department, and Supervisor. Both Name and Address may be composite attributes; however, this was not specified in the requirements. We must go back to the users to see if any of them will refer to the individual components of Name—First_name, Middle_initial, Last_name—or of Address.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><strong class="calibre6">4.</strong> An entity type DEPENDENT with attributes Employee, Dependent_name, Sex, Birth_date, and Relationship (to the employee).</p></blockquote>
<p id="filepos757852" class="calibre7"><a class="calibre3"></a><img alt="image" src="../images/00159.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 7.8</strong><br class="calibre1"/>Preliminary design of entity types for the COMPANY database. Some of the shown attributes will be refined into relationships.</p><div class="calibre31"> </div>
<p class="calibre18">So far, we have not represented the fact that an employee can work on several projects, nor have we represented the number of hours per week an employee works on each project. This characteristic is listed as part of the third requirement in Section 7.2, and it can be represented by a multivalued composite attribute of EMPLOYEE called Works_on with the simple components (Project, Hours). Alternatively, it can be represented as a multivalued composite attribute of PROJECT called Workers with the simple components (Employee, Hours). We choose the first alternative in <a href="#filepos757852" class="calibre41">Figure 7.8</a>, which shows each of the entity types just described. The Name attribute of EMPLOYEE is shown as a composite attribute, presumably after consultation with the users.</p><div class="calibre31"> </div>
<h4 id="filepos758993" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1"><a id="filepos759077" class="calibre3"></a>7.4 Relationship Types, Relationship Sets, Roles, and Structural Constraints</span></span></blockquote></h4><div class="calibre31"> </div>
<p class="calibre18">In <a href="#filepos757852" class="calibre41">Figure 7.8</a> there are several <em class="calibre13">implicit relationships</em> among the various entity types. In fact, whenever an attribute of one entity type refers to another entity type, some relationship exists. For example, the attribute Manager of DEPARTMENT refers to an employee who manages the department; the attribute Controlling_department of PROJECT refers to the department that controls the project; the attribute Supervisor of EMPLOYEE refers to another employee (the one who supervises this employee); the attribute Department of EMPLOYEE refers to the department for which the employee works; and so on. In the ER model, these references should not be represented as attributes but as <strong class="calibre6">relationships</strong>, which are discussed in this section. The COMPANY database schema will be refined in Section 7.6 to represent relationships explicitly. In the initial design of entity types, relationships are typically captured in the form of attributes. As the design is refined, these attributes get converted into relationships between entity types.</p><div class="calibre31"> </div>
<p class="calibre18">This section is organized as follows: Section 7.4.1 introduces the concepts of relationship types, relationship sets, and relationship instances. We define the concepts of relationship degree, role names, and recursive relationships in Section 7.4.2, and then we discuss structural constraints on relationships—such as cardinality ratios and existence dependencies—in Section 7.4.3. Section 7.4.4 shows how relationship types can also have attributes.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">7.4.1 Relationship Types, Sets, and Instances</span></span></blockquote></h5>
<p class="calibre18">A <strong class="calibre6">relationship type</strong>
<em class="calibre13">R</em> among <em class="calibre13">n</em> entity types <em class="calibre13">E</em><sub class="calibre65">1</sub>, <em class="calibre13">E</em><sub class="calibre65">2</sub>, ..., <em class="calibre13">E<sub class="calibre65">n</sub></em> defines a set of associations—or a <strong class="calibre6">relationship set</strong>—among entities from these entity types. As for the case of entity types and entity sets, a relationship type and its corresponding relationship set are customarily referred to by the <em class="calibre13">same name</em>, <em class="calibre13">R</em>. Mathematically, the relationship set <em class="calibre13">R</em> is a set of <strong class="calibre6">relationship instances</strong>
<em class="calibre13">r<sub class="calibre65">i</sub></em>, where each <em class="calibre13">r<sub class="calibre65">i</sub></em> associates <em class="calibre13">n</em> individual entities (<em class="calibre13">e</em><sub class="calibre65">1</sub>, <em class="calibre13">e</em><sub class="calibre65">2</sub>, ..., <em class="calibre13">e<sub class="calibre65">n</sub></em>), and each entity <em class="calibre13">e<sub class="calibre65">j</sub></em> in <em class="calibre13">r<sub class="calibre65">i</sub></em> is a member of entity set <em class="calibre13">E<sub class="calibre65">j</sub></em>, 1 ≤ <em class="calibre13">j</em> ≤ <em class="calibre13">n</em>. Hence, a relationship set is a mathematical relation on <em class="calibre13">E</em><sub class="calibre65">1</sub>, <em class="calibre13">E</em><sub class="calibre65">2</sub>, ..., <em class="calibre13">E<sub class="calibre65">n</sub></em>; alternatively, it can be defined as a subset of the Cartesian product of the entity sets <em class="calibre13">E</em><sub class="calibre65">1</sub> × <em class="calibre13">E</em><sub class="calibre65">2</sub> × ... × <em class="calibre13">E<sub class="calibre65">n</sub></em>. Each of the entity types <em class="calibre13">E</em><sub class="calibre65">1</sub>, <em class="calibre13">E</em><sub class="calibre65">2</sub>, ..., <em class="calibre13">E<sub class="calibre65">n</sub></em> is said to participate in the relationship type <em class="calibre13">R</em>; similarly, each of the individual entities <em class="calibre13">e</em><sub class="calibre65">1</sub>, <em class="calibre13">e</em><sub class="calibre65">2</sub>, ..., <em class="calibre13">e<sub class="calibre65">n</sub></em> is said to <strong class="calibre6">participate</strong> in the relationship instance <em class="calibre13">r<sub class="calibre65">i</sub></em> = (<em class="calibre13">e</em><sub class="calibre65">1</sub>, <em class="calibre13">e</em><sub class="calibre65">2</sub>, ..., <em class="calibre13">e<sub class="calibre65">n</sub></em>).</p><div class="calibre31"> </div>
<p class="calibre18">Informally, each relationship instance <em class="calibre13">r<sub class="calibre65">i</sub></em> in <em class="calibre13">R</em> is an association of entities, where the association includes exactly one entity from each participating entity type. Each such relationship instance <em class="calibre13">r<sub class="calibre65">i</sub></em> represents the fact that the entities participating in <em class="calibre13">r<sub class="calibre65">i</sub></em> are related in some way in the corresponding miniworld situation. For example, consider a relationship type WORKS_FOR between the two entity types EMPLOYEE and DEPARTMENT, which associates each employee with the department for which the employee works in the corresponding entity set. Each relationship instance in the relationship set WORKS_FOR associates one EMPLOYEE entity and one DEPARTMENT entity. <a href="#filepos764190" class="calibre41">Figure 7.9</a> illustrates this example, where each relationship instance <em class="calibre13">r<sub class="calibre65">i</sub></em> is shown connected to the EMPLOYEE and DEPARTMENT entities that participate in <em class="calibre13">r<sub class="calibre65">i</sub></em> In the miniworld represented by <a href="#filepos764190" class="calibre41">Figure 7.9</a>, employees <em class="calibre13">e</em><sub class="calibre65">1</sub>, <em class="calibre13">e</em><sub class="calibre65">3</sub>, and <em class="calibre13">e</em><sub class="calibre65">6</sub> work for department <em class="calibre13">d</em><sub class="calibre65">1</sub>; employees <em class="calibre13">e</em><sub class="calibre65">2</sub> and <em class="calibre13">e</em><sub class="calibre65">4</sub> work for department <em class="calibre13">d</em><sub class="calibre65">2</sub>; and employees <em class="calibre13">e</em><sub class="calibre65">5</sub> and <em class="calibre13">e</em><sub class="calibre65">7</sub> work for department <em class="calibre13">d</em><sub class="calibre65">3</sub>.</p><div class="calibre31"> </div>
<p id="filepos764190" class="calibre7"><a id="filepos764221" class="calibre3"></a><img alt="image" src="../images/00160.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 7.9</strong><br class="calibre1"/>Some instances in the WORKS_FOR relationship set, which represents a relationship type WORKS_FOR between EMPLOYEE and DEPARTMENT.</p><div class="calibre31"> </div>
<p class="calibre18">In ER diagrams, relationship types are displayed as diamond-shaped boxes, which are connected by straight lines to the rectangular boxes representing the participating entity types. The relationship name is displayed in the diamond-shaped box (see <a href="#filepos738906" class="calibre41">Figure 7.2</a>).</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">7.4.2 Relationship Degree, Role Names, and Recursive Relationships</span></span></blockquote></h5>
<p class="calibre18"><strong class="calibre6">Degree of a Relationship Type.</strong> The <strong class="calibre6">degree</strong> of a relationship type is the number of participating entity types. Hence, the WORKS_FOR relationship is of degree two. A relationship type of degree two is called <strong class="calibre6">binary</strong>, and one of degree three is called <strong class="calibre6">ternary</strong>. An example of a ternary relationship is SUPPLY, shown in <a href="#filepos765982" class="calibre41">Figure 7.10</a>, where each relationship instance <em class="calibre13">r<sub class="calibre65">i</sub></em> associates three entities—a supplier <em class="calibre13">s</em>, a part <em class="calibre13">p</em>, and a project <em class="calibre13">j</em>—whenever <em class="calibre13">s</em> supplies part <em class="calibre13">p</em> to project <em class="calibre13">j</em>. Relationships can generally be of any degree, but the ones most common are binary relationships. Higher degree relationships are generally more complex than binary relationships; we characterize them further in Section 7.9.</p><div class="calibre31"> </div>
<p id="filepos765982" class="calibre7"><a id="filepos766013" class="calibre3"></a><img alt="image" src="../images/00161.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 7.10</strong><br class="calibre1"/>Some relationship instances in the SUPPLY ternary relationship set.</p><div class="calibre31"> </div>
<p class="calibre18"><strong class="calibre6">Relationships as Attributes.</strong> It is sometimes convenient to think of a binary relationship type in terms of attributes, as we discussed in Section 7.3.3. Consider the WORKS_FOR relationship type in <a href="#filepos764190" class="calibre41">Figure 7.9</a>. One can think of an attribute called Department of the EMPLOYEE entity type, where the value of Department for each EMPLOYEE entity is (a reference to) the DEPARTMENT entity for which that employee works. Hence, the value set for this Department attribute is the set of <em class="calibre13">all</em> DEPARTMENT entities, which is the DEPARTMENT entity set. This is what we did in <a href="#filepos757852" class="calibre41">Figure 7.8</a> when we specified the initial design of the entity type EMPLOYEE for the COMPANY database. However, when we think of a binary relationship as an attribute, we always have two options. In this example, the alternative is to think of a multivalued attribute Employee of the entity type DEPARTMENT whose values for each DEPARTMENT entity is the set of EMPLOYEE entities who work for that department. The value set of this Employee attribute is the power set of the EMPLOYEE entity set. Either of these two attributes—Department of EMPLOYEE or Employee of DEPARTMENT—can represent the WORKS_FOR relationship type. If both are represented, they are constrained to be inverses of each other.<a id="filepos767613" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_132.html#filepos4356427" class="calibre41">8</a></sup></p><div class="calibre31"> </div>
<p class="calibre18"><a id="filepos767716" class="calibre3"></a><strong class="calibre6">Role Names and Recursive Relationships.</strong> Each entity type that participates in a relationship type plays a particular role in the relationship. The <strong class="calibre6">role name</strong> signifies the role that a participating entity from the entity type plays in each relationship instance, and helps to explain what the relationship means. For example, in the WORKS_FOR relationship type, EMPLOYEE plays the role of <em class="calibre13">employee</em> or <em class="calibre13">worker</em> and DEPARTMENT plays the role of <em class="calibre13">department</em> or <em class="calibre13">employer</em>.</p><div class="calibre31"> </div>
<p class="calibre18">Role names are not technically necessary in relationship types where all the participating entity types are distinct, since each participating entity type name can be used as the role name. However, in some cases the <em class="calibre13">same</em> entity type participates more than once in a relationship type in <em class="calibre13">different roles</em>. In such cases the role name becomes essential for distinguishing the meaning of the role that each participating entity plays. Such relationship types are called <strong class="calibre6">recursive relationships</strong>. <a href="#filepos770130" class="calibre41">Figure 7.11</a> shows an example. The SUPERVISION relationship type relates an employee to a supervisor, where both employee and supervisor entities are members of the same EMPLOYEE entity set. Hence, the EMPLOYEE entity type <em class="calibre13">participates twice</em> in SUPERVISION: once in the role of <em class="calibre13">supervisor</em> (or <em class="calibre13">boss</em>), and once in the role of <em class="calibre13">supervisee</em> (or <em class="calibre13">subordinate</em>). Each relationship instance <em class="calibre13">r<sub class="calibre65">i</sub></em> in SUPERVISION associates two employee entities <em class="calibre13">e<sub class="calibre65">j</sub></em> and <em class="calibre13">e<sub class="calibre65">k</sub></em>, one of which plays the role of supervisor and the other the role of supervisee. In <a href="#filepos770130" class="calibre41">Figure 7.11</a>, the lines marked ‘1’ represent the supervisor role, and those marked ‘2’ represent the supervisee role; hence, <em class="calibre13">e</em><sub class="calibre65">1</sub> supervises <em class="calibre13">e</em><sub class="calibre65">2</sub> and <em class="calibre13">e</em><sub class="calibre65">3</sub>, <em class="calibre13">e</em><sub class="calibre65">4</sub> supervises <em class="calibre13">e</em><sub class="calibre65">6</sub> and <em class="calibre13">e</em><sub class="calibre65">7</sub>, and <em class="calibre13">e</em><sub class="calibre65">5</sub> supervises <em class="calibre13">e</em><sub class="calibre65">1</sub> and <em class="calibre13">e</em><sub class="calibre65">4</sub>. In this example, each relationship instance must be connected with two lines, one marked with ‘1’ (supervisor) and the other with ‘2’ (supervisee).</p><div class="calibre31"> </div>
<p id="filepos770130" class="calibre7"><img alt="image" src="../images/00162.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 7.11</strong><br class="calibre1"/>A recursive relationship SUPERVISION between EMPLOYEE in the <em class="calibre13">supervisor</em> role (1) and EMPLOYEE in the <em class="calibre13">subordinate</em> role (2).</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1"><a id="filepos770532" class="calibre3"></a>7.4.3 Constraints on Binary Relationship Types</span></span></blockquote></h5>
<p class="calibre18">Relationship types usually have certain constraints that limit the possible combinations of entities that may participate in the corresponding relationship set. These constraints are determined from the miniworld situation that the relationships represent. For example, in <a href="#filepos764190" class="calibre41">Figure 7.9</a>, if the company has a rule that each employee must work for exactly one department, then we would like to describe this constraint in the schema. We can distinguish two main types of binary relationship constraints: <em class="calibre13">cardinality ratio</em> and <em class="calibre13">participation</em>.</p><div class="calibre31"> </div>
<p class="calibre18"><strong class="calibre6">Cardinality Ratios for Binary Relationships.</strong> The <strong class="calibre6">cardinality ratio</strong> for a binary relationship specifies the <em class="calibre13">maximum</em> number of relationship instances that an entity can participate in. For example, in the WORKS_FOR binary relationship type, DEPARTMENT:EMPLOYEE is of cardinality ratio 1:N, meaning that each department can be related to (that is, employs) any number of employees,<a id="filepos771726" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_133.html#filepos4356977" class="calibre41">9</a></sup> but an employee can be related to (work for) only one department. This means that for this particular relationship WORKS_FOR, a particular department entity can be related to any number of employees (N indicates there is no maximum number). On the other hand, an employee can be related to a maximum of one department. The possible cardinality ratios for binary relationship types are 1:1, 1:N, N:1, and M:N.</p><div class="calibre31"> </div>
<p class="calibre18">An example of a 1:1 binary relationship is MANAGES (<a href="#filepos772824" class="calibre41">Figure 7.12</a>), which relates a department entity to the employee who manages that department. This represents the miniworld constraints that—at any point in time—an employee can manage one department only and a department can have one manager only. The relationship type WORKS_ON (<a href="#filepos773030" class="calibre41">Figure 7.13</a>) is of cardinality ratio M:N, because the miniworld rule is that an employee can work on several projects and a project can have several employees.</p><div class="calibre31"> </div>
<p id="filepos772824" class="calibre7"><img alt="image" src="../images/00163.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 7.12</strong><br class="calibre1"/>A 1:1 relationship, MANAGES.</p><div class="calibre31"> </div>
<p id="filepos773030" class="calibre7"><a id="filepos773061" class="calibre3"></a><img alt="image" src="../images/00164.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 7.13</strong><br class="calibre1"/>An M:N relationship, WORKS_ON.</p><div class="calibre31"> </div>
<p class="calibre18">Cardinality ratios for binary relationships are represented on ER diagrams by displaying 1, M, and N on the diamonds as shown in <a href="#filepos738906" class="calibre41">Figure 7.2</a>. Notice that in this notation, we can either specify no maximum (N) or a maximum of one (1) on participation. An alternative notation (see Section 7.7.4) allows the designer to specify a specific <em class="calibre13">maximum number</em> on participation, such as 4 or 5.</p><div class="calibre31"> </div>
<p class="calibre18"><strong class="calibre6">Participation Constraints and Existence Dependencies.</strong> The <strong class="calibre6">participation constraint</strong> specifies whether the existence of an entity depends on its being related to another entity via the relationship type. This constraint specifies the <em class="calibre13">minimum</em> number of relationship instances that each entity can participate in, and is sometimes called the <strong class="calibre6">minimum cardinality constraint</strong>. There are two types of participation constraints—total and partial—that we illustrate by example. If a company policy states that <em class="calibre13">every</em> employee must work for a department, then an employee entity can exist only if it participates in at least one WORKS_FOR relationship instance (<a href="#filepos764190" class="calibre41">Figure 7.9</a>). Thus, the participation of EMPLOYEE in WORKS_FOR is called <strong class="calibre6">total participation</strong>, meaning that every entity in <em class="calibre13">the total set</em> of employee entities must be related to a department entity via WORKS_FOR. Total participation is also called <strong class="calibre6">existence dependency</strong>. In <a href="#filepos772824" class="calibre41">Figure 7.12</a> we do not expect every employee to manage a department, so the participation of EMPLOYEE in the MANAGES relationship type is <strong class="calibre6">partial</strong>, meaning that <em class="calibre13">some</em> or <em class="calibre13">part of the set of</em> employee entities are related to some department entity via MANAGES, but not necessarily all. We will <a id="filepos775172" class="calibre3"></a>refer to the cardinality ratio and participation constraints, taken together, as the <strong class="calibre6">structural constraints</strong> of a relationship type.</p><div class="calibre31"> </div>
<p class="calibre18">In ER diagrams, total participation (or existence dependency) is displayed as a <em class="calibre13">double line</em> connecting the participating entity type to the relationship, whereas partial participation is represented by a <em class="calibre13">single line</em> (see <a href="#filepos738906" class="calibre41">Figure 7.2</a>). Notice that in this notation, we can either specify no minimum (partial participation) or a minimum of one (total participation). The alternative notation (see Section 7.7.4) allows the designer to specify a specific <em class="calibre13">minimum number</em> on participation in the relationship, such as 4 or 5.</p><div class="calibre31"> </div>
<p class="calibre18">We will discuss constraints on higher-degree relationships in Section 7.9.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">7.4.4 Attributes of Relationship Types</span></span></blockquote></h5>
<p class="calibre18">Relationship types can also have attributes, similar to those of entity types. For example, to record the number of hours per week that an employee works on a particular project, we can include an attribute Hours for the WORKS_ON relationship type in <a href="#filepos773030" class="calibre41">Figure 7.13</a>. Another example is to include the date on which a manager started managing a department via an attribute Start_date for the MANAGES relationship type in <a href="#filepos772824" class="calibre41">Figure 7.12</a>.</p><div class="calibre31"> </div>
<p class="calibre18">Notice that attributes of 1:1 or 1:N relationship types can be migrated to one of the participating entity types. For example, the Start_date attribute for the MANAGES relationship can be an attribute of either EMPLOYEE or DEPARTMENT, although conceptually it belongs to MANAGES. This is because MANAGES is a 1:1 relationship, so every department or employee entity participates in <em class="calibre13">at most one</em> relationship instance. Hence, the value of the Start_date attribute can be determined separately, either by the participating department entity or by the participating employee (manager) entity.</p><div class="calibre31"> </div>
<p class="calibre18">For a 1:N relationship type, a relationship attribute can be migrated <em class="calibre13">only</em> to the entity type on the N-side of the relationship. For example, in <a href="#filepos764190" class="calibre41">Figure 7.9</a>, if the WORKS_FOR relationship also has an attribute Start_date that indicates when an employee started working for a department, this attribute can be included as an attribute of EMPLOYEE. This is because each employee works for only one department, and hence participates in at most one relationship instance in WORKS_FOR. In both 1:1 and 1:N relationship types, the decision where to place a relationship attribute—as a relationship type attribute or as an attribute of a participating entity type—is determined subjectively by the schema designer.</p><div class="calibre31"> </div>
<p class="calibre18">For M:N relationship types, some attributes may be determined by the <em class="calibre13">combination of participating entities</em> in a relationship instance, not by any single entity. Such attributes <em class="calibre13">must be specified as relationship attributes</em>. An example is the Hours attribute of the M:N relationship WORKS_ON (<a href="#filepos773030" class="calibre41">Figure 7.13</a>); the number of hours per week an employee currently works on a project is determined by an employee-project combination and not separately by either entity.</p><div class="calibre31"> </div>
<h4 id="filepos778861" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1"><a id="filepos778945" class="calibre3"></a>7.5 Weak Entity Types</span></span></blockquote></h4><div class="calibre31"> </div>
<p class="calibre18">Entity types that do not have key attributes of their own are called <strong class="calibre6">weak entity types</strong>. In contrast, <strong class="calibre6">regular entity types</strong> that do have a key attribute—which include all the examples discussed so far—are called <strong class="calibre6">strong entity types</strong>. Entities belonging to a weak entity type are identified by being related to specific entities from another entity type in combination with one of their attribute values. We call this other entity type the <strong class="calibre6">identifying</strong> or <strong class="calibre6">owner entity type</strong>,<a id="filepos779621" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_134.html#filepos4357176" class="calibre41">10</a></sup> and we call the relationship type that relates a weak entity type to its owner the <strong class="calibre6">identifying relationship</strong> of the weak entity type.<a id="filepos779818" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_135.html#filepos4357446" class="calibre41">11</a></sup> A weak entity type always has a <em class="calibre13">total participation constraint</em> (existence dependency) with respect to its identifying relationship because a weak entity cannot be identified without an owner entity. However, not every existence dependency results in a weak entity type. For example, a DRIVER_LICENSE entity cannot exist unless it is related to a PERSON entity, even though it has its own key (License_number) and hence is not a weak entity.</p><div class="calibre31"> </div>
<p class="calibre18">Consider the entity type DEPENDENT, related to EMPLOYEE, which is used to keep track of the dependents of each employee via a 1:N relationship (<a href="#filepos738906" class="calibre41">Figure 7.2</a>). In our example, the attributes of DEPENDENT are Name (the first name of the dependent), Birth_date, Sex, and Relationship (to the employee). Two dependents of <em class="calibre13">two distinct employees</em> may, by chance, have the same values for Name, Birth_date, Sex, and Relationship, but they are still distinct entities. They are identified as distinct entities only after determining the <em class="calibre13">particular employee entity</em> to which each dependent is related. Each employee entity is said to <em class="calibre13">own</em> the dependent entities that are related to it.</p><div class="calibre31"> </div>
<p class="calibre18">A weak entity type normally has a <strong class="calibre6">partial key</strong>, which is the attribute that can uniquely identify weak entities that are <em class="calibre13">related to the same owner entity</em>.<a id="filepos781334" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_136.html#filepos4357711" class="calibre41">12</a></sup> In our example, if we assume that no two dependents of the same employee ever have the same first name, the attribute Name of DEPENDENT is the partial key. In the worst case, a composite attribute of <em class="calibre13">all the weak entity’s attributes</em> will be the partial key.</p><div class="calibre31"> </div>
<p class="calibre18">In ER diagrams, both a weak entity type and its identifying relationship are distinguished by surrounding their boxes and diamonds with double lines (see <a href="#filepos738906" class="calibre41">Figure 7.2</a>). The partial key attribute is underlined with a dashed or dotted line.</p><div class="calibre31"> </div>
<p class="calibre18">Weak entity types can sometimes be represented as complex (composite, multivalued) attributes. In the preceding example, we could specify a multivalued attribute Dependents for EMPLOYEE, which is a composite attribute with component attributes Name, Birth_date, Sex, and Relationship. The choice of which representation to use is made by the database designer. One criterion that may be used is to choose the <a id="filepos782440" class="calibre3"></a>weak entity type representation if there are many attributes. If the weak entity participates independently in relationship types other than its identifying relationship type, then it should not be modeled as a complex attribute.</p><div class="calibre31"> </div>
<p class="calibre18">In general, any number of levels of weak entity types can be defined; an owner entity type may itself be a weak entity type. In addition, a weak entity type may have more than one identifying entity type and an identifying relationship type of degree higher than two, as we illustrate in Section 7.9.</p><div class="calibre31"> </div>
<h4 id="filepos783062" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">7.6 Refining the ER Design for the COMPANY Database</span></span></blockquote></h4><div class="calibre31"> </div>
<p class="calibre18">We can now refine the database design in <a href="#filepos757852" class="calibre41">Figure 7.8</a> by changing the attributes that represent relationships into relationship types. The cardinality ratio and participation constraint of each relationship type are determined from the requirements listed in Section 7.2. If some cardinality ratio or dependency cannot be determined from the requirements, the users must be questioned further to determine these structural constraints.</p><div class="calibre31"> </div>
<p class="calibre18">In our example, we specify the following relationship types:</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> MANAGES, a 1:1 relationship type between EMPLOYEE and DEPARTMENT. EMPLOYEE participation is partial. DEPARTMENT participation is not clear from the requirements. We question the users, who say that a department must have a manager at all times, which implies total participation.<a id="filepos784246" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_137.html#filepos4357914" class="calibre41">13</a></sup> The attribute Start_date is assigned to this relationship type.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> WORKS_FOR, a 1:N relationship type between DEPARTMENT and EMPLOYEE. Both participations are total.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> CONTROLS, a 1:N relationship type between DEPARTMENT and PROJECT. The participation of PROJECT is total, whereas that of DEPARTMENT is determined to be partial, after consultation with the users indicates that some departments may control no projects.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> SUPERVISION, a 1:N relationship type between EMPLOYEE (in the supervisor role) and EMPLOYEE (in the supervisee role). Both participations are determined to be partial, after the users indicate that not every employee is a supervisor and not every employee has a supervisor.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> WORKS_ON, determined to be an M:N relationship type with attribute Hours, after the users indicate that a project can have several employees working on it. Both participations are determined to be total.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> DEPENDENTS_OF, a 1:N relationship type between EMPLOYEE and DEPENDENT, which is also the identifying relationship for the weak entity <a id="filepos785936" class="calibre3"></a>type DEPENDENT. The participation of EMPLOYEE is partial, whereas that of DEPENDENT is total.</p></blockquote>
<p class="calibre18">After specifying the above six relationship types, we remove from the entity types in <a href="#filepos757852" class="calibre41">Figure 7.8</a> all attributes that have been refined into relationships. These include Manager and Manager_start_date from DEPARTMENT; Controlling_department from PROJECT; Department, Supervisor, and Works_on from EMPLOYEE; and Employee from DEPENDENT. It is important to have the least possible redundancy when we design the conceptual schema of a database. If some redundancy is desired at the storage level or at the user view level, it can be introduced later, as discussed in Section 1.6.1.</p><div class="calibre31"> </div>
<h4 id="filepos786739" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">7.7 ER Diagrams, Naming Conventions, and Design Issues</span></span></blockquote></h4><div class="calibre31"> </div>
<h5 class="calibre64"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">7.7.1 Summary of Notation for ER Diagrams</span></span></blockquote></h5>
<p class="calibre18"><a href="#filepos764190" class="calibre41">Figures 7.9</a> through <a href="#filepos773030" class="calibre41">7.13</a> illustrate examples of the participation of entity types in relationship types by displaying their sets or extensions—the individual entity instances in an entity set and the individual relationship instances in a relationship set. In ER diagrams the emphasis is on representing the schemas rather than the instances. This is more useful in database design because a database schema changes rarely, whereas the contents of the entity sets change frequently. In addition, the schema is obviously easier to display, because it is much smaller.</p><div class="calibre31"> </div>
<p class="calibre18"><a href="#filepos738906" class="calibre41">Figure 7.2</a> displays the COMPANY <strong class="calibre6">ER database schema</strong> as an <strong class="calibre6">ER diagram</strong>. We now review the full ER diagram notation. Entity types such as EMPLOYEE, DEPARTMENT, and PROJECT are shown in rectangular boxes. Relationship types such as WORKS_FOR, MANAGES, CONTROLS, and WORKS_ON are shown in diamond-shaped boxes attached to the participating entity types with straight lines. Attributes are shown in ovals, and each attribute is attached by a straight line to its entity type or relationship type. Component attributes of a composite attribute are attached to the oval representing the composite attribute, as illustrated by the Name attribute of EMPLOYEE. Multivalued attributes are shown in double ovals, as illustrated by the Locations attribute of DEPARTMENT. Key attributes have their names underlined. Derived attributes are shown in dotted ovals, as illustrated by the Number_of_employees attribute of DEPARTMENT.</p><div class="calibre31"> </div>
<p class="calibre18">Weak entity types are distinguished by being placed in double rectangles and by having their identifying relationship placed in double diamonds, as illustrated by the DEPENDENT entity type and the DEPENDENTS_OF identifying relationship type. The partial key of the weak entity type is underlined with a dotted line.</p><div class="calibre31"> </div>
<p class="calibre18">In <a href="#filepos738906" class="calibre41">Figure 7.2</a> the cardinality ratio of each <em class="calibre13">binary</em> relationship type is specified by attaching a 1, M, or N on each participating edge. The cardinality ratio of DEPARTMENT:EMPLOYEE in MANAGES is 1:1, whereas it is 1:N for DEPARTMENT: EMPLOYEE in WORKS_FOR, and M:N for WORKS_ON. The participation <a id="filepos789556" class="calibre3"></a>constraint is specified by a single line for partial participation and by double lines for total participation (existence dependency).</p><div class="calibre31"> </div>
<p class="calibre18">In <a href="#filepos738906" class="calibre41">Figure 7.2</a> we show the role names for the SUPERVISION relationship type because the same EMPLOYEE entity type plays two distinct roles in that relationship. Notice that the cardinality ratio is 1:N from supervisor to supervisee because each employee in the role of supervisee has at most one direct supervisor, whereas an employee in the role of supervisor can supervise zero or more employees.</p><div class="calibre31"> </div>
<p class="calibre18"><a href="#filepos793480" class="calibre41">Figure 7.14</a> summarizes the conventions for ER diagrams. It is important to note that there are many other alternative diagrammatic notations (see Section 7.7.4 and <a href="dummy_split_054.html#filepos3441269" class="calibre41">Appendix A</a>).</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">7.7.2 Proper Naming of Schema Constructs</span></span></blockquote></h5>
<p class="calibre18">When designing a database schema, the choice of names for entity types, attributes, relationship types, and (particularly) roles is not always straightforward. One should choose names that convey, as much as possible, the meanings attached to the different constructs in the schema. We choose to use <em class="calibre13">singular names</em> for entity types, rather than plural ones, because the entity type name applies to each individual entity belonging to that entity type. In our ER diagrams, we will use the convention that entity type and relationship type names are uppercase letters, attribute names have their initial letter capitalized, and role names are lowercase letters. We have used this convention in <a href="#filepos738906" class="calibre41">Figure 7.2</a>.</p><div class="calibre31"> </div>
<p class="calibre18">As a general practice, given a narrative description of the database requirements, the <em class="calibre13">nouns</em> appearing in the narrative tend to give rise to entity type names, and the <em class="calibre13">verbs</em> tend to indicate names of relationship types. Attribute names generally arise from additional nouns that describe the nouns corresponding to entity types.</p><div class="calibre31"> </div>
<p class="calibre18">Another naming consideration involves choosing binary relationship names to make the ER diagram of the schema readable from left to right and from top to bottom. We have generally followed this guideline in <a href="#filepos738906" class="calibre41">Figure 7.2</a>. To explain this naming convention further, we have one exception to the convention in <a href="#filepos738906" class="calibre41">Figure 7.2</a>—the DEPENDENTS_OF relationship type, which reads from bottom to top. When we describe this relationship, we can say that the DEPENDENT entities (bottom entity type) are DEPENDENTS_OF (relationship name) an EMPLOYEE (top entity type). To change this to read from top to bottom, we could rename the relationship type to HAS_DEPENDENTS, which would then read as follows: An EMPLOYEE entity (top entity type) HAS_DEPENDENTS (relationship name) of type DEPENDENT (bottom entity type). Notice that this issue arises because each binary relationship can be described starting from either of the two participating entity types, as discussed in the beginning of Section 7.4.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">7.7.3 Design Choices for ER Conceptual Design</span></span></blockquote></h5>
<p class="calibre18">It is occasionally difficult to decide whether a particular concept in the miniworld should be modeled as an entity type, an attribute, or a relationship type. In this section, we give some brief guidelines as to which construct should be chosen in particular situations.</p><div class="calibre31"> </div>
<p id="filepos793480" class="calibre7"><img alt="image" src="../images/00165.jpg" class="calibre16"/></p>
<p class="calibre58"><a class="calibre3"></a><br class="calibre1"/><strong class="calibre6">Figure 7.14</strong><br class="calibre1"/>Summary of the notation for ER diagrams.</p><div class="calibre31"> </div>
<p class="calibre18"><a id="filepos793738" class="calibre3"></a>In general, the schema design process should be considered an iterative refinement process, where an initial design is created and then iteratively refined until the most suitable design is reached. Some of the refinements that are often used include the following:</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> A concept may be first modeled as an attribute and then refined into a relationship because it is determined that the attribute is a reference to another entity type. It is often the case that a pair of such attributes that are inverses of one another are refined into a binary relationship. We discussed this type of refinement in detail in Section 7.6. It is important to note that in our notation, once an attribute is replaced by a relationship, the attribute itself should be removed from the entity type to avoid duplication and redundancy.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> Similarly, an attribute that exists in several entity types may be elevated or promoted to an independent entity type. For example, suppose that several entity types in a UNIVERSITY database, such as STUDENT, INSTRUCTOR, and COURSE, each has an attribute Department in the initial design; the designer may then choose to create an entity type DEPARTMENT with a single attribute Dept_name and relate it to the three entity types (STUDENT, INSTRUCTOR, and COURSE) via appropriate relationships. Other attributes/relationships of DEPARTMENT may be discovered later.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> An inverse refinement to the previous case may be applied—for example, if an entity type DEPARTMENT exists in the initial design with a single attribute Dept_name and is related to only one other entity type, STUDENT. In this case, DEPARTMENT may be reduced or demoted to an attribute of STUDENT.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> Section 7.9 discusses choices concerning the degree of a relationship. In <a href="dummy_split_024.html#filepos851508" class="calibre41">Chapter 8</a>, we discuss other refinements concerning specialization/generalization. <a href="dummy_split_026.html#filepos1020863" class="calibre41">Chapter 10</a> discusses additional top-down and bottom-up refinements that are common in large-scale conceptual schema design.</p></blockquote>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">7.7.4 Alternative Notations for ER Diagrams</span></span></blockquote></h5>
<p class="calibre18">There are many alternative diagrammatic notations for displaying ER diagrams. <a href="dummy_split_054.html#filepos3441269" class="calibre41">Appendix A</a> gives some of the more popular notations. In Section 7.8, we introduce the Unified Modeling Language (UML) notation for class diagrams, which has been proposed as a standard for conceptual object modeling.</p><div class="calibre31"> </div>
<p class="calibre18">In this section, we describe one alternative ER notation for specifying structural constraints on relationships, which replaces the cardinality ratio (1:1, 1:N, M:N) and single/double line notation for participation constraints. This notation involves associating a pair of integer numbers (min, max) with each <em class="calibre13">participation</em> of an entity type <em class="calibre13">E</em> in a relationship type <em class="calibre13">R</em>, where 0 ≤ min ≤ max and max ≥ 1. The numbers mean that for each entity <em class="calibre13">e</em> in <em class="calibre13">E</em>, <em class="calibre13">e</em> must participate in at least min and at most <a class="calibre3"></a>max relationship instances in <em class="calibre13">R at any point in time</em>. In this method, min = 0 implies partial participation, whereas min &gt; 0 implies total participation.</p><div class="calibre31"> </div>
<p class="calibre18"><a href="#filepos798238" class="calibre41">Figure 7.15</a> displays the COMPANY database schema using the (min, max) notation.<a id="filepos797770" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_138.html#filepos4358252" class="calibre41">14</a></sup> Usually, one uses either the cardinality ratio/single-line/double-line notation <em class="calibre13">or</em> the (min, max) notation. The (min, max) notation is more precise, and we can use it to specify some structural constraints for relationship types of <em class="calibre13">higher degree</em>. However, it is not sufficient for specifying some key constraints on higher-degree relationships, as discussed in Section 7.9.</p><div class="calibre31"> </div>
<p id="filepos798238" class="calibre7"><img alt="image" src="../images/00166.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 7.15</strong><br class="calibre1"/>ER diagrams for the company schema, with structural constraints specified using (min, max) notation and role names.</p><div class="calibre31"> </div>
<p class="calibre18"><a id="filepos798559" class="calibre3"></a><a href="#filepos798238" class="calibre41">Figure 7.15</a> also displays all the role names for the COMPANY database schema.</p><div class="calibre31"> </div>
<h4 id="filepos798699" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">7.8 Example of Other Notation: UML Class Diagrams</span></span></blockquote></h4><div class="calibre31"> </div>
<p class="calibre18">The UML methodology is being used extensively in software design and has many types of diagrams for various software design purposes. We only briefly present the basics of <strong class="calibre6">UML class diagrams</strong> here, and compare them with ER diagrams. In some ways, class diagrams can be considered as an alternative notation to ER diagrams. Additional UML notation and concepts are presented in Section 8.6, and in <a href="dummy_split_026.html#filepos1020863" class="calibre41">Chapter 10</a>. <a href="#filepos799777" class="calibre41">Figure 7.16</a> shows how the COMPANY ER database schema in <a href="#filepos798238" class="calibre41">Figure 7.15</a> can be displayed using UML class diagram notation. The <em class="calibre13">entity types</em> in <a href="#filepos798238" class="calibre41">Figure 7.15</a> are modeled as <em class="calibre13">classes</em> in <a href="#filepos799777" class="calibre41">Figure 7.16</a>. An <em class="calibre13">entity</em> in ER corresponds to an <em class="calibre13">object</em> in UML.</p><div class="calibre31"> </div>
<p id="filepos799777" class="calibre7"><img alt="image" src="../images/00167.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 7.16</strong><br class="calibre1"/>The COMPANY conceptual schema in UML class diagram notation.</p><div class="calibre31"> </div>
<p class="calibre18"><a id="filepos800043" class="calibre3"></a>In UML class diagrams, a <strong class="calibre6">class</strong> (similar to an entity type in ER) is displayed as a box (see <a href="#filepos799777" class="calibre41">Figure 7.16</a>) that includes three sections: The top section gives the <strong class="calibre6">class name</strong> (similar to entity type name); the middle section includes the <strong class="calibre6">attributes</strong>; and the last section includes <strong class="calibre6">operations</strong> that can be applied to individual objects (similar to individual entities in an entity set) of the class. Operations are <em class="calibre13">not</em> specified in ER diagrams. Consider the EMPLOYEE class in <a href="#filepos799777" class="calibre41">Figure 7.16</a>. Its attributes are Name, Ssn, Bdate, Sex, Address, and Salary. The designer can optionally specify the <strong class="calibre6">domain</strong> of an attribute if desired, by placing a colon (:) followed by the domain name or description, as illustrated by the Name, Sex, and Bdate attributes of EMPLOYEE in <a href="#filepos799777" class="calibre41">Figure 7.16</a>. A composite attribute is modeled as a <strong class="calibre6">structured domain</strong>, as illustrated by the Name attribute of EMPLOYEE. A multivalued attribute will generally be modeled as a separate class, as illustrated by the LOCATION class in <a href="#filepos799777" class="calibre41">Figure 7.16</a>.</p><div class="calibre31"> </div>
<p class="calibre18">Relationship types are called <strong class="calibre6">associations</strong> in UML terminology, and relationship instances are called <strong class="calibre6">links</strong>. A <strong class="calibre6">binary association</strong> (binary relationship type) is represented as a line connecting the participating classes (entity types), and may optionally have a name. A relationship attribute, called a <strong class="calibre6">link attribute</strong>, is placed in a box that is connected to the association’s line by a dashed line. The (min, max) notation described in Section 7.7.4 is used to specify relationship constraints, which are called <strong class="calibre6">multiplicities</strong> in UML terminology. Multiplicities are specified in the form <em class="calibre13">min..max</em>, and an asterisk (*) indicates no maximum limit on participation. However, the multiplicities are placed <em class="calibre13">on the opposite ends of the relationship</em> when compared with the notation discussed in Section 7.7.4 (compare <a href="#filepos798238" class="calibre41">Figures 7.15</a> and <a href="#filepos799777" class="calibre41">7.16</a>). In UML, a single asterisk indicates a multiplicity of 0..*, and a single 1 indicates a multiplicity of 1..1. A recursive relationship (see Section 7.4.2) is called a <strong class="calibre6">reflexive association</strong> in UML, and the role names—like the multiplicities—are placed at the opposite ends of an association when compared with the placing of role names in <a href="#filepos798238" class="calibre41">Figure 7.15</a>.</p><div class="calibre31"> </div>
<p class="calibre18">In UML, there are two types of relationships: association and aggregation. <strong class="calibre6">Aggregation</strong> is meant to represent a relationship between a whole object and its component parts, and it has a distinct diagrammatic notation. In <a href="#filepos799777" class="calibre41">Figure 7.16</a>, we modeled the locations of a department and the single location of a project as aggregations. However, aggregation and association do not have different structural properties, and the choice as to which type of relationship to use is somewhat subjective. In the ER model, both are represented as relationships.</p><div class="calibre31"> </div>
<p class="calibre18">UML also distinguishes between <strong class="calibre6">unidirectional</strong> and <strong class="calibre6">bidirectional</strong> associations (or aggregations). In the unidirectional case, the line connecting the classes is displayed with an arrow to indicate that only one direction for accessing related objects is needed. If no arrow is displayed, the bidirectional case is assumed, which is the default. For example, if we always expect to access the manager of a department starting from a DEPARTMENT object, we would draw the association line representing the MANAGES association with an arrow from DEPARTMENT to EMPLOYEE. In addition, relationship instances may be specified to be <strong class="calibre6">ordered</strong>. For example, we could specify that the employee objects related to each department through the WORKS_FOR association (relationship) should be ordered by their Salary attribute <a id="filepos804289" class="calibre3"></a>value. Association (relationship) names are <em class="calibre13">optional</em> in UML, and relationship attributes are displayed in a box attached with a dashed line to the line representing the association/aggregation (see Start_date and Hours in <a href="#filepos799777" class="calibre41">Figure 7.16</a>).</p><div class="calibre31"> </div>
<p class="calibre18">The operations given in each class are derived from the functional requirements of the application, as we discussed in Section 7.1. It is generally sufficient to specify the operation names initially for the logical operations that are expected to be applied to individual objects of a class, as shown in <a href="#filepos799777" class="calibre41">Figure 7.16</a>. As the design is refined, more details are added, such as the exact argument types (parameters) for each operation, plus a functional description of each operation. UML has <em class="calibre13">function descriptions</em> and <em class="calibre13">sequence diagrams</em> to specify some of the operation details, but these are beyond the scope of our discussion. <a href="dummy_split_026.html#filepos1020863" class="calibre41">Chapter 10</a> will introduce some of these diagrams.</p><div class="calibre31"> </div>
<p class="calibre18">Weak entities can be modeled using the construct called <strong class="calibre6">qualified association</strong> (or <strong class="calibre6">qualified aggregation</strong>) in UML; this can represent both the identifying relationship and the partial key, which is placed in a box attached to the owner class. This is illustrated by the DEPENDENT class and its qualified aggregation to EMPLOYEE in <a href="#filepos799777" class="calibre41">Figure 7.16</a>. The partial key Dependent_name is called the <strong class="calibre6">discriminator</strong> in UML terminology, since its value distinguishes the objects associated with (related to) the same EMPLOYEE. Qualified associations are not restricted to modeling weak entities, and they can be used to model other situations in UML.</p><div class="calibre31"> </div>
<p class="calibre18">This section is not meant to be a complete description of UML class diagrams, but rather to illustrate one popular type of alternative diagrammatic notation that can be used for representing ER modeling concepts.</p><div class="calibre31"> </div>
<h4 id="filepos806439" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">7.9 Relationship Types of Degree Higher than Two</span></span></blockquote></h4><div class="calibre31"> </div>
<p class="calibre18">In Section 7.4.2 we defined the <strong class="calibre6">degree</strong> of a relationship type as the number of participating entity types and called a relationship type of degree two <em class="calibre13">binary</em> and a relationship type of degree three <em class="calibre13">ternary</em>. In this section, we elaborate on the differences between binary and higher-degree relationships, when to choose higher-degree versus binary relationships, and how to specify constraints on higher-degree relationships.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1">7.9.1 Choosing between Binary and Ternary (or Higher-Degree) Relationships</span></span></blockquote></h5>
<p class="calibre18">The ER diagram notation for a ternary relationship type is shown in <a href="#filepos808081" class="calibre41">Figure 7.17(a)</a>, which displays the schema for the SUPPLY relationship type that was displayed at the entity set/relationship set or instance level in <a href="#filepos765982" class="calibre41">Figure 7.10</a>. Recall that the relationship set of SUPPLY is a set of relationship instances (<em class="calibre13">s</em>, <em class="calibre13">j</em>, <em class="calibre13">p</em>), where <em class="calibre13">s</em> is a SUPPLIER who is currently supplying a PART <em class="calibre13">p</em> to a PROJECT <em class="calibre13">j</em>. In general, a relationship type <em class="calibre13">R</em> of degree <em class="calibre13">n</em> will have <em class="calibre13">n</em> edges in an ER diagram, one connecting <em class="calibre13">R</em> to each participating entity type.</p><div class="calibre31"> </div>
<p id="filepos808081" class="calibre7"><a class="calibre3"></a><img alt="image" src="../images/00168.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 7.17</strong><br class="calibre1"/>Ternary relationship types. (a) The SUPPLY relationship. (b) Three binary relationships not equivalent to SUPPLY. (c) SUPPLY represented as a weak entity type.</p><div class="calibre31"> </div>
<p class="calibre18"><a href="#filepos808081" class="calibre41">Figure 7.17(b)</a> shows an ER diagram for three binary relationship types CAN_SUPPLY, USES, and SUPPLIES. In general, a ternary relationship type represents different information than do three binary relationship types. Consider the three binary relationship types CAN_SUPPLY, USES, and SUPPLIES. Suppose that CAN_SUPPLY, between SUPPLIER and PART, includes an instance (<em class="calibre13">s</em>, <em class="calibre13">p</em>) whenever supplier <em class="calibre13">s can supply</em> part <em class="calibre13">p</em> (to any project); USES, between PROJECT and PART, includes an instance (<em class="calibre13">j</em>, <em class="calibre13">p</em>) whenever project <em class="calibre13">j</em> uses part <em class="calibre13">p</em>; and SUPPLIES, between SUPPLIER and PROJECT, includes an instance (<em class="calibre13">s</em>, <em class="calibre13">j</em>) whenever supplier <em class="calibre13">s</em> supplies <a class="calibre3"></a><em class="calibre13">some part</em> to project <em class="calibre13">j</em>. The existence of three relationship instances (<em class="calibre13">s</em>, <em class="calibre13">p</em>), (<em class="calibre13">j</em>, <em class="calibre13">p</em>), and (<em class="calibre13">s</em>, <em class="calibre13">j</em>) in CAN_SUPPLY, USES, and SUPPLIES, respectively, does not necessarily imply that an instance (<em class="calibre13">s</em>, <em class="calibre13">j</em>, <em class="calibre13">p</em>) exists in the ternary relationship SUPPLY, because the <em class="calibre13">meaning is different</em>. It is often tricky to decide whether a particular relationship should be represented as a relationship type of degree <em class="calibre13">n</em> or should be broken down into several relationship types of smaller degrees. The designer must base this decision on the semantics or meaning of the particular situation being represented. The typical solution is to include the ternary relationship <em class="calibre13">plus</em> one or more of the binary relationships, if they represent different meanings and if all are needed by the application.</p><div class="calibre31"> </div>
<p class="calibre18">Some database design tools are based on variations of the ER model that permit only binary relationships. In this case, a ternary relationship such as SUPPLY must be represented as a weak entity type, with no partial key and with three identifying relationships. The three participating entity types SUPPLIER, PART, and PROJECT are together the owner entity types (see <a href="#filepos808081" class="calibre41">Figure 7.17(c)</a>). Hence, an entity in the weak entity type SUPPLY in <a href="#filepos808081" class="calibre41">Figure 7.17(c)</a> is identified by the combination of its three owner entities from SUPPLIER, PART, and PROJECT.</p><div class="calibre31"> </div>
<p class="calibre18">It is also possible to represent the ternary relationship as a regular entity type by introducing an artificial or surrogate key. In this example, a key attribute Supply_id could be used for the supply entity type, converting it into a regular entity type. Three binary N:1 relationships relate SUPPLY to the three participating entity types.</p><div class="calibre31"> </div>
<p class="calibre18">Another example is shown in <a href="#filepos812999" class="calibre41">Figure 7.18</a>. The ternary relationship type OFFERS represents information on instructors offering courses during particular semesters; hence it includes a relationship instance (<em class="calibre13">i</em>, <em class="calibre13">s</em>, <em class="calibre13">c</em>) whenever INSTRUCTOR <em class="calibre13">i</em> offers COURSE <em class="calibre13">c</em> during SEMESTER <em class="calibre13">s</em>. The three binary relationship types shown in <a href="#filepos812999" class="calibre41">Figure 7.18</a> have the following meanings: CAN_TEACH relates a course to the instructors who <em class="calibre13">can teach</em> that course, TAUGHT_DURING relates a semester to the instructors who <em class="calibre13">taught some course</em> during that semester, and OFFERED_DURING relates a semester to the courses offered during that semester <em class="calibre13">by any instructor</em>. These ternary and binary relationships represent different information, but certain constraints should hold among the relationships. For example, a relationship instance (<em class="calibre13">i</em>, <em class="calibre13">s</em>, <em class="calibre13">c</em>) should not exist in OFFERS <em class="calibre13">unless</em> an instance (<em class="calibre13">i</em>, <em class="calibre13">s</em>) exists in TAUGHT_DURING, an instance (<em class="calibre13">s</em>, <em class="calibre13">c</em>) exists in OFFERED_DURING, and an instance (<em class="calibre13">i</em>, <em class="calibre13">c</em>) exists in CAN_TEACH. However, the reverse is not always true; we may have instances (<em class="calibre13">i</em>, <em class="calibre13">s</em>), (<em class="calibre13">s</em>, <em class="calibre13">c</em>), and (<em class="calibre13">i</em>, <em class="calibre13">c</em>) in the three binary relationship types with no corresponding instance (<em class="calibre13">i</em>, <em class="calibre13">s</em>, <em class="calibre13">c</em>) in OFFERS. Note that in this example, based on the meanings of the relationships, we can infer the instances of TAUGHT_DURING and OFFERED_DURING from the instances in OFFERS, but we cannot infer the instances of CAN_TEACH; therefore, TAUGHT_DURING and OFFERED_DURING are redundant and can be left out.</p><div class="calibre31"> </div>
<p id="filepos812999" class="calibre7"><img alt="image" src="../images/00169.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 7.18</strong><br class="calibre1"/>Another example of ternary versus binary relationship types.</p><div class="calibre31"> </div>
<p class="calibre18"><a class="calibre3"></a>Although in general three binary relationships <em class="calibre13">cannot</em> replace a ternary relationship, they may do so under certain <em class="calibre13">additional constraints</em>. In our example, if the CAN_TEACH relationship is 1:1 (an instructor can teach one course, and a course can be taught by only one instructor), then the ternary relationship OFFERS can be left out because it can be inferred from the three binary relationships CAN_TEACH, TAUGHT_DURING, and OFFERED_DURING. The schema designer must analyze the meaning of each specific situation to decide which of the binary and ternary relationship types are needed.</p><div class="calibre31"> </div>
<p class="calibre18">Notice that it is possible to have a weak entity type with a ternary (or <em class="calibre13">n</em>-ary) identifying relationship type. In this case, the weak entity type can have <em class="calibre13">several</em> owner entity types. An example is shown in <a href="#filepos814872" class="calibre41">Figure 7.19</a>. This example shows part of a database that keeps track of candidates interviewing for jobs at various companies, and may be part of an employment agency database, for example. In the requirements, a candidate can have multiple interviews with the same company (for example, with different company departments or on separate dates), but a job offer is made based on one of the interviews. Here, INTERVIEW is represented as a weak entity with two owners CANDIDATE and COMPANY, and with the partial key Dept_date. An INTERVIEW entity is uniquely identified by a candidate, a company, and the combination of the date and department of the interview.</p><div class="calibre31"> </div>
<p id="filepos814872" class="calibre7"><img alt="image" src="../images/00170.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 7.19</strong><br class="calibre1"/>A weak entity type INTERVIEW with a ternary identifying relationship type.</p><div class="calibre31"> </div>
<h5 class="calibre59"><blockquote class="calibre30"><span class="calibre60"><span class="bold1"><a id="filepos815208" class="calibre3"></a>7.9.2 Constraints on Ternary (or Higher-Degree) Relationships</span></span></blockquote></h5>
<p class="calibre18">There are two notations for specifying structural constraints on <em class="calibre13">n</em>-ary relationships, and they specify different constraints. They should thus <em class="calibre13">both be used</em> if it is important to fully specify the structural constraints on a ternary or higher-degree relationship. The first notation is based on the cardinality ratio notation of binary relationships displayed in <a href="#filepos738906" class="calibre41">Figure 7.2</a>. Here, a 1, M, or N is specified on each participation arc (both M and N symbols stand for <em class="calibre13">many</em> or <em class="calibre13">any number</em>).<a id="filepos815905" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_139.html#filepos4358758" class="calibre41">15</a></sup> Let us illustrate this constraint using the SUPPLY relationship in <a href="#filepos808081" class="calibre41">Figure 7.17</a>.</p><div class="calibre31"> </div>
<p class="calibre18">Recall that the relationship set of SUPPLY is a set of relationship instances (<em class="calibre13">s</em>, <em class="calibre13">j</em>, <em class="calibre13">p</em>), where <em class="calibre13">s</em> is a SUPPLIER, <em class="calibre13">j</em> is a PROJECT, and <em class="calibre13">p</em> is a PART. Suppose that the constraint exists that for a particular project-part combination, only one supplier will be used (only one supplier supplies a particular part to a particular project). In this case, we place 1 on the SUPPLIER participation, and M, N on the PROJECT, PART participations in <a href="#filepos808081" class="calibre41">Figure 7.17</a>. This specifies the constraint that a particular (<em class="calibre13">j</em>, <em class="calibre13">p</em>) combination can appear at most once in the relationship set because each such (PROJECT, PART) combination uniquely determines a single supplier. Hence, any relationship instance (<em class="calibre13">s</em>, <em class="calibre13">j</em>, <em class="calibre13">p</em>) is uniquely identified in the relationship set by its (<em class="calibre13">j</em>, <em class="calibre13">p</em>) combination, which makes (<em class="calibre13">j</em>, <em class="calibre13">p</em>) a key for the relationship set. In this notation, the participations that have a 1 specified on them are not required to be part of the identifying key for the relationship set.<a id="filepos817239" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_140.html#filepos4359001" class="calibre41">16</a></sup> If all three cardinalities are M or N, then the key will be the combination of all three participants.</p><div class="calibre31"> </div>
<p class="calibre18">The second notation is based on the (min, max) notation displayed in <a href="#filepos798238" class="calibre41">Figure 7.15</a> for binary relationships. A (min, max) on a participation here specifies that each entity is related to at least <em class="calibre13">min</em> and at most <em class="calibre13">max relationship instances</em> in the relationship set. These constraints have no bearing on determining the key of an <em class="calibre13">n</em>-ary relationship, where <em class="calibre13">n</em> &gt; 2,<a id="filepos817870" class="calibre3"></a><sup class="calibre43"><a href="dummy_split_141.html#filepos4359198" class="calibre41">17</a></sup> but specify a different type of constraint that places restrictions on how many relationship instances each entity can participate in.</p><div class="calibre31"> </div>
<h4 id="filepos818081" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">7.10 Summary</span></span></blockquote></h4><div class="calibre31"> </div>
<p class="calibre18">In this chapter we presented the modeling concepts of a high-level conceptual data model, the Entity-Relationship (ER) model. We started by discussing the role that a high-level data model plays in the database design process, and then we presented a sample set of database requirements for the COMPANY database, which is one of the examples that is used throughout this book. We defined the basic ER model concepts of entities and their attributes. Then we discussed NULL values and presented <a class="calibre3"></a>the various types of attributes, which can be nested arbitrarily to produce complex attributes:</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> Simple or atomic</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> Composite</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> Multivalued</p></blockquote>
<p class="calibre18">We also briefly discussed stored versus derived attributes. Then we discussed the ER model concepts at the schema or “intension” level:</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> Entity types and their corresponding entity sets</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> Key attributes of entity types</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> Value sets (domains) of attributes</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> Relationship types and their corresponding relationship sets</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> Participation roles of entity types in relationship types</p></blockquote>
<p class="calibre18">We presented two methods for specifying the structural constraints on relationship types. The first method distinguished two types of structural constraints:</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> Cardinality ratios (1:1, 1:N, M:N for binary relationships)</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><img alt="image" src="../images/00003.jpg" class="calibre16"/> Participation constraints (total, partial)</p></blockquote>
<p class="calibre18">We noted that, alternatively, another method of specifying structural constraints is to specify minimum and maximum numbers (min, max) on the participation of each entity type in a relationship type. We discussed weak entity types and the related concepts of owner entity types, identifying relationship types, and partial key attributes.</p><div class="calibre31"> </div>
<p class="calibre18">Entity-Relationship schemas can be represented diagrammatically as ER diagrams. We showed how to design an ER schema for the COMPANY database by first defining the entity types and their attributes and then refining the design to include relationship types. We displayed the ER diagram for the COMPANY database schema. We discussed some of the basic concepts of UML class diagrams and how they relate to ER modeling concepts. We also described ternary and higher-degree relationship types in more detail, and discussed the circumstances under which they are distinguished from binary relationships.</p><div class="calibre31"> </div>
<p class="calibre18">The ER modeling concepts we have presented thus far—entity types, relationship types, attributes, keys, and structural constraints—can model many database applications. However, more complex applications—such as engineering design, medical information systems, and telecommunications—require additional concepts if we want to model them with greater accuracy. We discuss some advanced modeling concepts in <a href="dummy_split_024.html#filepos851508" class="calibre41">Chapter 8</a> and revisit further advanced data modeling techniques in <a href="dummy_split_050.html#filepos2950456" class="calibre41">Chapter 26</a>.</p><div class="calibre31"> </div>
<h4 id="filepos822577" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1"><a class="calibre3"></a>Review Questions</span></span></blockquote></h4><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.1.</strong> Discuss the role of a high-level data model in the database design process.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.2.</strong> List the various cases where use of a NULL value would be appropriate.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.3.</strong> Define the following terms: <em class="calibre13">entity, attribute, attribute value, relationship instance, composite attribute, multivalued attribute, derived attribute, complex attribute, key attribute</em>, and <em class="calibre13">value set</em> (<em class="calibre13">domain</em>).</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.4.</strong> What is an entity type? What is an entity set? Explain the differences among an entity, an entity type, and an entity set.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.5.</strong> Explain the difference between an attribute and a value set.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.6.</strong> What is a relationship type? Explain the differences among a relationship instance, a relationship type, and a relationship set.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.7.</strong> What is a participation role? When is it necessary to use role names in the description of relationship types?</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.8.</strong> Describe the two alternatives for specifying structural constraints on relationship types. What are the advantages and disadvantages of each?</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.9.</strong> Under what conditions can an attribute of a binary relationship type be migrated to become an attribute of one of the participating entity types?</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.10.</strong> When we think of relationships as attributes, what are the value sets of these attributes? What class of data models is based on this concept?</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.11.</strong> What is meant by a recursive relationship type? Give some examples of recursive relationship types.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.12.</strong> When is the concept of a weak entity used in data modeling? Define the terms <em class="calibre13">owner entity type, weak entity type, identifying relationship type</em>, and <em class="calibre13">partial key</em>.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.13.</strong> Can an identifying relationship of a weak entity type be of a degree greater than two? Give examples to illustrate your answer.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.14.</strong> Discuss the conventions for displaying an ER schema as an ER diagram.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.15.</strong> Discuss the naming conventions used for ER schema diagrams.</p></blockquote><div class="calibre31"> </div>
<h4 id="filepos826079" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">Exercises</span></span></blockquote></h4><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.16.</strong> Consider the following set of requirements for a UNIVERSITY database that is used to keep track of students’ transcripts. This is similar but not identical to the database shown in <a href="dummy_split_015.html#filepos107062" class="calibre41">Figure 1.2</a>:</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40">a. The university keeps track of each student’s name, student number, Social Security number, current address and phone number, permanent address and phone number, birth date, sex, class (freshman, sophomore, ..., graduate), major department, minor department (if any), and degree program <a class="calibre3"></a>(B.A., B.S., ..., Ph.D.). Some user applications need to refer to the city, state, and ZIP Code of the student’s permanent address and to the student’s last name. Both Social Security number and student number have unique values for each student.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">b. Each department is described by a name, department code, office number, office phone number, and college. Both name and code have unique values for each department.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">c. Each course has a course name, description, course number, number of semester hours, level, and offering department. The value of the course number is unique for each course.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">d. Each section has an instructor, semester, year, course, and section number. The section number distinguishes sections of the same course that are taught during the same semester/year; its values are 1, 2, 3, ..., up to the number of sections taught during each semester.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">e. A grade report has a student, section, letter grade, and numeric grade (0, 1, 2, 3, or 4).</p></blockquote>
<blockquote class="calibre45"><p class="calibre18">Design an ER schema for this application, and draw an ER diagram for the schema. Specify key attributes of each entity type, and structural constraints on each relationship type. Note any unspecified requirements, and make appropriate assumptions to make the specification complete.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.17.</strong> Composite and multivalued attributes can be nested to any number of levels. Suppose we want to design an attribute for a STUDENT entity type to keep track of previous college education. Such an attribute will have one entry for each college previously attended, and each such entry will be composed of college name, start and end dates, degree entries (degrees awarded at that college, if any), and transcript entries (courses completed at that college, if any). Each degree entry contains the degree name and the month and year the degree was awarded, and each transcript entry contains a course name, semester, year, and grade. Design an attribute to hold this information. Use the conventions in <a href="#filepos747923" class="calibre41">Figure 7.5</a>.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.18.</strong> Show an alternative design for the attribute described in Exercise 7.17 that uses only entity types (including weak entity types, if needed) and relationship types.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.19.</strong> Consider the ER diagram in <a href="#filepos830733" class="calibre41">Figure 7.20</a>, which shows a simplified schema for an airline reservations system. Extract from the ER diagram the requirements and constraints that produced this schema. Try to be as precise as possible in your requirements and constraints specification.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.20.</strong> In <a href="dummy_split_015.html#filepos92110" class="calibre41">Chapters 1</a> and <a href="dummy_split_016.html#filepos180230" class="calibre41">2</a>, we discussed the database environment and database users. We can consider many entity types to describe such an environment, such as DBMS, stored database, DBA, and catalog/data dictionary. Try to specify all the entity types that can fully describe a database system and its environment; then specify the relationship types among them, and draw an ER diagram to describe such a general database environment.</p></blockquote><div class="calibre31"> </div>
<p id="filepos830733" class="calibre7"><img alt="image" src="../images/00171.jpg" class="calibre16"/></p>
<p class="calibre58"><a class="calibre3"></a><br class="calibre1"/><strong class="calibre6">Figure 7.20</strong><br class="calibre1"/>An ER diagram for an AIRLINE database schema.</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.21.</strong> Design an ER schema for keeping track of information about votes taken in the U.S. House of Representatives during the current two-year congressional session. The database needs to keep track of each U.S. STATE’s Name (e.g., ‘Texas’, ‘New York’, ‘California’) and include the Region of the state (whose domain is {‘Northeast’, ‘Midwest’, ‘Southeast’, ‘Southwest’, ‘West’}). Each <a class="calibre3"></a>CONGRESS_PERSON in the House of Representatives is described by his or her Name, plus the District represented, the Start_date when the congressperson was first elected, and the political Party to which he or she belongs (whose domain is {‘Republican’, ‘Democrat’, ‘Independent’, ‘Other’}). The database keeps track of each BILL (i.e., proposed law), including the Bill_name, the Date_of_vote on the bill, whether the bill Passed_or_failed (whose domain is {‘Yes’, ‘No’}), and the Sponsor (the congressperson(s) who sponsored—that is, proposed—the bill). The database also keeps track of how each congressperson voted on each bill (domain of Vote attribute is {‘Yes’, ‘No’, ‘Abstain’, ‘Absent’}). Draw an ER schema diagram for this application. State clearly any assumptions you make.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.22.</strong> A database is being constructed to keep track of the teams and games of a sports league. A team has a number of players, not all of whom participate in each game. It is desired to keep track of the players participating in each game for each team, the positions they played in that game, and the result of the game. Design an ER schema diagram for this application, stating any assumptions you make. Choose your favorite sport (e.g., soccer, baseball, football).</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.23.</strong> Consider the ER diagram shown in <a href="#filepos835930" class="calibre41">Figure 7.21</a> for part of a BANK database. Each bank can have multiple branches, and each branch can have multiple accounts and loans.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40">a. List the strong (nonweak) entity types in the ER diagram.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">b. Is there a weak entity type? If so, give its name, partial key, and identifying relationship.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">c. What constraints do the partial key and the identifying relationship of the weak entity type specify in this diagram?</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">d. List the names of all relationship types, and specify the (min, max) constraint on each participation of an entity type in a relationship type. Justify your choices.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">e. List concisely the user requirements that led to this ER schema design.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">f. Suppose that every customer must have at least one account but is restricted to at most two loans at a time, and that a bank branch cannot have more than 1,000 loans. How does this show up on the (min, max) constraints?</p></blockquote>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.24.</strong> Consider the ER diagram in <a href="#filepos836125" class="calibre41">Figure 7.22</a>. Assume that an employee may work in up to two departments or may not be assigned to any department. Assume that each department must have one and may have up to three phone numbers. Supply (min, max) constraints on this diagram. <em class="calibre13">State clearly any additional assumptions you make</em>. Under what conditions would the relationship HAS_PHONE be redundant in this example?</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.25.</strong> Consider the ER diagram in <a href="#filepos836348" class="calibre41">Figure 7.23</a>. Assume that a course may or may not use a textbook, but that a text by definition is a book that is used in some course. A course may not use more than five books. Instructors teach from two to four courses. Supply (min, max) constraints on this diagram. <em class="calibre13">State clearly any additional assumptions you make</em>. If we add the relationship ADOPTS, to indicate the textbook(s) that an instructor uses for a course, should it be a binary relationship between INSTRUCTOR and TEXT, or a ternary relationship between all three entity types? What (min, max) constraints would you put on it? Why?</p></blockquote><div class="calibre31"> </div>
<p class="calibre7"><a class="calibre3"></a><a id="filepos835930" class="calibre3"></a><img alt="image" src="../images/00172.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 7.21</strong><br class="calibre1"/>An ER diagram for a BANK database schema.</p><div class="calibre31"> </div>
<p id="filepos836125" class="calibre7"><img alt="image" src="../images/00173.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 7.22</strong><br class="calibre1"/>Part of an ER diagram for a COMPANY database.</p><div class="calibre31"> </div>
<p id="filepos836348" class="calibre7"><a class="calibre3"></a><img alt="image" src="../images/00174.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 7.23</strong><br class="calibre1"/>Part of an ER diagram for a COURSES database.</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.26.</strong> Consider an entity type SECTION in a UNIVERSITY database, which describes the section offerings of courses. The attributes of SECTION are Section_number, Semester, Year, Course_number, Instructor, Room_no (where section is taught), Building (where section is taught), Weekdays (domain is the possible combinations of weekdays in which a section can be offered {‘MWF’, ‘MW’, ‘TT’, and so on}), and Hours (domain is all possible time periods during which sections are offered {‘9–9:50 <small class="calibre66"><span class="calibre67">A.M</span></small>.’, ‘10–10:50 <small class="calibre66"><span class="calibre67">A.M</span></small>.’, ..., ‘3:30–4:50 <small class="calibre66"><span class="calibre67">P.M</span></small>.’, ‘5:30–6:20 <small class="calibre66"><span class="calibre67">P.M</span></small>.’, and so on}). Assume that Section_number is unique for each course within a particular semester/year combination (that is, if a course is offered multiple times during a particular semester, its section offerings are numbered 1, 2, 3, and so on). There are several composite keys for section, and some attributes are components of more than one key. Identify three composite keys, and show how they can be represented in an ER schema diagram.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.27.</strong> Cardinality ratios often dictate the detailed design of a database. The cardinality ratio depends on the real-world meaning of the entity types involved and is defined by the specific application. For the following binary relationships, suggest cardinality ratios based on the common-sense meaning of the entity types. Clearly state any assumptions you make.</p></blockquote><div class="calibre31"> </div>
<p class="calibre7"><img alt="image" src="../images/00175.jpg" class="calibre16"/></p>
<blockquote class="calibre30"><p class="calibre63"><a class="calibre3"></a><strong class="calibre6">7.28.</strong> Consider the ER schema for the MOVIES database in <a href="#filepos839207" class="calibre41">Figure 7.24</a>.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">Assume that MOVIES is a populated database. ACTOR is used as a generic term and includes actresses. Given the constraints shown in the ER schema, respond to the following statements with <em class="calibre13">True, False</em>, or <em class="calibre13">Maybe</em>. Assign a response of <em class="calibre13">Maybe</em> to statements that, while not explicitly shown to be <em class="calibre13">True</em>, cannot be proven <em class="calibre13">False</em> based on the schema as shown. Justify each answer.</p></blockquote><div class="calibre31"> </div>
<p id="filepos839207" class="calibre7"><img alt="image" src="../images/00176.jpg" class="calibre16"/></p>
<p class="calibre58"><strong class="calibre6">Figure 7.24</strong><br class="calibre1"/>An ER diagram for a MOVIES database schema.</p><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40"><a id="filepos839469" class="calibre3"></a>a. There are no actors in this database that have been in no movies.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">b. There are some actors who have acted in more than ten movies.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">c. Some actors have done a lead role in multiple movies.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">d. A movie can have only a maximum of two lead actors.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">e. Every director has been an actor in some movie.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">f. No producer has ever been an actor.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">g. A producer cannot be an actor in some other movie.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">h. There are movies with more than a dozen actors.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">i. Some producers have been a director as well.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">j. Most movies have one director and one producer.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">k. Some movies have one director but several producers.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">l. There are some actors who have done a lead role, directed a movie, and produced some movie.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">m. No movie has a director who also acted in that movie.</p></blockquote>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.29.</strong> Given the ER schema for the MOVIES database in <a href="#filepos839207" class="calibre41">Figure 7.24</a>, draw an instance diagram using three movies that have been released recently. Draw instances of each entity type: MOVIES, ACTORS, PRODUCERS, DIRECTORS involved; make up instances of the relationships as they exist in reality for those movies.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.30.</strong> Illustrate the UML Diagram for Exercise 7.16. Your UML design should observe the following requirements:</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre40">a. A student should have the ability to compute his/her GPA and add or drop majors and minors.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">b. Each department should be to able add or delete courses and hire or terminate faculty.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40">c. Each instructor should be able to assign or change a student’s grade for a course.</p></blockquote>
<blockquote class="calibre30"><p class="calibre40"><em class="calibre13">Note</em>: Some of these functions may be spread over multiple classes.</p></blockquote>
<h4 id="filepos842575" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">Laboratory Exercises</span></span></blockquote></h4><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.31.</strong> Consider the UNIVERSITY database described in Exercise 7.16. Build the ER schema for this database using a data modeling tool such as ERwin or Rational Rose.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.32.</strong> Consider a MAIL_ORDER database in which employees take orders for parts from customers. The data requirements are summarized as follows:</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre61"><img alt="image" src="../images/00003.jpg" class="calibre16"/> The mail order company has employees, each identified by a unique employee number, first and last name, and Zip Code.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre61"><img alt="image" src="../images/00003.jpg" class="calibre16"/> Each customer of the company is identified by a unique customer number, first and last name, and Zip Code.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre61"><a class="calibre3"></a><img alt="image" src="../images/00003.jpg" class="calibre16"/> Each part sold by the company is identified by a unique part number, a part name, price, and quantity in stock.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre61"><img alt="image" src="../images/00003.jpg" class="calibre16"/> Each order placed by a customer is taken by an employee and is given a unique order number. Each order contains specified quantities of one or more parts. Each order has a date of receipt as well as an expected ship date. The actual ship date is also recorded.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">Design an Entity-Relationship diagram for the mail order database and build the design using a data modeling tool such as ERwin or Rational Rose.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.33.</strong> Consider a MOVIE database in which data is recorded about the movie industry. The data requirements are summarized as follows:</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre61"><img alt="image" src="../images/00003.jpg" class="calibre16"/> Each movie is identified by title and year of release. Each movie has a length in minutes. Each has a production company, and each is classified under one or more genres (such as horror, action, drama, and so forth). Each movie has one or more directors and one or more actors appear in it. Each movie also has a plot outline. Finally, each movie has zero or more quotable quotes, each of which is spoken by a particular actor appearing in the movie.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre61"><img alt="image" src="../images/00003.jpg" class="calibre16"/> Actors are identified by name and date of birth and appear in one or more movies. Each actor has a role in the movie.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre61"><img alt="image" src="../images/00003.jpg" class="calibre16"/> Directors are also identified by name and date of birth and direct one or more movies. It is possible for a director to act in a movie (including one that he or she may also direct).</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre61"><img alt="image" src="../images/00003.jpg" class="calibre16"/> Production companies are identified by name and each has an address. A production company produces one or more movies.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">Design an Entity-Relationship diagram for the movie database and enter the design using a data modeling tool such as ERwin or Rational Rose.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.34.</strong> Consider a CONFERENCE_REVIEW database in which researchers submit their research papers for consideration. Reviews by reviewers are recorded for use in the paper selection process. The database system caters primarily to reviewers who record answers to evaluation questions for each paper they review and make recommendations regarding whether to accept or reject the paper. The data requirements are summarized as follows:</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre61"><img alt="image" src="../images/00003.jpg" class="calibre16"/> Authors of papers are uniquely identified by e-mail id. First and last names are also recorded.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre61"><img alt="image" src="../images/00003.jpg" class="calibre16"/> Each paper is assigned a unique identifier by the system and is described by a title, abstract, and the name of the electronic file containing the paper.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre61"><img alt="image" src="../images/00003.jpg" class="calibre16"/> A paper may have multiple authors, but one of the authors is designated as the contact author.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre61"><img alt="image" src="../images/00003.jpg" class="calibre16"/> Reviewers of papers are uniquely identified by e-mail address. Each reviewer’s first name, last name, phone number, affiliation, and topics of interest are also recorded.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre61"><a id="filepos847927" class="calibre3"></a><img alt="image" src="../images/00003.jpg" class="calibre16"/> Each paper is assigned between two and four reviewers. A reviewer rates each paper assigned to him or her on a scale of 1 to 10 in four categories: technical merit, readability, originality, and relevance to the conference. Finally, each reviewer provides an overall recommendation regarding each paper.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre61"><img alt="image" src="../images/00003.jpg" class="calibre16"/> Each review contains two types of written comments: one to be seen by the review committee only and the other as feedback to the author(s).</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre45"><p class="calibre18">Design an Entity-Relationship diagram for the CONFERENCE_REVIEW database and build the design using a data modeling tool such as ERwin or Rational Rose.</p></blockquote><div class="calibre31"> </div>
<blockquote class="calibre30"><p class="calibre63"><strong class="calibre6">7.35.</strong> Consider the ER diagram for the AIRLINE database shown in <a href="#filepos830733" class="calibre41">Figure 7.20</a>. Build this design using a data modeling tool such as ERwin or Rational Rose.</p></blockquote><div class="calibre31"> </div>
<h4 id="filepos849099" class="calibre57"><blockquote class="calibre30"><span class="calibre11"><span class="bold1">Selected Bibliography</span></span></blockquote></h4><div class="calibre31"> </div>
<p class="calibre18">The Entity-Relationship model was introduced by Chen (1976), and related work appears in Schmidt and Swenson (1975), Wiederhold and Elmasri (1979), and Senko (1975). Since then, numerous modifications to the ER model have been suggested. We have incorporated some of these in our presentation. Structural constraints on relationships are discussed in Abrial (1974), Elmasri and Wiederhold (1980), and Lenzerini and Santucci (1983). Multivalued and composite attributes are incorporated in the ER model in Elmasri et al. (1985). Although we did not discuss languages for the ER model and its extensions, there have been several proposals for such languages. Elmasri and Wiederhold (1981) proposed the GORDAS query language for the ER model. Another ER query language was proposed by Markowitz and Raz (1983). Senko (1980) presented a query language for Senko’s DIAM model. A formal set of operations called the ER algebra was presented by Parent and Spaccapietra (1985). Gogolla and Hohenstein (1991) presented another formal language for the ER model. Campbell et al. (1985) presented a set of ER operations and showed that they are relationally complete. A conference for the dissemination of research results related to the ER model has been held regularly since 1979. The conference, now known as the International Conference on Conceptual Modeling, has been held in Los Angeles (ER 1979, ER 1983, ER 1997), Washington, D.C. (ER 1981), Chicago (ER 1985), Dijon, France (ER 1986), New York City (ER 1987), Rome (ER 1988), Toronto (ER 1989), Lausanne, Switzerland (ER 1990), San Mateo, California (ER 1991), Karlsruhe, Germany (ER 1992), Arlington, Texas (ER 1993), Manchester, England (ER 1994), Brisbane, Australia (ER 1995), Cottbus, Germany (ER 1996), Singapore (ER 1998), Paris, France (ER 1999), Salt Lake City, Utah (ER 2000), Yokohama, Japan (ER 2001), Tampere, Finland (ER 2002), Chicago, Illinois (ER 2003), Shanghai, China (ER 2004), Klagenfurt, Austria (ER 2005), Tucson, Arizona (ER 2006), Auckland, New Zealand (ER 2007), Barcelona, Catalonia, Spain (ER 2008), and Gramado, RS, Brazil (ER 2009). The 2010 conference is to be held in Vancouver, BC, Canada.</p><div class="calibre31"> </div>  <div class="mbppagebreak" id="calibre_pb_33"></div></body>
</html>
